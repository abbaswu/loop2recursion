#!/usr/bin/env python3

'''
This Python script should be run from a Shell script by redirecting or piping a `.s` file generated by `clang -S`.

Credits: https://stackoverflow.com/questions/58425136/how-to-mark-the-boundries-of-basic-blocks-with-llvm-or-other-tools

For example: `python3 -u parse_clang_s_output.py < basicmath_small.s`.

It writes a JSON file to stdout. The JSON file contains the following layers:

- array representing all functions in an `.s` file
  - dict representing a function
    - 'name' -> str
    - 'basic_blocks' -> array represnting all basic blocks in a function
      - dict representing a basic block
        - 'name' -> str
        - 'number_of_instructions' -> int
        - 'number_of_reloads' -> int
        - 'number_of_spills' -> int

Example: `[{"name": "BF_set_key", "basic_blocks": [{"name": "entry", "number_of_instructions": 30, "number_of_reloads": 4, "number_of_spills": 9}, {"name": "for.body", "number_of_instructions": 43, "number_of_reloads": 8, "number_of_spills": 2}, {"name": "for.body.for.body_crit_edge", "number_of_instructions": 12, "number_of_reloads": 5, "number_of_spills": 3}, {"name": "for.end", "number_of_instructions": 73, "number_of_reloads": 19, "number_of_spills": 2}, {"name": "for.body50", "number_of_instructions": 14, "number_of_reloads": 5, "number_of_spills": 2}, {"name": "for.end61", "number_of_instructions": 2, "number_of_reloads": 0, "number_of_spills": 0}]}]`
'''

from enum import Enum
from json import dumps
from shlex import split
from sys import stdin, stdout


def tokenize_line(line):
    '''Tokenize line in llc --print-regusage output.
    Handles quotation marks properly (e.g. '"Hello World" \'hello world\'' is tokenized as ['"Hello World"', "'hello world'"] instead of ['"Hello', 'World"', "'hello", "world'"]).
    Credits: https://stackoverflow.com/questions/79968/split-a-string-by-spaces-preserving-quoted-substrings-in-python
    '''
    return split(line.strip(), posix=False)


# Line types
LineTypes = Enum(
    'LineTypes',
    (
        'FUNCTION',
        'BASIC_BLOCK',
        'INSTRUCTION'
    )
)


def get_types_and_arguments_of_lines(line_iterable):
    """Iterates through lines in llc --print-regusage output, tokenizes each line, and classifies each line.
    Yields line type and an argument.
        
    # Patterns to Extract from `llc`'s Output

    ```
    main:                                   # @main
    ```

    ['main:', '#', '@main']

    - tokens[0] ends with a ':'
    - tokens[-1] begins with a '@'

    - tokens[0] represents an assembly function
    - tokens[1] represents an LLVM IR function


    ```
    # %bb.0:                                # %entry
    # %bb.1:                                # %for.body.preheader
    # %bb.4:                                # %for.body8.preheader
    ```

    ['#', '%bb.4:', '#', '%for.body8.preheader']

    - tokens[0] is '#'
    - tokens[1] begins with a '%' and ends with a ':'
    - tokens[-1] begins with a '%'

    - tokens[1] represents an MIR basic block
    - tokens[-1] represents an LLVM IR basic block

    ```
    # %bb.12:
    ```

    ['#', '%bb.12:']

    - tokens[0] is '#'
    - tokens[1] begins with a '%' and ends with a ':'
    - tokens[-1] begins with a '%'
    - tokens[1] is tokens[-1]

    - tokens[1], tokens[-1] represents an MIR basic block


    ```
    .LBB0_2:                                # %for.body
    .LBB0_13:                               # %for.cond43.preheader
    ```

    ['.LBB0_13:', '#', '%for.cond43.preheader']

    - tokens[0] ends with a ':'
    - tokens[-1] begins with a '@'

    ```
    .LCPI0_0:
        .quad	4607182418800017408     # double 1
    .Lstr.12:
        .asciz	"********* ANGLE CONVERSION ***********"
        .size	.Lstr.12, 39
    ```

    ['.LCPI0_0:']

    - tokens[0] ends with a ':'

    ['.quad', '4607182418800017408', '#', 'double', '1']
    ['.asciz', '"********* ANGLE CONVERSION ***********"']

    - tokens[0] begins with a '.'


    ```
        .cfi_startproc
        .cfi_def_cfa_offset 16
        .p2align	4, 0x90
    ```

    ['.cfi_startproc']
    ['.p2align', '4,', '0x90']

    - tokens[0] begins with a '.'

    ```
        pushq	%rbp
        movl	$.Lstr, %edi
        movsd	.LCPI0_0(%rip), %xmm0   # xmm0 = mem[0],zero
        jl	.LBB0_2
    ```

    ['pushq', '%rbp']
    ['movl', '$.Lstr,', '%edi']
    ['movsd', '.LCPI0_0(%rip),', '%xmm0', '#', 'xmm0', '=', 'mem[0],zero']
    ['jl', '.LBB0_2']

    - tokens[0] DOES NOT begin with a '.'

    ```
        movsd	%xmm0, 16(%rsp)         # 8-byte Spill
        movsd	8(%rsp), %xmm1          # 8-byte Reload
    ```

    ['movsd', '%xmm0,', '16(%rsp)', '#', '8-byte', 'Spill']
    ['movsd', '8(%rsp),', '%xmm1', '#', '8-byte', 'Reload']

    - tokens[0] DOES NOT begin with a '.'
    - tokens[-1] is 'Spill' or 'Reload'

    ```
                                            #   in Loop: Header=BB0_16 Depth=4
                                            # =>This Inner Loop Header: Depth=1
                                            # =>This Inner Loop Header: Depth=1
                                            # =>This Loop Header: Depth=1
                                            #     Child Loop BB0_14 Depth 2
                                            #       Child Loop BB0_15 Depth 3
                                            #         Child Loop BB0_16 Depth 4
                                            #           Child Loop BB0_18 Depth 5
    ```

    ['#', 'in', 'Loop:', 'Header=BB0_16', 'Depth=4']
    ['#', '=>This', 'Inner', 'Loop', 'Header:', 'Depth=1']
    ['#', 'Child', 'Loop', 'BB0_18', 'Depth', '5']

    - tokens[0] is '#'
    """
    for line in line_iterable:
        tokens = tokenize_line(line)
        if tokens:
            if tokens[0].startswith('#'):
                if len(tokens) > 1 and tokens[-1].startswith('%') and not (tokens[1] is tokens[-1]):
                    # Start of LLVM IR Basic Block, but not Start of Machine Code Basic Block
                    # Line Type: LineTypes.BASIC_BLOCK
                    # Argument: LLVM IR Basic Block Name (without the '%', as obtained by `llvm::BasicBlock::getName()`)
                    basic_block_name = tokens[-1][1:]
                    assert basic_block_name
                    yield LineTypes.BASIC_BLOCK, basic_block_name
                else:
                    # Regular Comment
                    # Do nothing
                    pass
            elif tokens[0].endswith(':'):
                if len(tokens) > 1:
                    if tokens[-1].startswith('@'):
                        # Start of LLVM IR Function, also Start of Machine Code Function
                        # Line Type: LineTypes.FUNCTION
                        # Argument: LLVM IR Function Name (without the '@', as obtained by `llvm::Function::getName()`)
                        function_name = tokens[-1][1:]
                        assert function_name
                        yield LineTypes.FUNCTION, function_name
                    elif tokens[-1].startswith('%'):
                        # Start of LLVM IR Basic Block, also Start of Machine Code Basic Block
                        # Line Type: LineTypes.BASIC_BLOCK
                        # Argument: LLVM IR Basic Block Name (without the '%', as obtained by `llvm::BasicBlock::getName()`)
                        basic_block_name = tokens[-1][1:]
                        assert basic_block_name
                        yield LineTypes.BASIC_BLOCK, basic_block_name
                    else:
                        assert False, tokens
                else:
                    # Start of Machine Code Basic Block, but not Start of LLVM IR Basic Block
                    # Do nothing
                    pass
            else:
                if tokens[0].startswith('.'):
                    # Pseudo Instruction
                    # Do nothing
                    pass
                else:
                    if len(tokens) > 1 and tokens[-1] in ('Spill', 'Reload'):
                        # Instruction with Spill or Reload
                        # Line Type: LineTypes.INSTRUCTION
                        # Argument: 'Spill' or 'Reload'
                        yield LineTypes.INSTRUCTION, tokens[-1]
                    else:
                        # Instruction without Spill or Reload
                        # Line Type: LineTypes.INSTRUCTION
                        # Argument: ''
                        yield LineTypes.INSTRUCTION, ''


# States
States = Enum(
    'States',
    (
        'START',
        'HIT_FUNCTION',
        'HIT_BASIC_BLOCK',
        'HIT_INSTRUCTION',
        'END'
    )
)


def parse_clang_s_output_generator(line_iterable):
    '''
    Iterates through lines in llc --print-regusage output.
    Yields a (str, dict) tuple for each function.

    # Uses the State Machine Design Pattern
    # The following Transition Rules are assumed
    ```mermaid
    stateDiagram-v2
        START --> HIT_FUNCTION: FUNCTION / reset_function
        HIT_FUNCTION --> HIT_BASIC_BLOCK: BASIC_BLOCK / reset_basic_block
        HIT_BASIC_BLOCK --> HIT_INSTRUCTION: INSTRUCTION / handle_instruction
        HIT_INSTRUCTION --> HIT_FUNCTION: FUNCTION / yield current_function_dict, reset_function
        HIT_INSTRUCTION --> HIT_BASIC_BLOCK: BASIC_BLOCK / reset_basic_block
        HIT_INSTRUCTION --> HIT_INSTRUCTION: INSTRUCTION / handle_instruction
        HIT_INSTRUCTION --> END: EOF / yield current_function, current_function_dict
    ```
    '''
    current_state = States.START

    current_function_dict = None
    current_basic_block_dict = None

    def reset_function(function):
        nonlocal current_function_dict, current_basic_block_dict

        current_function_dict = { 'name': function, 'basic_blocks': [] }
        current_basic_block_dict = None
    

    def reset_basic_block(basic_block):
        nonlocal current_function_dict, current_basic_block_dict

        # FIX: Basic Blocks ending with a `switch` statement may be split to several consecutive Basic Blocks with the same name.
        # Handle this situation.
        if current_basic_block_dict and current_basic_block_dict['name'] == basic_block:
            pass
        else:
            current_basic_block_dict = { 'name': basic_block, 'number_of_instructions': 0, 'number_of_reloads': 0, 'number_of_spills': 0 }
            current_function_dict['basic_blocks'].append(current_basic_block_dict)
    

    def handle_instruction(argument):
        nonlocal current_function_dict, current_basic_block_dict

        current_basic_block_dict['number_of_instructions'] += 1

        if argument == 'Reload':
            current_basic_block_dict['number_of_reloads'] += 1

        elif argument == 'Spill':
            current_basic_block_dict['number_of_spills'] += 1
    

    for line_type, argument in get_types_and_arguments_of_lines(line_iterable):
        if current_state == States.START:
            assert line_type == LineTypes.FUNCTION
            # print('START -> HIT_FUNCTION')
            reset_function(argument)
            current_state = States.HIT_FUNCTION
            
        elif current_state == States.HIT_FUNCTION:
            assert line_type == LineTypes.BASIC_BLOCK
            # print('HIT_FUNCTION -> HIT_BASIC_BLOCK')
            reset_basic_block(argument)
            current_state = States.HIT_BASIC_BLOCK
            
        elif current_state == States.HIT_BASIC_BLOCK:
            assert line_type == LineTypes.INSTRUCTION
            # print('HIT_BASIC_BLOCK -> HIT_INSTRUCTION')
            handle_instruction(argument)
            current_state = States.HIT_INSTRUCTION

        elif current_state == States.HIT_INSTRUCTION:
            if line_type == LineTypes.FUNCTION:
                # print('HIT_INSTRUCTION -> HIT_FUNCTION')
                yield current_function_dict
                reset_function(argument)
                current_state = States.HIT_FUNCTION

            elif line_type == LineTypes.BASIC_BLOCK:
                # print('HIT_INSTRUCTION -> HIT_BASIC_BLOCK')
                reset_basic_block(argument)
                current_state = States.HIT_BASIC_BLOCK

            elif line_type == LineTypes.INSTRUCTION:
                # print('HIT_INSTRUCTION -> HIT_INSTRUCTION')
                handle_instruction(argument)
                current_state = States.HIT_INSTRUCTION

            else:
                assert False
        else:
            assert False
    
    assert current_state == States.HIT_INSTRUCTION
    # print('HIT_INSTRUCTION -> END')
    yield current_function_dict


if __name__ == '__main__':
    print(
        dumps(
            list(parse_clang_s_output_generator(stdin))
        ),
        file=stdout
    )

