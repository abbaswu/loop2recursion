*** IR Dump After Pre-ISel Intrinsic Lowering ***
; ModuleID = 'basicmath_small.ll'
source_filename = "basicmath_small.ll"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.int_sqrt = type { i32, i32 }

@.str.1 = private unnamed_addr constant [11 x i8] c"Solutions:\00", align 1
@.str.2 = private unnamed_addr constant [4 x i8] c" %f\00", align 1
@.str.5 = private unnamed_addr constant [17 x i8] c"sqrt(%3d) = %2d\0A\00", align 1
@.str.6 = private unnamed_addr constant [17 x i8] c"\0Asqrt(%lX) = %X\0A\00", align 1
@.str.8 = private unnamed_addr constant [31 x i8] c"%3.0f degrees = %.12f radians\0A\00", align 1
@.str.9 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.10 = private unnamed_addr constant [31 x i8] c"%.12f radians = %3.0f degrees\0A\00", align 1
@str = private unnamed_addr constant [38 x i8] c"********* CUBIC FUNCTIONS ***********\00"
@str.11 = private unnamed_addr constant [40 x i8] c"********* INTEGER SQR ROOTS ***********\00"
@str.12 = private unnamed_addr constant [39 x i8] c"********* ANGLE CONVERSION ***********\00"

; Function Attrs: nounwind uwtable
define i32 @main() #0 {
entry:
  %x = alloca [3 x double], align 16
  %solutions = alloca i32, align 4
  %q = alloca %struct.int_sqrt, align 4
  %0 = bitcast [3 x double]* %x to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %0) #4
  %1 = bitcast i32* %solutions to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #4
  %2 = bitcast %struct.int_sqrt* %q to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #4
  %puts = tail call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* getelementptr inbounds ([38 x i8], [38 x i8]* @str, i64 0, i64 0)) #4
  %arraydecay = getelementptr inbounds [3 x double], [3 x double]* %x, i64 0, i64 0
  call void @SolveCubic(double 1.000000e+00, double -1.050000e+01, double 3.200000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %3 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp194 = icmp sgt i32 %3, 0
  br i1 %cmp194, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body, %for.body.preheader
  %indvars.iv213 = phi i64 [ %indvars.iv.next214, %for.body ], [ 0, %for.body.preheader ]
  %arrayidx = getelementptr inbounds [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv213
  %4 = load double, double* %arrayidx, align 8, !tbaa !5
  %call2 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %4)
  %indvars.iv.next214 = add nuw nsw i64 %indvars.iv213, 1
  %5 = load i32, i32* %solutions, align 4, !tbaa !1
  %6 = sext i32 %5 to i64
  %cmp = icmp slt i64 %indvars.iv.next214, %6
  br i1 %cmp, label %for.body, label %for.end.loopexit

for.end.loopexit:                                 ; preds = %for.body
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %entry
  %putchar = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -4.500000e+00, double 1.700000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call5 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %7 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp7192 = icmp sgt i32 %7, 0
  br i1 %cmp7192, label %for.body8.preheader, label %for.end14

for.body8.preheader:                              ; preds = %for.end
  br label %for.body8

for.body8:                                        ; preds = %for.body8, %for.body8.preheader
  %indvars.iv211 = phi i64 [ %indvars.iv.next212, %for.body8 ], [ 0, %for.body8.preheader ]
  %arrayidx10 = getelementptr inbounds [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv211
  %8 = load double, double* %arrayidx10, align 8, !tbaa !5
  %call11 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %8)
  %indvars.iv.next212 = add nuw nsw i64 %indvars.iv211, 1
  %9 = load i32, i32* %solutions, align 4, !tbaa !1
  %10 = sext i32 %9 to i64
  %cmp7 = icmp slt i64 %indvars.iv.next212, %10
  br i1 %cmp7, label %for.body8, label %for.end14.loopexit

for.end14.loopexit:                               ; preds = %for.body8
  br label %for.end14

for.end14:                                        ; preds = %for.end14.loopexit, %for.end
  %putchar173 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -3.500000e+00, double 2.200000e+01, double -3.100000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call17 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %11 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp19190 = icmp sgt i32 %11, 0
  br i1 %cmp19190, label %for.body20.preheader, label %for.end26

for.body20.preheader:                             ; preds = %for.end14
  br label %for.body20

for.body20:                                       ; preds = %for.body20, %for.body20.preheader
  %indvars.iv209 = phi i64 [ %indvars.iv.next210, %for.body20 ], [ 0, %for.body20.preheader ]
  %arrayidx22 = getelementptr inbounds [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv209
  %12 = load double, double* %arrayidx22, align 8, !tbaa !5
  %call23 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %12)
  %indvars.iv.next210 = add nuw nsw i64 %indvars.iv209, 1
  %13 = load i32, i32* %solutions, align 4, !tbaa !1
  %14 = sext i32 %13 to i64
  %cmp19 = icmp slt i64 %indvars.iv.next210, %14
  br i1 %cmp19, label %for.body20, label %for.end26.loopexit

for.end26.loopexit:                               ; preds = %for.body20
  br label %for.end26

for.end26:                                        ; preds = %for.end26.loopexit, %for.end14
  %putchar174 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -1.370000e+01, double 1.000000e+00, double -3.500000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call29 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %15 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp31188 = icmp sgt i32 %15, 0
  br i1 %cmp31188, label %for.body32.preheader, label %for.end38

for.body32.preheader:                             ; preds = %for.end26
  br label %for.body32

for.body32:                                       ; preds = %for.body32, %for.body32.preheader
  %indvars.iv207 = phi i64 [ %indvars.iv.next208, %for.body32 ], [ 0, %for.body32.preheader ]
  %arrayidx34 = getelementptr inbounds [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv207
  %16 = load double, double* %arrayidx34, align 8, !tbaa !5
  %call35 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %16)
  %indvars.iv.next208 = add nuw nsw i64 %indvars.iv207, 1
  %17 = load i32, i32* %solutions, align 4, !tbaa !1
  %18 = sext i32 %17 to i64
  %cmp31 = icmp slt i64 %indvars.iv.next208, %18
  br i1 %cmp31, label %for.body32, label %for.end38.loopexit

for.end38.loopexit:                               ; preds = %for.body32
  br label %for.end38

for.end38:                                        ; preds = %for.end38.loopexit, %for.end26
  %putchar175 = call i32 @putchar(i32 10) #4
  br label %for.cond43.preheader

for.cond43.preheader:                             ; preds = %for.inc71, %for.end38
  %a1.0187.int = phi i32 [ 1, %for.end38 ], [ %inc72.int, %for.inc71 ]
  %indvar.conv205 = sitofp i32 %a1.0187.int to double
  br label %for.cond46.preheader

for.cond46.preheader:                             ; preds = %for.inc68, %for.cond43.preheader
  %b1.0186.int = phi i32 [ 10, %for.cond43.preheader ], [ %dec69.int, %for.inc68 ]
  %indvar.conv203 = sitofp i32 %b1.0186.int to double
  br label %for.cond49.preheader

for.cond49.preheader:                             ; preds = %for.inc66, %for.cond46.preheader
  %c1.0185 = phi double [ 5.000000e+00, %for.cond46.preheader ], [ %add, %for.inc66 ]
  br label %for.body51

for.body51:                                       ; preds = %for.end62, %for.cond49.preheader
  %d1.0184.int = phi i32 [ -1, %for.cond49.preheader ], [ %dec.int, %for.end62 ]
  %indvar.conv201 = sitofp i32 %d1.0184.int to double
  call void @SolveCubic(double %indvar.conv205, double %indvar.conv203, double %c1.0185, double %indvar.conv201, i32* nonnull %solutions, double* %arraydecay) #4
  %call53 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %19 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp55182 = icmp sgt i32 %19, 0
  br i1 %cmp55182, label %for.body56.preheader, label %for.end62

for.body56.preheader:                             ; preds = %for.body51
  br label %for.body56

for.body56:                                       ; preds = %for.body56, %for.body56.preheader
  %indvars.iv198 = phi i64 [ %indvars.iv.next199, %for.body56 ], [ 0, %for.body56.preheader ]
  %arrayidx58 = getelementptr inbounds [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv198
  %20 = load double, double* %arrayidx58, align 8, !tbaa !5
  %call59 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %20)
  %indvars.iv.next199 = add nuw nsw i64 %indvars.iv198, 1
  %21 = load i32, i32* %solutions, align 4, !tbaa !1
  %22 = sext i32 %21 to i64
  %cmp55 = icmp slt i64 %indvars.iv.next199, %22
  br i1 %cmp55, label %for.body56, label %for.end62.loopexit

for.end62.loopexit:                               ; preds = %for.body56
  br label %for.end62

for.end62:                                        ; preds = %for.end62.loopexit, %for.body51
  %putchar178 = call i32 @putchar(i32 10) #4
  %dec.int = add nsw i32 %d1.0184.int, -1
  %cmp50 = icmp sgt i32 %dec.int, -11
  br i1 %cmp50, label %for.body51, label %for.inc66, !llvm.loop !7

for.inc66:                                        ; preds = %for.end62
  %add = fadd double %c1.0185, 5.000000e-01
  %cmp47 = fcmp olt double %add, 1.500000e+01
  br i1 %cmp47, label %for.cond49.preheader, label %for.inc68

for.inc68:                                        ; preds = %for.inc66
  %dec69.int = add nsw i32 %b1.0186.int, -1
  %cmp44 = icmp sgt i32 %b1.0186.int, 1
  br i1 %cmp44, label %for.cond46.preheader, label %for.inc71, !llvm.loop !7

for.inc71:                                        ; preds = %for.inc68
  %inc72.int = add nuw nsw i32 %a1.0187.int, 1
  %exitcond206 = icmp eq i32 %inc72.int, 10
  br i1 %exitcond206, label %for.end73, label %for.cond43.preheader, !llvm.loop !7

for.end73:                                        ; preds = %for.inc71
  %puts176 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([40 x i8], [40 x i8]* @str.11, i64 0, i64 0)) #4
  %sqrt = getelementptr inbounds %struct.int_sqrt, %struct.int_sqrt* %q, i64 0, i32 0
  br label %for.body77

for.body77:                                       ; preds = %for.body77, %for.end73
  %indvars.iv = phi i64 [ 0, %for.end73 ], [ %indvars.iv.next, %for.body77 ]
  call void @usqrt(i64 %indvars.iv, %struct.int_sqrt* nonnull %q) #4
  %23 = load i32, i32* %sqrt, align 4, !tbaa !9
  %24 = trunc i64 %indvars.iv to i32
  %call78 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.5, i64 0, i64 0), i32 %24, i32 %23)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond197 = icmp eq i64 %indvars.iv.next, 1001
  br i1 %exitcond197, label %for.end81, label %for.body77, !llvm.loop !7

for.end81:                                        ; preds = %for.body77
  call void @usqrt(i64 1072497001, %struct.int_sqrt* nonnull %q) #4
  %25 = load i32, i32* %sqrt, align 4, !tbaa !9
  %call83 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.6, i64 0, i64 0), i64 1072497001, i32 %25)
  %puts177 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @str.12, i64 0, i64 0)) #4
  br label %for.body88

for.body88:                                       ; preds = %for.body88, %for.end81
  %X.0180.int = phi i32 [ 0, %for.end81 ], [ %add93.int, %for.body88 ]
  %indvar.conv = sitofp i32 %X.0180.int to double
  %mul90 = fmul double %indvar.conv, 0x400921FB54442D18
  %div = fdiv double %mul90, 1.800000e+02
  %call91 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.8, i64 0, i64 0), double %indvar.conv, double %div)
  %add93.int = add nuw nsw i32 %X.0180.int, 1
  %exitcond = icmp eq i32 %add93.int, 361
  br i1 %exitcond, label %for.end94, label %for.body88

for.end94:                                        ; preds = %for.body88
  %call95 = call i32 (i8*, ...) bitcast (i32 (...)* @puts to i32 (i8*, ...)*)(i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.9, i64 0, i64 0)) #4
  br label %for.body103

for.body103:                                      ; preds = %for.body103, %for.end94
  %X.1179 = phi double [ 0.000000e+00, %for.end94 ], [ %add113, %for.body103 ]
  %mul104 = fmul double %X.1179, 1.800000e+02
  %div107 = fdiv double %mul104, 0x400921FB54442D18
  %call108 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.10, i64 0, i64 0), double %X.1179, double %div107)
  %add113 = fadd double %X.1179, 0x3F91DF46A2529D39
  %cmp101 = fcmp ugt double %add113, 0x401921FB97600B9B
  br i1 %cmp101, label %for.end114, label %for.body103

for.end114:                                       ; preds = %for.body103
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %1) #4
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %0) #4
  ret i32 0
}

; Function Attrs: nounwind
declare i32 @printf(i8* nocapture readonly, ...) #1

declare void @SolveCubic(double, double, double, double, i32*, double*) #2

declare void @usqrt(i64, %struct.int_sqrt*) #2

declare i32 @puts(...) #2

declare i32 @putchar(i32)

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.lifetime.start.p0i8(i64 immarg, i8* nocapture) #3

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.lifetime.end.p0i8(i64 immarg, i8* nocapture) #3

attributes #0 = { nounwind uwtable "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind willreturn }
attributes #4 = { nounwind }

!llvm.ident = !{!0}

!0 = !{!"clang version 3.8.0 (tags/RELEASE_380/final)"}
!1 = !{!2, !2, i64 0}
!2 = !{!"int", !3, i64 0}
!3 = !{!"omnipotent char", !4, i64 0}
!4 = !{!"Simple C/C++ TBAA"}
!5 = !{!6, !6, i64 0}
!6 = !{!"double", !3, i64 0}
!7 = distinct !{!7, !8}
!8 = !{!"llvm.loop.loop2recursion.copy.enable"}
!9 = !{!10, !2, i64 0}
!10 = !{!"int_sqrt", !2, i64 0, !2, i64 4}
*** IR Dump After Expand Atomic instructions ***
; Function Attrs: nounwind uwtable
define i32 @main() #0 {
entry:
  %x = alloca [3 x double], align 16
  %solutions = alloca i32, align 4
  %q = alloca %struct.int_sqrt, align 4
  %0 = bitcast [3 x double]* %x to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %0) #4
  %1 = bitcast i32* %solutions to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #4
  %2 = bitcast %struct.int_sqrt* %q to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #4
  %puts = tail call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* getelementptr inbounds ([38 x i8], [38 x i8]* @str, i64 0, i64 0)) #4
  %arraydecay = getelementptr inbounds [3 x double], [3 x double]* %x, i64 0, i64 0
  call void @SolveCubic(double 1.000000e+00, double -1.050000e+01, double 3.200000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %3 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp194 = icmp sgt i32 %3, 0
  br i1 %cmp194, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body, %for.body.preheader
  %indvars.iv213 = phi i64 [ %indvars.iv.next214, %for.body ], [ 0, %for.body.preheader ]
  %arrayidx = getelementptr inbounds [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv213
  %4 = load double, double* %arrayidx, align 8, !tbaa !5
  %call2 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %4)
  %indvars.iv.next214 = add nuw nsw i64 %indvars.iv213, 1
  %5 = load i32, i32* %solutions, align 4, !tbaa !1
  %6 = sext i32 %5 to i64
  %cmp = icmp slt i64 %indvars.iv.next214, %6
  br i1 %cmp, label %for.body, label %for.end.loopexit

for.end.loopexit:                                 ; preds = %for.body
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %entry
  %putchar = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -4.500000e+00, double 1.700000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call5 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %7 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp7192 = icmp sgt i32 %7, 0
  br i1 %cmp7192, label %for.body8.preheader, label %for.end14

for.body8.preheader:                              ; preds = %for.end
  br label %for.body8

for.body8:                                        ; preds = %for.body8, %for.body8.preheader
  %indvars.iv211 = phi i64 [ %indvars.iv.next212, %for.body8 ], [ 0, %for.body8.preheader ]
  %arrayidx10 = getelementptr inbounds [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv211
  %8 = load double, double* %arrayidx10, align 8, !tbaa !5
  %call11 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %8)
  %indvars.iv.next212 = add nuw nsw i64 %indvars.iv211, 1
  %9 = load i32, i32* %solutions, align 4, !tbaa !1
  %10 = sext i32 %9 to i64
  %cmp7 = icmp slt i64 %indvars.iv.next212, %10
  br i1 %cmp7, label %for.body8, label %for.end14.loopexit

for.end14.loopexit:                               ; preds = %for.body8
  br label %for.end14

for.end14:                                        ; preds = %for.end14.loopexit, %for.end
  %putchar173 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -3.500000e+00, double 2.200000e+01, double -3.100000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call17 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %11 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp19190 = icmp sgt i32 %11, 0
  br i1 %cmp19190, label %for.body20.preheader, label %for.end26

for.body20.preheader:                             ; preds = %for.end14
  br label %for.body20

for.body20:                                       ; preds = %for.body20, %for.body20.preheader
  %indvars.iv209 = phi i64 [ %indvars.iv.next210, %for.body20 ], [ 0, %for.body20.preheader ]
  %arrayidx22 = getelementptr inbounds [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv209
  %12 = load double, double* %arrayidx22, align 8, !tbaa !5
  %call23 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %12)
  %indvars.iv.next210 = add nuw nsw i64 %indvars.iv209, 1
  %13 = load i32, i32* %solutions, align 4, !tbaa !1
  %14 = sext i32 %13 to i64
  %cmp19 = icmp slt i64 %indvars.iv.next210, %14
  br i1 %cmp19, label %for.body20, label %for.end26.loopexit

for.end26.loopexit:                               ; preds = %for.body20
  br label %for.end26

for.end26:                                        ; preds = %for.end26.loopexit, %for.end14
  %putchar174 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -1.370000e+01, double 1.000000e+00, double -3.500000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call29 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %15 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp31188 = icmp sgt i32 %15, 0
  br i1 %cmp31188, label %for.body32.preheader, label %for.end38

for.body32.preheader:                             ; preds = %for.end26
  br label %for.body32

for.body32:                                       ; preds = %for.body32, %for.body32.preheader
  %indvars.iv207 = phi i64 [ %indvars.iv.next208, %for.body32 ], [ 0, %for.body32.preheader ]
  %arrayidx34 = getelementptr inbounds [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv207
  %16 = load double, double* %arrayidx34, align 8, !tbaa !5
  %call35 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %16)
  %indvars.iv.next208 = add nuw nsw i64 %indvars.iv207, 1
  %17 = load i32, i32* %solutions, align 4, !tbaa !1
  %18 = sext i32 %17 to i64
  %cmp31 = icmp slt i64 %indvars.iv.next208, %18
  br i1 %cmp31, label %for.body32, label %for.end38.loopexit

for.end38.loopexit:                               ; preds = %for.body32
  br label %for.end38

for.end38:                                        ; preds = %for.end38.loopexit, %for.end26
  %putchar175 = call i32 @putchar(i32 10) #4
  br label %for.cond43.preheader

for.cond43.preheader:                             ; preds = %for.inc71, %for.end38
  %a1.0187.int = phi i32 [ 1, %for.end38 ], [ %inc72.int, %for.inc71 ]
  %indvar.conv205 = sitofp i32 %a1.0187.int to double
  br label %for.cond46.preheader

for.cond46.preheader:                             ; preds = %for.inc68, %for.cond43.preheader
  %b1.0186.int = phi i32 [ 10, %for.cond43.preheader ], [ %dec69.int, %for.inc68 ]
  %indvar.conv203 = sitofp i32 %b1.0186.int to double
  br label %for.cond49.preheader

for.cond49.preheader:                             ; preds = %for.inc66, %for.cond46.preheader
  %c1.0185 = phi double [ 5.000000e+00, %for.cond46.preheader ], [ %add, %for.inc66 ]
  br label %for.body51

for.body51:                                       ; preds = %for.end62, %for.cond49.preheader
  %d1.0184.int = phi i32 [ -1, %for.cond49.preheader ], [ %dec.int, %for.end62 ]
  %indvar.conv201 = sitofp i32 %d1.0184.int to double
  call void @SolveCubic(double %indvar.conv205, double %indvar.conv203, double %c1.0185, double %indvar.conv201, i32* nonnull %solutions, double* %arraydecay) #4
  %call53 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %19 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp55182 = icmp sgt i32 %19, 0
  br i1 %cmp55182, label %for.body56.preheader, label %for.end62

for.body56.preheader:                             ; preds = %for.body51
  br label %for.body56

for.body56:                                       ; preds = %for.body56, %for.body56.preheader
  %indvars.iv198 = phi i64 [ %indvars.iv.next199, %for.body56 ], [ 0, %for.body56.preheader ]
  %arrayidx58 = getelementptr inbounds [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv198
  %20 = load double, double* %arrayidx58, align 8, !tbaa !5
  %call59 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %20)
  %indvars.iv.next199 = add nuw nsw i64 %indvars.iv198, 1
  %21 = load i32, i32* %solutions, align 4, !tbaa !1
  %22 = sext i32 %21 to i64
  %cmp55 = icmp slt i64 %indvars.iv.next199, %22
  br i1 %cmp55, label %for.body56, label %for.end62.loopexit

for.end62.loopexit:                               ; preds = %for.body56
  br label %for.end62

for.end62:                                        ; preds = %for.end62.loopexit, %for.body51
  %putchar178 = call i32 @putchar(i32 10) #4
  %dec.int = add nsw i32 %d1.0184.int, -1
  %cmp50 = icmp sgt i32 %dec.int, -11
  br i1 %cmp50, label %for.body51, label %for.inc66, !llvm.loop !7

for.inc66:                                        ; preds = %for.end62
  %add = fadd double %c1.0185, 5.000000e-01
  %cmp47 = fcmp olt double %add, 1.500000e+01
  br i1 %cmp47, label %for.cond49.preheader, label %for.inc68

for.inc68:                                        ; preds = %for.inc66
  %dec69.int = add nsw i32 %b1.0186.int, -1
  %cmp44 = icmp sgt i32 %b1.0186.int, 1
  br i1 %cmp44, label %for.cond46.preheader, label %for.inc71, !llvm.loop !7

for.inc71:                                        ; preds = %for.inc68
  %inc72.int = add nuw nsw i32 %a1.0187.int, 1
  %exitcond206 = icmp eq i32 %inc72.int, 10
  br i1 %exitcond206, label %for.end73, label %for.cond43.preheader, !llvm.loop !7

for.end73:                                        ; preds = %for.inc71
  %puts176 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([40 x i8], [40 x i8]* @str.11, i64 0, i64 0)) #4
  %sqrt = getelementptr inbounds %struct.int_sqrt, %struct.int_sqrt* %q, i64 0, i32 0
  br label %for.body77

for.body77:                                       ; preds = %for.body77, %for.end73
  %indvars.iv = phi i64 [ 0, %for.end73 ], [ %indvars.iv.next, %for.body77 ]
  call void @usqrt(i64 %indvars.iv, %struct.int_sqrt* nonnull %q) #4
  %23 = load i32, i32* %sqrt, align 4, !tbaa !9
  %24 = trunc i64 %indvars.iv to i32
  %call78 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.5, i64 0, i64 0), i32 %24, i32 %23)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond197 = icmp eq i64 %indvars.iv.next, 1001
  br i1 %exitcond197, label %for.end81, label %for.body77, !llvm.loop !7

for.end81:                                        ; preds = %for.body77
  call void @usqrt(i64 1072497001, %struct.int_sqrt* nonnull %q) #4
  %25 = load i32, i32* %sqrt, align 4, !tbaa !9
  %call83 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.6, i64 0, i64 0), i64 1072497001, i32 %25)
  %puts177 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @str.12, i64 0, i64 0)) #4
  br label %for.body88

for.body88:                                       ; preds = %for.body88, %for.end81
  %X.0180.int = phi i32 [ 0, %for.end81 ], [ %add93.int, %for.body88 ]
  %indvar.conv = sitofp i32 %X.0180.int to double
  %mul90 = fmul double %indvar.conv, 0x400921FB54442D18
  %div = fdiv double %mul90, 1.800000e+02
  %call91 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.8, i64 0, i64 0), double %indvar.conv, double %div)
  %add93.int = add nuw nsw i32 %X.0180.int, 1
  %exitcond = icmp eq i32 %add93.int, 361
  br i1 %exitcond, label %for.end94, label %for.body88

for.end94:                                        ; preds = %for.body88
  %call95 = call i32 (i8*, ...) bitcast (i32 (...)* @puts to i32 (i8*, ...)*)(i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.9, i64 0, i64 0)) #4
  br label %for.body103

for.body103:                                      ; preds = %for.body103, %for.end94
  %X.1179 = phi double [ 0.000000e+00, %for.end94 ], [ %add113, %for.body103 ]
  %mul104 = fmul double %X.1179, 1.800000e+02
  %div107 = fdiv double %mul104, 0x400921FB54442D18
  %call108 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.10, i64 0, i64 0), double %X.1179, double %div107)
  %add113 = fadd double %X.1179, 0x3F91DF46A2529D39
  %cmp101 = fcmp ugt double %add113, 0x401921FB97600B9B
  br i1 %cmp101, label %for.end114, label %for.body103

for.end114:                                       ; preds = %for.body103
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %1) #4
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %0) #4
  ret i32 0
}
*** IR Dump After Module Verifier ***
; Function Attrs: nounwind uwtable
define i32 @main() #0 {
entry:
  %x = alloca [3 x double], align 16
  %solutions = alloca i32, align 4
  %q = alloca %struct.int_sqrt, align 4
  %0 = bitcast [3 x double]* %x to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %0) #4
  %1 = bitcast i32* %solutions to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #4
  %2 = bitcast %struct.int_sqrt* %q to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #4
  %puts = tail call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* getelementptr inbounds ([38 x i8], [38 x i8]* @str, i64 0, i64 0)) #4
  %arraydecay = getelementptr inbounds [3 x double], [3 x double]* %x, i64 0, i64 0
  call void @SolveCubic(double 1.000000e+00, double -1.050000e+01, double 3.200000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %3 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp194 = icmp sgt i32 %3, 0
  br i1 %cmp194, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body, %for.body.preheader
  %indvars.iv213 = phi i64 [ %indvars.iv.next214, %for.body ], [ 0, %for.body.preheader ]
  %arrayidx = getelementptr inbounds [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv213
  %4 = load double, double* %arrayidx, align 8, !tbaa !5
  %call2 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %4)
  %indvars.iv.next214 = add nuw nsw i64 %indvars.iv213, 1
  %5 = load i32, i32* %solutions, align 4, !tbaa !1
  %6 = sext i32 %5 to i64
  %cmp = icmp slt i64 %indvars.iv.next214, %6
  br i1 %cmp, label %for.body, label %for.end.loopexit

for.end.loopexit:                                 ; preds = %for.body
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %entry
  %putchar = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -4.500000e+00, double 1.700000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call5 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %7 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp7192 = icmp sgt i32 %7, 0
  br i1 %cmp7192, label %for.body8.preheader, label %for.end14

for.body8.preheader:                              ; preds = %for.end
  br label %for.body8

for.body8:                                        ; preds = %for.body8, %for.body8.preheader
  %indvars.iv211 = phi i64 [ %indvars.iv.next212, %for.body8 ], [ 0, %for.body8.preheader ]
  %arrayidx10 = getelementptr inbounds [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv211
  %8 = load double, double* %arrayidx10, align 8, !tbaa !5
  %call11 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %8)
  %indvars.iv.next212 = add nuw nsw i64 %indvars.iv211, 1
  %9 = load i32, i32* %solutions, align 4, !tbaa !1
  %10 = sext i32 %9 to i64
  %cmp7 = icmp slt i64 %indvars.iv.next212, %10
  br i1 %cmp7, label %for.body8, label %for.end14.loopexit

for.end14.loopexit:                               ; preds = %for.body8
  br label %for.end14

for.end14:                                        ; preds = %for.end14.loopexit, %for.end
  %putchar173 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -3.500000e+00, double 2.200000e+01, double -3.100000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call17 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %11 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp19190 = icmp sgt i32 %11, 0
  br i1 %cmp19190, label %for.body20.preheader, label %for.end26

for.body20.preheader:                             ; preds = %for.end14
  br label %for.body20

for.body20:                                       ; preds = %for.body20, %for.body20.preheader
  %indvars.iv209 = phi i64 [ %indvars.iv.next210, %for.body20 ], [ 0, %for.body20.preheader ]
  %arrayidx22 = getelementptr inbounds [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv209
  %12 = load double, double* %arrayidx22, align 8, !tbaa !5
  %call23 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %12)
  %indvars.iv.next210 = add nuw nsw i64 %indvars.iv209, 1
  %13 = load i32, i32* %solutions, align 4, !tbaa !1
  %14 = sext i32 %13 to i64
  %cmp19 = icmp slt i64 %indvars.iv.next210, %14
  br i1 %cmp19, label %for.body20, label %for.end26.loopexit

for.end26.loopexit:                               ; preds = %for.body20
  br label %for.end26

for.end26:                                        ; preds = %for.end26.loopexit, %for.end14
  %putchar174 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -1.370000e+01, double 1.000000e+00, double -3.500000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call29 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %15 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp31188 = icmp sgt i32 %15, 0
  br i1 %cmp31188, label %for.body32.preheader, label %for.end38

for.body32.preheader:                             ; preds = %for.end26
  br label %for.body32

for.body32:                                       ; preds = %for.body32, %for.body32.preheader
  %indvars.iv207 = phi i64 [ %indvars.iv.next208, %for.body32 ], [ 0, %for.body32.preheader ]
  %arrayidx34 = getelementptr inbounds [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv207
  %16 = load double, double* %arrayidx34, align 8, !tbaa !5
  %call35 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %16)
  %indvars.iv.next208 = add nuw nsw i64 %indvars.iv207, 1
  %17 = load i32, i32* %solutions, align 4, !tbaa !1
  %18 = sext i32 %17 to i64
  %cmp31 = icmp slt i64 %indvars.iv.next208, %18
  br i1 %cmp31, label %for.body32, label %for.end38.loopexit

for.end38.loopexit:                               ; preds = %for.body32
  br label %for.end38

for.end38:                                        ; preds = %for.end38.loopexit, %for.end26
  %putchar175 = call i32 @putchar(i32 10) #4
  br label %for.cond43.preheader

for.cond43.preheader:                             ; preds = %for.inc71, %for.end38
  %a1.0187.int = phi i32 [ 1, %for.end38 ], [ %inc72.int, %for.inc71 ]
  %indvar.conv205 = sitofp i32 %a1.0187.int to double
  br label %for.cond46.preheader

for.cond46.preheader:                             ; preds = %for.inc68, %for.cond43.preheader
  %b1.0186.int = phi i32 [ 10, %for.cond43.preheader ], [ %dec69.int, %for.inc68 ]
  %indvar.conv203 = sitofp i32 %b1.0186.int to double
  br label %for.cond49.preheader

for.cond49.preheader:                             ; preds = %for.inc66, %for.cond46.preheader
  %c1.0185 = phi double [ 5.000000e+00, %for.cond46.preheader ], [ %add, %for.inc66 ]
  br label %for.body51

for.body51:                                       ; preds = %for.end62, %for.cond49.preheader
  %d1.0184.int = phi i32 [ -1, %for.cond49.preheader ], [ %dec.int, %for.end62 ]
  %indvar.conv201 = sitofp i32 %d1.0184.int to double
  call void @SolveCubic(double %indvar.conv205, double %indvar.conv203, double %c1.0185, double %indvar.conv201, i32* nonnull %solutions, double* %arraydecay) #4
  %call53 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %19 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp55182 = icmp sgt i32 %19, 0
  br i1 %cmp55182, label %for.body56.preheader, label %for.end62

for.body56.preheader:                             ; preds = %for.body51
  br label %for.body56

for.body56:                                       ; preds = %for.body56, %for.body56.preheader
  %indvars.iv198 = phi i64 [ %indvars.iv.next199, %for.body56 ], [ 0, %for.body56.preheader ]
  %arrayidx58 = getelementptr inbounds [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv198
  %20 = load double, double* %arrayidx58, align 8, !tbaa !5
  %call59 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %20)
  %indvars.iv.next199 = add nuw nsw i64 %indvars.iv198, 1
  %21 = load i32, i32* %solutions, align 4, !tbaa !1
  %22 = sext i32 %21 to i64
  %cmp55 = icmp slt i64 %indvars.iv.next199, %22
  br i1 %cmp55, label %for.body56, label %for.end62.loopexit

for.end62.loopexit:                               ; preds = %for.body56
  br label %for.end62

for.end62:                                        ; preds = %for.end62.loopexit, %for.body51
  %putchar178 = call i32 @putchar(i32 10) #4
  %dec.int = add nsw i32 %d1.0184.int, -1
  %cmp50 = icmp sgt i32 %dec.int, -11
  br i1 %cmp50, label %for.body51, label %for.inc66, !llvm.loop !7

for.inc66:                                        ; preds = %for.end62
  %add = fadd double %c1.0185, 5.000000e-01
  %cmp47 = fcmp olt double %add, 1.500000e+01
  br i1 %cmp47, label %for.cond49.preheader, label %for.inc68

for.inc68:                                        ; preds = %for.inc66
  %dec69.int = add nsw i32 %b1.0186.int, -1
  %cmp44 = icmp sgt i32 %b1.0186.int, 1
  br i1 %cmp44, label %for.cond46.preheader, label %for.inc71, !llvm.loop !7

for.inc71:                                        ; preds = %for.inc68
  %inc72.int = add nuw nsw i32 %a1.0187.int, 1
  %exitcond206 = icmp eq i32 %inc72.int, 10
  br i1 %exitcond206, label %for.end73, label %for.cond43.preheader, !llvm.loop !7

for.end73:                                        ; preds = %for.inc71
  %puts176 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([40 x i8], [40 x i8]* @str.11, i64 0, i64 0)) #4
  %sqrt = getelementptr inbounds %struct.int_sqrt, %struct.int_sqrt* %q, i64 0, i32 0
  br label %for.body77

for.body77:                                       ; preds = %for.body77, %for.end73
  %indvars.iv = phi i64 [ 0, %for.end73 ], [ %indvars.iv.next, %for.body77 ]
  call void @usqrt(i64 %indvars.iv, %struct.int_sqrt* nonnull %q) #4
  %23 = load i32, i32* %sqrt, align 4, !tbaa !9
  %24 = trunc i64 %indvars.iv to i32
  %call78 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.5, i64 0, i64 0), i32 %24, i32 %23)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond197 = icmp eq i64 %indvars.iv.next, 1001
  br i1 %exitcond197, label %for.end81, label %for.body77, !llvm.loop !7

for.end81:                                        ; preds = %for.body77
  call void @usqrt(i64 1072497001, %struct.int_sqrt* nonnull %q) #4
  %25 = load i32, i32* %sqrt, align 4, !tbaa !9
  %call83 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.6, i64 0, i64 0), i64 1072497001, i32 %25)
  %puts177 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @str.12, i64 0, i64 0)) #4
  br label %for.body88

for.body88:                                       ; preds = %for.body88, %for.end81
  %X.0180.int = phi i32 [ 0, %for.end81 ], [ %add93.int, %for.body88 ]
  %indvar.conv = sitofp i32 %X.0180.int to double
  %mul90 = fmul double %indvar.conv, 0x400921FB54442D18
  %div = fdiv double %mul90, 1.800000e+02
  %call91 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.8, i64 0, i64 0), double %indvar.conv, double %div)
  %add93.int = add nuw nsw i32 %X.0180.int, 1
  %exitcond = icmp eq i32 %add93.int, 361
  br i1 %exitcond, label %for.end94, label %for.body88

for.end94:                                        ; preds = %for.body88
  %call95 = call i32 (i8*, ...) bitcast (i32 (...)* @puts to i32 (i8*, ...)*)(i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.9, i64 0, i64 0)) #4
  br label %for.body103

for.body103:                                      ; preds = %for.body103, %for.end94
  %X.1179 = phi double [ 0.000000e+00, %for.end94 ], [ %add113, %for.body103 ]
  %mul104 = fmul double %X.1179, 1.800000e+02
  %div107 = fdiv double %mul104, 0x400921FB54442D18
  %call108 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.10, i64 0, i64 0), double %X.1179, double %div107)
  %add113 = fadd double %X.1179, 0x3F91DF46A2529D39
  %cmp101 = fcmp ugt double %add113, 0x401921FB97600B9B
  br i1 %cmp101, label %for.end114, label %for.body103

for.end114:                                       ; preds = %for.body103
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %1) #4
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %0) #4
  ret i32 0
}
*** IR Dump After Canonicalize natural loops ***
; Function Attrs: nounwind uwtable
define i32 @main() #0 {
entry:
  %x = alloca [3 x double], align 16
  %solutions = alloca i32, align 4
  %q = alloca %struct.int_sqrt, align 4
  %0 = bitcast [3 x double]* %x to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %0) #4
  %1 = bitcast i32* %solutions to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #4
  %2 = bitcast %struct.int_sqrt* %q to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #4
  %puts = tail call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* getelementptr inbounds ([38 x i8], [38 x i8]* @str, i64 0, i64 0)) #4
  %arraydecay = getelementptr inbounds [3 x double], [3 x double]* %x, i64 0, i64 0
  call void @SolveCubic(double 1.000000e+00, double -1.050000e+01, double 3.200000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %3 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp194 = icmp sgt i32 %3, 0
  br i1 %cmp194, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body, %for.body.preheader
  %indvars.iv213 = phi i64 [ %indvars.iv.next214, %for.body ], [ 0, %for.body.preheader ]
  %arrayidx = getelementptr inbounds [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv213
  %4 = load double, double* %arrayidx, align 8, !tbaa !5
  %call2 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %4)
  %indvars.iv.next214 = add nuw nsw i64 %indvars.iv213, 1
  %5 = load i32, i32* %solutions, align 4, !tbaa !1
  %6 = sext i32 %5 to i64
  %cmp = icmp slt i64 %indvars.iv.next214, %6
  br i1 %cmp, label %for.body, label %for.end.loopexit

for.end.loopexit:                                 ; preds = %for.body
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %entry
  %putchar = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -4.500000e+00, double 1.700000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call5 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %7 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp7192 = icmp sgt i32 %7, 0
  br i1 %cmp7192, label %for.body8.preheader, label %for.end14

for.body8.preheader:                              ; preds = %for.end
  br label %for.body8

for.body8:                                        ; preds = %for.body8, %for.body8.preheader
  %indvars.iv211 = phi i64 [ %indvars.iv.next212, %for.body8 ], [ 0, %for.body8.preheader ]
  %arrayidx10 = getelementptr inbounds [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv211
  %8 = load double, double* %arrayidx10, align 8, !tbaa !5
  %call11 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %8)
  %indvars.iv.next212 = add nuw nsw i64 %indvars.iv211, 1
  %9 = load i32, i32* %solutions, align 4, !tbaa !1
  %10 = sext i32 %9 to i64
  %cmp7 = icmp slt i64 %indvars.iv.next212, %10
  br i1 %cmp7, label %for.body8, label %for.end14.loopexit

for.end14.loopexit:                               ; preds = %for.body8
  br label %for.end14

for.end14:                                        ; preds = %for.end14.loopexit, %for.end
  %putchar173 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -3.500000e+00, double 2.200000e+01, double -3.100000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call17 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %11 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp19190 = icmp sgt i32 %11, 0
  br i1 %cmp19190, label %for.body20.preheader, label %for.end26

for.body20.preheader:                             ; preds = %for.end14
  br label %for.body20

for.body20:                                       ; preds = %for.body20, %for.body20.preheader
  %indvars.iv209 = phi i64 [ %indvars.iv.next210, %for.body20 ], [ 0, %for.body20.preheader ]
  %arrayidx22 = getelementptr inbounds [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv209
  %12 = load double, double* %arrayidx22, align 8, !tbaa !5
  %call23 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %12)
  %indvars.iv.next210 = add nuw nsw i64 %indvars.iv209, 1
  %13 = load i32, i32* %solutions, align 4, !tbaa !1
  %14 = sext i32 %13 to i64
  %cmp19 = icmp slt i64 %indvars.iv.next210, %14
  br i1 %cmp19, label %for.body20, label %for.end26.loopexit

for.end26.loopexit:                               ; preds = %for.body20
  br label %for.end26

for.end26:                                        ; preds = %for.end26.loopexit, %for.end14
  %putchar174 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -1.370000e+01, double 1.000000e+00, double -3.500000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call29 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %15 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp31188 = icmp sgt i32 %15, 0
  br i1 %cmp31188, label %for.body32.preheader, label %for.end38

for.body32.preheader:                             ; preds = %for.end26
  br label %for.body32

for.body32:                                       ; preds = %for.body32, %for.body32.preheader
  %indvars.iv207 = phi i64 [ %indvars.iv.next208, %for.body32 ], [ 0, %for.body32.preheader ]
  %arrayidx34 = getelementptr inbounds [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv207
  %16 = load double, double* %arrayidx34, align 8, !tbaa !5
  %call35 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %16)
  %indvars.iv.next208 = add nuw nsw i64 %indvars.iv207, 1
  %17 = load i32, i32* %solutions, align 4, !tbaa !1
  %18 = sext i32 %17 to i64
  %cmp31 = icmp slt i64 %indvars.iv.next208, %18
  br i1 %cmp31, label %for.body32, label %for.end38.loopexit

for.end38.loopexit:                               ; preds = %for.body32
  br label %for.end38

for.end38:                                        ; preds = %for.end38.loopexit, %for.end26
  %putchar175 = call i32 @putchar(i32 10) #4
  br label %for.cond43.preheader

for.cond43.preheader:                             ; preds = %for.inc71, %for.end38
  %a1.0187.int = phi i32 [ 1, %for.end38 ], [ %inc72.int, %for.inc71 ]
  %indvar.conv205 = sitofp i32 %a1.0187.int to double
  br label %for.cond46.preheader

for.cond46.preheader:                             ; preds = %for.inc68, %for.cond43.preheader
  %b1.0186.int = phi i32 [ 10, %for.cond43.preheader ], [ %dec69.int, %for.inc68 ]
  %indvar.conv203 = sitofp i32 %b1.0186.int to double
  br label %for.cond49.preheader

for.cond49.preheader:                             ; preds = %for.inc66, %for.cond46.preheader
  %c1.0185 = phi double [ 5.000000e+00, %for.cond46.preheader ], [ %add, %for.inc66 ]
  br label %for.body51

for.body51:                                       ; preds = %for.end62, %for.cond49.preheader
  %d1.0184.int = phi i32 [ -1, %for.cond49.preheader ], [ %dec.int, %for.end62 ]
  %indvar.conv201 = sitofp i32 %d1.0184.int to double
  call void @SolveCubic(double %indvar.conv205, double %indvar.conv203, double %c1.0185, double %indvar.conv201, i32* nonnull %solutions, double* %arraydecay) #4
  %call53 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %19 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp55182 = icmp sgt i32 %19, 0
  br i1 %cmp55182, label %for.body56.preheader, label %for.end62

for.body56.preheader:                             ; preds = %for.body51
  br label %for.body56

for.body56:                                       ; preds = %for.body56, %for.body56.preheader
  %indvars.iv198 = phi i64 [ %indvars.iv.next199, %for.body56 ], [ 0, %for.body56.preheader ]
  %arrayidx58 = getelementptr inbounds [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv198
  %20 = load double, double* %arrayidx58, align 8, !tbaa !5
  %call59 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %20)
  %indvars.iv.next199 = add nuw nsw i64 %indvars.iv198, 1
  %21 = load i32, i32* %solutions, align 4, !tbaa !1
  %22 = sext i32 %21 to i64
  %cmp55 = icmp slt i64 %indvars.iv.next199, %22
  br i1 %cmp55, label %for.body56, label %for.end62.loopexit

for.end62.loopexit:                               ; preds = %for.body56
  br label %for.end62

for.end62:                                        ; preds = %for.end62.loopexit, %for.body51
  %putchar178 = call i32 @putchar(i32 10) #4
  %dec.int = add nsw i32 %d1.0184.int, -1
  %cmp50 = icmp sgt i32 %dec.int, -11
  br i1 %cmp50, label %for.body51, label %for.inc66, !llvm.loop !7

for.inc66:                                        ; preds = %for.end62
  %add = fadd double %c1.0185, 5.000000e-01
  %cmp47 = fcmp olt double %add, 1.500000e+01
  br i1 %cmp47, label %for.cond49.preheader, label %for.inc68

for.inc68:                                        ; preds = %for.inc66
  %dec69.int = add nsw i32 %b1.0186.int, -1
  %cmp44 = icmp sgt i32 %b1.0186.int, 1
  br i1 %cmp44, label %for.cond46.preheader, label %for.inc71, !llvm.loop !7

for.inc71:                                        ; preds = %for.inc68
  %inc72.int = add nuw nsw i32 %a1.0187.int, 1
  %exitcond206 = icmp eq i32 %inc72.int, 10
  br i1 %exitcond206, label %for.end73, label %for.cond43.preheader, !llvm.loop !7

for.end73:                                        ; preds = %for.inc71
  %puts176 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([40 x i8], [40 x i8]* @str.11, i64 0, i64 0)) #4
  %sqrt = getelementptr inbounds %struct.int_sqrt, %struct.int_sqrt* %q, i64 0, i32 0
  br label %for.body77

for.body77:                                       ; preds = %for.body77, %for.end73
  %indvars.iv = phi i64 [ 0, %for.end73 ], [ %indvars.iv.next, %for.body77 ]
  call void @usqrt(i64 %indvars.iv, %struct.int_sqrt* nonnull %q) #4
  %23 = load i32, i32* %sqrt, align 4, !tbaa !9
  %24 = trunc i64 %indvars.iv to i32
  %call78 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.5, i64 0, i64 0), i32 %24, i32 %23)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond197 = icmp eq i64 %indvars.iv.next, 1001
  br i1 %exitcond197, label %for.end81, label %for.body77, !llvm.loop !7

for.end81:                                        ; preds = %for.body77
  call void @usqrt(i64 1072497001, %struct.int_sqrt* nonnull %q) #4
  %25 = load i32, i32* %sqrt, align 4, !tbaa !9
  %call83 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.6, i64 0, i64 0), i64 1072497001, i32 %25)
  %puts177 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @str.12, i64 0, i64 0)) #4
  br label %for.body88

for.body88:                                       ; preds = %for.body88, %for.end81
  %X.0180.int = phi i32 [ 0, %for.end81 ], [ %add93.int, %for.body88 ]
  %indvar.conv = sitofp i32 %X.0180.int to double
  %mul90 = fmul double %indvar.conv, 0x400921FB54442D18
  %div = fdiv double %mul90, 1.800000e+02
  %call91 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.8, i64 0, i64 0), double %indvar.conv, double %div)
  %add93.int = add nuw nsw i32 %X.0180.int, 1
  %exitcond = icmp eq i32 %add93.int, 361
  br i1 %exitcond, label %for.end94, label %for.body88

for.end94:                                        ; preds = %for.body88
  %call95 = call i32 (i8*, ...) bitcast (i32 (...)* @puts to i32 (i8*, ...)*)(i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.9, i64 0, i64 0)) #4
  br label %for.body103

for.body103:                                      ; preds = %for.body103, %for.end94
  %X.1179 = phi double [ 0.000000e+00, %for.end94 ], [ %add113, %for.body103 ]
  %mul104 = fmul double %X.1179, 1.800000e+02
  %div107 = fdiv double %mul104, 0x400921FB54442D18
  %call108 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.10, i64 0, i64 0), double %X.1179, double %div107)
  %add113 = fadd double %X.1179, 0x3F91DF46A2529D39
  %cmp101 = fcmp ugt double %add113, 0x401921FB97600B9B
  br i1 %cmp101, label %for.end114, label %for.body103

for.end114:                                       ; preds = %for.body103
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %1) #4
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %0) #4
  ret i32 0
}
*** IR Dump After Loop Strength Reduction ***
; Preheader:
for.end94:                                        ; preds = %for.body88
  %call95 = call i32 (i8*, ...) bitcast (i32 (...)* @puts to i32 (i8*, ...)*)(i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.9, i64 0, i64 0)) #4
  br label %for.body103

; Loop:
for.body103:                                      ; preds = %for.body103, %for.end94
  %X.1179 = phi double [ 0.000000e+00, %for.end94 ], [ %add113, %for.body103 ]
  %mul104 = fmul double %X.1179, 1.800000e+02
  %div107 = fdiv double %mul104, 0x400921FB54442D18
  %call108 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.10, i64 0, i64 0), double %X.1179, double %div107)
  %add113 = fadd double %X.1179, 0x3F91DF46A2529D39
  %cmp101 = fcmp ugt double %add113, 0x401921FB97600B9B
  br i1 %cmp101, label %for.end114, label %for.body103

; Exit blocks
for.end114:                                       ; preds = %for.body103
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %1) #4
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %0) #4
  ret i32 0
*** IR Dump After Loop Strength Reduction ***
; Preheader:
for.end81:                                        ; preds = %for.body77
  call void @usqrt(i64 1072497001, %struct.int_sqrt* nonnull %q) #4
  %25 = load i32, i32* %sqrt, align 4, !tbaa !9
  %call83 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.6, i64 0, i64 0), i64 1072497001, i32 %25)
  %puts177 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @str.12, i64 0, i64 0)) #4
  br label %for.body88

; Loop:
for.body88:                                       ; preds = %for.body88, %for.end81
  %lsr.iv = phi i32 [ %lsr.iv.next, %for.body88 ], [ 361, %for.end81 ]
  %IV.S. = phi double [ 0.000000e+00, %for.end81 ], [ %IV.S.next., %for.body88 ]
  %mul90 = fmul double %IV.S., 0x400921FB54442D18
  %div = fdiv double %mul90, 1.800000e+02
  %call91 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.8, i64 0, i64 0), double %IV.S., double %div)
  %IV.S.next. = fadd double %IV.S., 1.000000e+00
  %lsr.iv.next = add nsw i32 %lsr.iv, -1
  %exitcond = icmp eq i32 %lsr.iv.next, 0
  br i1 %exitcond, label %for.end94, label %for.body88

; Exit blocks
for.end94:                                        ; preds = %for.body88
  %call95 = call i32 (i8*, ...) bitcast (i32 (...)* @puts to i32 (i8*, ...)*)(i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.9, i64 0, i64 0)) #4
  br label %for.body103
*** IR Dump After Loop Strength Reduction ***
; Preheader:
for.end73:                                        ; preds = %for.inc71
  %puts176 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([40 x i8], [40 x i8]* @str.11, i64 0, i64 0)) #4
  %sqrt = getelementptr inbounds %struct.int_sqrt, %struct.int_sqrt* %q, i64 0, i32 0
  br label %for.body77

; Loop:
for.body77:                                       ; preds = %for.body77, %for.end73
  %indvars.iv = phi i64 [ 0, %for.end73 ], [ %indvars.iv.next, %for.body77 ]
  call void @usqrt(i64 %indvars.iv, %struct.int_sqrt* nonnull %q) #4
  %23 = load i32, i32* %sqrt, align 4, !tbaa !9
  %tmp = trunc i64 %indvars.iv to i32
  %call78 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.5, i64 0, i64 0), i32 %tmp, i32 %23)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond197 = icmp eq i64 %indvars.iv.next, 1001
  br i1 %exitcond197, label %for.end81, label %for.body77, !llvm.loop !7

; Exit blocks
for.end81:                                        ; preds = %for.body77
  call void @usqrt(i64 1072497001, %struct.int_sqrt* nonnull %q) #4
  %24 = load i32, i32* %sqrt, align 4, !tbaa !9
  %call83 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.6, i64 0, i64 0), i64 1072497001, i32 %24)
  %puts177 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @str.12, i64 0, i64 0)) #4
  br label %for.body88
*** IR Dump After Loop Strength Reduction ***
; Preheader:
for.body56.preheader:                             ; preds = %for.body51
  br label %for.body56

; Loop:
for.body56:                                       ; preds = %for.body56, %for.body56.preheader
  %indvars.iv198 = phi i64 [ %indvars.iv.next199, %for.body56 ], [ 0, %for.body56.preheader ]
  %scevgep = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv198
  %20 = load double, double* %scevgep, align 8, !tbaa !5
  %call59 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %20)
  %indvars.iv.next199 = add nuw nsw i64 %indvars.iv198, 1
  %21 = load i32, i32* %solutions, align 4, !tbaa !1
  %22 = sext i32 %21 to i64
  %cmp55 = icmp slt i64 %indvars.iv.next199, %22
  br i1 %cmp55, label %for.body56, label %for.end62.loopexit

; Exit blocks
for.end62.loopexit:                               ; preds = %for.body56
  br label %for.end62
*** IR Dump After Loop Strength Reduction ***
; Preheader:
for.cond49.preheader:                             ; preds = %for.inc66, %for.cond46.preheader
  %c1.0185 = phi double [ 5.000000e+00, %for.cond46.preheader ], [ %add, %for.inc66 ]
  br label %for.body51

; Loop:
for.body51:                                       ; preds = %for.end62, %for.cond49.preheader
  %d1.0184.int = phi i32 [ -1, %for.cond49.preheader ], [ %dec.int, %for.end62 ]
  %indvar.conv201 = sitofp i32 %d1.0184.int to double
  call void @SolveCubic(double %indvar.conv205, double %indvar.conv203, double %c1.0185, double %indvar.conv201, i32* nonnull %solutions, double* %arraydecay) #4
  %call53 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %19 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp55182 = icmp sgt i32 %19, 0
  br i1 %cmp55182, label %for.body56.preheader, label %for.end62

for.body56.preheader:                             ; preds = %for.body51
  br label %for.body56

for.body56:                                       ; preds = %for.body56, %for.body56.preheader
  %indvars.iv198 = phi i64 [ %indvars.iv.next199, %for.body56 ], [ 0, %for.body56.preheader ]
  %scevgep = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv198
  %20 = load double, double* %scevgep, align 8, !tbaa !5
  %call59 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %20)
  %indvars.iv.next199 = add nuw nsw i64 %indvars.iv198, 1
  %21 = load i32, i32* %solutions, align 4, !tbaa !1
  %22 = sext i32 %21 to i64
  %cmp55 = icmp slt i64 %indvars.iv.next199, %22
  br i1 %cmp55, label %for.body56, label %for.end62.loopexit

for.end62.loopexit:                               ; preds = %for.body56
  br label %for.end62

for.end62:                                        ; preds = %for.end62.loopexit, %for.body51
  %putchar178 = call i32 @putchar(i32 10) #4
  %dec.int = add nsw i32 %d1.0184.int, -1
  %cmp50 = icmp sgt i32 %dec.int, -11
  br i1 %cmp50, label %for.body51, label %for.inc66, !llvm.loop !7

; Exit blocks
for.inc66:                                        ; preds = %for.end62
  %add = fadd double %c1.0185, 5.000000e-01
  %cmp47 = fcmp olt double %add, 1.500000e+01
  br i1 %cmp47, label %for.cond49.preheader, label %for.inc68
*** IR Dump After Loop Strength Reduction ***
; Preheader:
for.cond46.preheader:                             ; preds = %for.inc68, %for.cond43.preheader
  %b1.0186.int = phi i32 [ 10, %for.cond43.preheader ], [ %dec69.int, %for.inc68 ]
  %indvar.conv203 = sitofp i32 %b1.0186.int to double
  br label %for.cond49.preheader

; Loop:
for.cond49.preheader:                             ; preds = %for.inc66, %for.cond46.preheader
  %c1.0185 = phi double [ 5.000000e+00, %for.cond46.preheader ], [ %add, %for.inc66 ]
  br label %for.body51

for.body51:                                       ; preds = %for.end62, %for.cond49.preheader
  %d1.0184.int = phi i32 [ -1, %for.cond49.preheader ], [ %dec.int, %for.end62 ]
  %indvar.conv201 = sitofp i32 %d1.0184.int to double
  call void @SolveCubic(double %indvar.conv205, double %indvar.conv203, double %c1.0185, double %indvar.conv201, i32* nonnull %solutions, double* %arraydecay) #4
  %call53 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %19 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp55182 = icmp sgt i32 %19, 0
  br i1 %cmp55182, label %for.body56.preheader, label %for.end62

for.body56.preheader:                             ; preds = %for.body51
  br label %for.body56

for.body56:                                       ; preds = %for.body56, %for.body56.preheader
  %indvars.iv198 = phi i64 [ %indvars.iv.next199, %for.body56 ], [ 0, %for.body56.preheader ]
  %scevgep = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv198
  %20 = load double, double* %scevgep, align 8, !tbaa !5
  %call59 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %20)
  %indvars.iv.next199 = add nuw nsw i64 %indvars.iv198, 1
  %21 = load i32, i32* %solutions, align 4, !tbaa !1
  %22 = sext i32 %21 to i64
  %cmp55 = icmp slt i64 %indvars.iv.next199, %22
  br i1 %cmp55, label %for.body56, label %for.end62.loopexit

for.end62.loopexit:                               ; preds = %for.body56
  br label %for.end62

for.end62:                                        ; preds = %for.end62.loopexit, %for.body51
  %putchar178 = call i32 @putchar(i32 10) #4
  %dec.int = add nsw i32 %d1.0184.int, -1
  %cmp50 = icmp sgt i32 %dec.int, -11
  br i1 %cmp50, label %for.body51, label %for.inc66, !llvm.loop !7

for.inc66:                                        ; preds = %for.end62
  %add = fadd double %c1.0185, 5.000000e-01
  %cmp47 = fcmp olt double %add, 1.500000e+01
  br i1 %cmp47, label %for.cond49.preheader, label %for.inc68

; Exit blocks
for.inc68:                                        ; preds = %for.inc66
  %dec69.int = add nsw i32 %b1.0186.int, -1
  %cmp44 = icmp sgt i32 %b1.0186.int, 1
  br i1 %cmp44, label %for.cond46.preheader, label %for.inc71, !llvm.loop !7
*** IR Dump After Loop Strength Reduction ***
; Preheader:
for.cond43.preheader:                             ; preds = %for.inc71, %for.end38
  %a1.0187.int = phi i32 [ 1, %for.end38 ], [ %inc72.int, %for.inc71 ]
  %indvar.conv205 = sitofp i32 %a1.0187.int to double
  br label %for.cond46.preheader

; Loop:
for.cond46.preheader:                             ; preds = %for.inc68, %for.cond43.preheader
  %b1.0186.int = phi i32 [ 10, %for.cond43.preheader ], [ %dec69.int, %for.inc68 ]
  %indvar.conv203 = sitofp i32 %b1.0186.int to double
  br label %for.cond49.preheader

for.cond49.preheader:                             ; preds = %for.inc66, %for.cond46.preheader
  %c1.0185 = phi double [ 5.000000e+00, %for.cond46.preheader ], [ %add, %for.inc66 ]
  br label %for.body51

for.body51:                                       ; preds = %for.end62, %for.cond49.preheader
  %d1.0184.int = phi i32 [ -1, %for.cond49.preheader ], [ %dec.int, %for.end62 ]
  %indvar.conv201 = sitofp i32 %d1.0184.int to double
  call void @SolveCubic(double %indvar.conv205, double %indvar.conv203, double %c1.0185, double %indvar.conv201, i32* nonnull %solutions, double* %arraydecay) #4
  %call53 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %19 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp55182 = icmp sgt i32 %19, 0
  br i1 %cmp55182, label %for.body56.preheader, label %for.end62

for.body56.preheader:                             ; preds = %for.body51
  br label %for.body56

for.body56:                                       ; preds = %for.body56, %for.body56.preheader
  %indvars.iv198 = phi i64 [ %indvars.iv.next199, %for.body56 ], [ 0, %for.body56.preheader ]
  %scevgep = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv198
  %20 = load double, double* %scevgep, align 8, !tbaa !5
  %call59 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %20)
  %indvars.iv.next199 = add nuw nsw i64 %indvars.iv198, 1
  %21 = load i32, i32* %solutions, align 4, !tbaa !1
  %22 = sext i32 %21 to i64
  %cmp55 = icmp slt i64 %indvars.iv.next199, %22
  br i1 %cmp55, label %for.body56, label %for.end62.loopexit

for.end62.loopexit:                               ; preds = %for.body56
  br label %for.end62

for.end62:                                        ; preds = %for.end62.loopexit, %for.body51
  %putchar178 = call i32 @putchar(i32 10) #4
  %dec.int = add nsw i32 %d1.0184.int, -1
  %cmp50 = icmp sgt i32 %dec.int, -11
  br i1 %cmp50, label %for.body51, label %for.inc66, !llvm.loop !7

for.inc66:                                        ; preds = %for.end62
  %add = fadd double %c1.0185, 5.000000e-01
  %cmp47 = fcmp olt double %add, 1.500000e+01
  br i1 %cmp47, label %for.cond49.preheader, label %for.inc68

for.inc68:                                        ; preds = %for.inc66
  %dec69.int = add nsw i32 %b1.0186.int, -1
  %cmp44 = icmp sgt i32 %b1.0186.int, 1
  br i1 %cmp44, label %for.cond46.preheader, label %for.inc71, !llvm.loop !7

; Exit blocks
for.inc71:                                        ; preds = %for.inc68
  %inc72.int = add nuw nsw i32 %a1.0187.int, 1
  %exitcond206 = icmp eq i32 %inc72.int, 10
  br i1 %exitcond206, label %for.end73, label %for.cond43.preheader, !llvm.loop !7
*** IR Dump After Loop Strength Reduction ***
; Preheader:
for.end38:                                        ; preds = %for.end38.loopexit, %for.end26
  %putchar175 = call i32 @putchar(i32 10) #4
  br label %for.cond43.preheader

; Loop:
for.cond43.preheader:                             ; preds = %for.inc71, %for.end38
  %IV.S.1 = phi double [ 1.000000e+00, %for.end38 ], [ %IV.S.next.2, %for.inc71 ]
  %a1.0187.int = phi i32 [ 1, %for.end38 ], [ %inc72.int, %for.inc71 ]
  br label %for.cond46.preheader

for.cond46.preheader:                             ; preds = %for.inc68, %for.cond43.preheader
  %b1.0186.int = phi i32 [ 10, %for.cond43.preheader ], [ %dec69.int, %for.inc68 ]
  %indvar.conv203 = sitofp i32 %b1.0186.int to double
  br label %for.cond49.preheader

for.cond49.preheader:                             ; preds = %for.inc66, %for.cond46.preheader
  %c1.0185 = phi double [ 5.000000e+00, %for.cond46.preheader ], [ %add, %for.inc66 ]
  br label %for.body51

for.body51:                                       ; preds = %for.end62, %for.cond49.preheader
  %d1.0184.int = phi i32 [ -1, %for.cond49.preheader ], [ %dec.int, %for.end62 ]
  %indvar.conv201 = sitofp i32 %d1.0184.int to double
  call void @SolveCubic(double %IV.S.1, double %indvar.conv203, double %c1.0185, double %indvar.conv201, i32* nonnull %solutions, double* %arraydecay) #4
  %call53 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %19 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp55182 = icmp sgt i32 %19, 0
  br i1 %cmp55182, label %for.body56.preheader, label %for.end62

for.body56.preheader:                             ; preds = %for.body51
  br label %for.body56

for.body56:                                       ; preds = %for.body56, %for.body56.preheader
  %indvars.iv198 = phi i64 [ %indvars.iv.next199, %for.body56 ], [ 0, %for.body56.preheader ]
  %scevgep = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv198
  %20 = load double, double* %scevgep, align 8, !tbaa !5
  %call59 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %20)
  %indvars.iv.next199 = add nuw nsw i64 %indvars.iv198, 1
  %21 = load i32, i32* %solutions, align 4, !tbaa !1
  %22 = sext i32 %21 to i64
  %cmp55 = icmp slt i64 %indvars.iv.next199, %22
  br i1 %cmp55, label %for.body56, label %for.end62.loopexit

for.end62.loopexit:                               ; preds = %for.body56
  br label %for.end62

for.end62:                                        ; preds = %for.end62.loopexit, %for.body51
  %putchar178 = call i32 @putchar(i32 10) #4
  %dec.int = add nsw i32 %d1.0184.int, -1
  %cmp50 = icmp sgt i32 %dec.int, -11
  br i1 %cmp50, label %for.body51, label %for.inc66, !llvm.loop !7

for.inc66:                                        ; preds = %for.end62
  %add = fadd double %c1.0185, 5.000000e-01
  %cmp47 = fcmp olt double %add, 1.500000e+01
  br i1 %cmp47, label %for.cond49.preheader, label %for.inc68

for.inc68:                                        ; preds = %for.inc66
  %dec69.int = add nsw i32 %b1.0186.int, -1
  %cmp44 = icmp sgt i32 %b1.0186.int, 1
  br i1 %cmp44, label %for.cond46.preheader, label %for.inc71, !llvm.loop !7

for.inc71:                                        ; preds = %for.inc68
  %IV.S.next.2 = fadd double %IV.S.1, 1.000000e+00
  %inc72.int = add nuw nsw i32 %a1.0187.int, 1
  %exitcond206 = icmp eq i32 %inc72.int, 10
  br i1 %exitcond206, label %for.end73, label %for.cond43.preheader, !llvm.loop !7

; Exit blocks
for.end73:                                        ; preds = %for.inc71
  %puts176 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([40 x i8], [40 x i8]* @str.11, i64 0, i64 0)) #4
  %sqrt = getelementptr inbounds %struct.int_sqrt, %struct.int_sqrt* %q, i64 0, i32 0
  br label %for.body77
*** IR Dump After Loop Strength Reduction ***
; Preheader:
for.body32.preheader:                             ; preds = %for.end26
  br label %for.body32

; Loop:
for.body32:                                       ; preds = %for.body32, %for.body32.preheader
  %indvars.iv207 = phi i64 [ %indvars.iv.next208, %for.body32 ], [ 0, %for.body32.preheader ]
  %scevgep3 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv207
  %16 = load double, double* %scevgep3, align 8, !tbaa !5
  %call35 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %16)
  %indvars.iv.next208 = add nuw nsw i64 %indvars.iv207, 1
  %17 = load i32, i32* %solutions, align 4, !tbaa !1
  %18 = sext i32 %17 to i64
  %cmp31 = icmp slt i64 %indvars.iv.next208, %18
  br i1 %cmp31, label %for.body32, label %for.end38.loopexit

; Exit blocks
for.end38.loopexit:                               ; preds = %for.body32
  br label %for.end38
*** IR Dump After Loop Strength Reduction ***
; Preheader:
for.body20.preheader:                             ; preds = %for.end14
  br label %for.body20

; Loop:
for.body20:                                       ; preds = %for.body20, %for.body20.preheader
  %indvars.iv209 = phi i64 [ %indvars.iv.next210, %for.body20 ], [ 0, %for.body20.preheader ]
  %scevgep4 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv209
  %12 = load double, double* %scevgep4, align 8, !tbaa !5
  %call23 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %12)
  %indvars.iv.next210 = add nuw nsw i64 %indvars.iv209, 1
  %13 = load i32, i32* %solutions, align 4, !tbaa !1
  %14 = sext i32 %13 to i64
  %cmp19 = icmp slt i64 %indvars.iv.next210, %14
  br i1 %cmp19, label %for.body20, label %for.end26.loopexit

; Exit blocks
for.end26.loopexit:                               ; preds = %for.body20
  br label %for.end26
*** IR Dump After Loop Strength Reduction ***
; Preheader:
for.body8.preheader:                              ; preds = %for.end
  br label %for.body8

; Loop:
for.body8:                                        ; preds = %for.body8, %for.body8.preheader
  %indvars.iv211 = phi i64 [ %indvars.iv.next212, %for.body8 ], [ 0, %for.body8.preheader ]
  %scevgep5 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv211
  %8 = load double, double* %scevgep5, align 8, !tbaa !5
  %call11 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %8)
  %indvars.iv.next212 = add nuw nsw i64 %indvars.iv211, 1
  %9 = load i32, i32* %solutions, align 4, !tbaa !1
  %10 = sext i32 %9 to i64
  %cmp7 = icmp slt i64 %indvars.iv.next212, %10
  br i1 %cmp7, label %for.body8, label %for.end14.loopexit

; Exit blocks
for.end14.loopexit:                               ; preds = %for.body8
  br label %for.end14
*** IR Dump After Loop Strength Reduction ***
; Preheader:
for.body.preheader:                               ; preds = %entry
  br label %for.body

; Loop:
for.body:                                         ; preds = %for.body, %for.body.preheader
  %indvars.iv213 = phi i64 [ %indvars.iv.next214, %for.body ], [ 0, %for.body.preheader ]
  %scevgep6 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv213
  %4 = load double, double* %scevgep6, align 8, !tbaa !5
  %call2 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %4)
  %indvars.iv.next214 = add nuw nsw i64 %indvars.iv213, 1
  %5 = load i32, i32* %solutions, align 4, !tbaa !1
  %6 = sext i32 %5 to i64
  %cmp = icmp slt i64 %indvars.iv.next214, %6
  br i1 %cmp, label %for.body, label %for.end.loopexit

; Exit blocks
for.end.loopexit:                                 ; preds = %for.body
  br label %for.end
*** IR Dump After Merge contiguous icmps into a memcmp ***
; Function Attrs: nounwind uwtable
define i32 @main() #0 {
entry:
  %x = alloca [3 x double], align 16
  %solutions = alloca i32, align 4
  %q = alloca %struct.int_sqrt, align 4
  %0 = bitcast [3 x double]* %x to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %0) #4
  %1 = bitcast i32* %solutions to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #4
  %2 = bitcast %struct.int_sqrt* %q to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #4
  %puts = tail call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* getelementptr inbounds ([38 x i8], [38 x i8]* @str, i64 0, i64 0)) #4
  %arraydecay = getelementptr inbounds [3 x double], [3 x double]* %x, i64 0, i64 0
  call void @SolveCubic(double 1.000000e+00, double -1.050000e+01, double 3.200000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %3 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp194 = icmp sgt i32 %3, 0
  br i1 %cmp194, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body, %for.body.preheader
  %indvars.iv213 = phi i64 [ %indvars.iv.next214, %for.body ], [ 0, %for.body.preheader ]
  %scevgep6 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv213
  %4 = load double, double* %scevgep6, align 8, !tbaa !5
  %call2 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %4)
  %indvars.iv.next214 = add nuw nsw i64 %indvars.iv213, 1
  %5 = load i32, i32* %solutions, align 4, !tbaa !1
  %6 = sext i32 %5 to i64
  %cmp = icmp slt i64 %indvars.iv.next214, %6
  br i1 %cmp, label %for.body, label %for.end.loopexit

for.end.loopexit:                                 ; preds = %for.body
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %entry
  %putchar = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -4.500000e+00, double 1.700000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call5 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %7 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp7192 = icmp sgt i32 %7, 0
  br i1 %cmp7192, label %for.body8.preheader, label %for.end14

for.body8.preheader:                              ; preds = %for.end
  br label %for.body8

for.body8:                                        ; preds = %for.body8, %for.body8.preheader
  %indvars.iv211 = phi i64 [ %indvars.iv.next212, %for.body8 ], [ 0, %for.body8.preheader ]
  %scevgep5 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv211
  %8 = load double, double* %scevgep5, align 8, !tbaa !5
  %call11 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %8)
  %indvars.iv.next212 = add nuw nsw i64 %indvars.iv211, 1
  %9 = load i32, i32* %solutions, align 4, !tbaa !1
  %10 = sext i32 %9 to i64
  %cmp7 = icmp slt i64 %indvars.iv.next212, %10
  br i1 %cmp7, label %for.body8, label %for.end14.loopexit

for.end14.loopexit:                               ; preds = %for.body8
  br label %for.end14

for.end14:                                        ; preds = %for.end14.loopexit, %for.end
  %putchar173 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -3.500000e+00, double 2.200000e+01, double -3.100000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call17 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %11 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp19190 = icmp sgt i32 %11, 0
  br i1 %cmp19190, label %for.body20.preheader, label %for.end26

for.body20.preheader:                             ; preds = %for.end14
  br label %for.body20

for.body20:                                       ; preds = %for.body20, %for.body20.preheader
  %indvars.iv209 = phi i64 [ %indvars.iv.next210, %for.body20 ], [ 0, %for.body20.preheader ]
  %scevgep4 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv209
  %12 = load double, double* %scevgep4, align 8, !tbaa !5
  %call23 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %12)
  %indvars.iv.next210 = add nuw nsw i64 %indvars.iv209, 1
  %13 = load i32, i32* %solutions, align 4, !tbaa !1
  %14 = sext i32 %13 to i64
  %cmp19 = icmp slt i64 %indvars.iv.next210, %14
  br i1 %cmp19, label %for.body20, label %for.end26.loopexit

for.end26.loopexit:                               ; preds = %for.body20
  br label %for.end26

for.end26:                                        ; preds = %for.end26.loopexit, %for.end14
  %putchar174 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -1.370000e+01, double 1.000000e+00, double -3.500000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call29 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %15 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp31188 = icmp sgt i32 %15, 0
  br i1 %cmp31188, label %for.body32.preheader, label %for.end38

for.body32.preheader:                             ; preds = %for.end26
  br label %for.body32

for.body32:                                       ; preds = %for.body32, %for.body32.preheader
  %indvars.iv207 = phi i64 [ %indvars.iv.next208, %for.body32 ], [ 0, %for.body32.preheader ]
  %scevgep3 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv207
  %16 = load double, double* %scevgep3, align 8, !tbaa !5
  %call35 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %16)
  %indvars.iv.next208 = add nuw nsw i64 %indvars.iv207, 1
  %17 = load i32, i32* %solutions, align 4, !tbaa !1
  %18 = sext i32 %17 to i64
  %cmp31 = icmp slt i64 %indvars.iv.next208, %18
  br i1 %cmp31, label %for.body32, label %for.end38.loopexit

for.end38.loopexit:                               ; preds = %for.body32
  br label %for.end38

for.end38:                                        ; preds = %for.end38.loopexit, %for.end26
  %putchar175 = call i32 @putchar(i32 10) #4
  br label %for.cond43.preheader

for.cond43.preheader:                             ; preds = %for.inc71, %for.end38
  %IV.S.1 = phi double [ 1.000000e+00, %for.end38 ], [ %IV.S.next.2, %for.inc71 ]
  %a1.0187.int = phi i32 [ 1, %for.end38 ], [ %inc72.int, %for.inc71 ]
  br label %for.cond46.preheader

for.cond46.preheader:                             ; preds = %for.inc68, %for.cond43.preheader
  %b1.0186.int = phi i32 [ 10, %for.cond43.preheader ], [ %dec69.int, %for.inc68 ]
  %indvar.conv203 = sitofp i32 %b1.0186.int to double
  br label %for.cond49.preheader

for.cond49.preheader:                             ; preds = %for.inc66, %for.cond46.preheader
  %c1.0185 = phi double [ 5.000000e+00, %for.cond46.preheader ], [ %add, %for.inc66 ]
  br label %for.body51

for.body51:                                       ; preds = %for.end62, %for.cond49.preheader
  %d1.0184.int = phi i32 [ -1, %for.cond49.preheader ], [ %dec.int, %for.end62 ]
  %indvar.conv201 = sitofp i32 %d1.0184.int to double
  call void @SolveCubic(double %IV.S.1, double %indvar.conv203, double %c1.0185, double %indvar.conv201, i32* nonnull %solutions, double* %arraydecay) #4
  %call53 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %19 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp55182 = icmp sgt i32 %19, 0
  br i1 %cmp55182, label %for.body56.preheader, label %for.end62

for.body56.preheader:                             ; preds = %for.body51
  br label %for.body56

for.body56:                                       ; preds = %for.body56, %for.body56.preheader
  %indvars.iv198 = phi i64 [ %indvars.iv.next199, %for.body56 ], [ 0, %for.body56.preheader ]
  %scevgep = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv198
  %20 = load double, double* %scevgep, align 8, !tbaa !5
  %call59 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %20)
  %indvars.iv.next199 = add nuw nsw i64 %indvars.iv198, 1
  %21 = load i32, i32* %solutions, align 4, !tbaa !1
  %22 = sext i32 %21 to i64
  %cmp55 = icmp slt i64 %indvars.iv.next199, %22
  br i1 %cmp55, label %for.body56, label %for.end62.loopexit

for.end62.loopexit:                               ; preds = %for.body56
  br label %for.end62

for.end62:                                        ; preds = %for.end62.loopexit, %for.body51
  %putchar178 = call i32 @putchar(i32 10) #4
  %dec.int = add nsw i32 %d1.0184.int, -1
  %cmp50 = icmp sgt i32 %dec.int, -11
  br i1 %cmp50, label %for.body51, label %for.inc66, !llvm.loop !7

for.inc66:                                        ; preds = %for.end62
  %add = fadd double %c1.0185, 5.000000e-01
  %cmp47 = fcmp olt double %add, 1.500000e+01
  br i1 %cmp47, label %for.cond49.preheader, label %for.inc68

for.inc68:                                        ; preds = %for.inc66
  %dec69.int = add nsw i32 %b1.0186.int, -1
  %cmp44 = icmp sgt i32 %b1.0186.int, 1
  br i1 %cmp44, label %for.cond46.preheader, label %for.inc71, !llvm.loop !7

for.inc71:                                        ; preds = %for.inc68
  %IV.S.next.2 = fadd double %IV.S.1, 1.000000e+00
  %inc72.int = add nuw nsw i32 %a1.0187.int, 1
  %exitcond206 = icmp eq i32 %inc72.int, 10
  br i1 %exitcond206, label %for.end73, label %for.cond43.preheader, !llvm.loop !7

for.end73:                                        ; preds = %for.inc71
  %puts176 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([40 x i8], [40 x i8]* @str.11, i64 0, i64 0)) #4
  %sqrt = getelementptr inbounds %struct.int_sqrt, %struct.int_sqrt* %q, i64 0, i32 0
  br label %for.body77

for.body77:                                       ; preds = %for.body77, %for.end73
  %indvars.iv = phi i64 [ 0, %for.end73 ], [ %indvars.iv.next, %for.body77 ]
  call void @usqrt(i64 %indvars.iv, %struct.int_sqrt* nonnull %q) #4
  %23 = load i32, i32* %sqrt, align 4, !tbaa !9
  %tmp = trunc i64 %indvars.iv to i32
  %call78 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.5, i64 0, i64 0), i32 %tmp, i32 %23)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond197 = icmp eq i64 %indvars.iv.next, 1001
  br i1 %exitcond197, label %for.end81, label %for.body77, !llvm.loop !7

for.end81:                                        ; preds = %for.body77
  call void @usqrt(i64 1072497001, %struct.int_sqrt* nonnull %q) #4
  %24 = load i32, i32* %sqrt, align 4, !tbaa !9
  %call83 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.6, i64 0, i64 0), i64 1072497001, i32 %24)
  %puts177 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @str.12, i64 0, i64 0)) #4
  br label %for.body88

for.body88:                                       ; preds = %for.body88, %for.end81
  %lsr.iv = phi i32 [ %lsr.iv.next, %for.body88 ], [ 361, %for.end81 ]
  %IV.S. = phi double [ 0.000000e+00, %for.end81 ], [ %IV.S.next., %for.body88 ]
  %mul90 = fmul double %IV.S., 0x400921FB54442D18
  %div = fdiv double %mul90, 1.800000e+02
  %call91 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.8, i64 0, i64 0), double %IV.S., double %div)
  %IV.S.next. = fadd double %IV.S., 1.000000e+00
  %lsr.iv.next = add nsw i32 %lsr.iv, -1
  %exitcond = icmp eq i32 %lsr.iv.next, 0
  br i1 %exitcond, label %for.end94, label %for.body88

for.end94:                                        ; preds = %for.body88
  %call95 = call i32 (i8*, ...) bitcast (i32 (...)* @puts to i32 (i8*, ...)*)(i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.9, i64 0, i64 0)) #4
  br label %for.body103

for.body103:                                      ; preds = %for.body103, %for.end94
  %X.1179 = phi double [ 0.000000e+00, %for.end94 ], [ %add113, %for.body103 ]
  %mul104 = fmul double %X.1179, 1.800000e+02
  %div107 = fdiv double %mul104, 0x400921FB54442D18
  %call108 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.10, i64 0, i64 0), double %X.1179, double %div107)
  %add113 = fadd double %X.1179, 0x3F91DF46A2529D39
  %cmp101 = fcmp ugt double %add113, 0x401921FB97600B9B
  br i1 %cmp101, label %for.end114, label %for.body103

for.end114:                                       ; preds = %for.body103
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %1) #4
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %0) #4
  ret i32 0
}
*** IR Dump After Expand memcmp() to load/stores ***
; Function Attrs: nounwind uwtable
define i32 @main() #0 {
entry:
  %x = alloca [3 x double], align 16
  %solutions = alloca i32, align 4
  %q = alloca %struct.int_sqrt, align 4
  %0 = bitcast [3 x double]* %x to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %0) #4
  %1 = bitcast i32* %solutions to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #4
  %2 = bitcast %struct.int_sqrt* %q to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #4
  %puts = tail call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* getelementptr inbounds ([38 x i8], [38 x i8]* @str, i64 0, i64 0)) #4
  %arraydecay = getelementptr inbounds [3 x double], [3 x double]* %x, i64 0, i64 0
  call void @SolveCubic(double 1.000000e+00, double -1.050000e+01, double 3.200000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %3 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp194 = icmp sgt i32 %3, 0
  br i1 %cmp194, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body, %for.body.preheader
  %indvars.iv213 = phi i64 [ %indvars.iv.next214, %for.body ], [ 0, %for.body.preheader ]
  %scevgep6 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv213
  %4 = load double, double* %scevgep6, align 8, !tbaa !5
  %call2 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %4)
  %indvars.iv.next214 = add nuw nsw i64 %indvars.iv213, 1
  %5 = load i32, i32* %solutions, align 4, !tbaa !1
  %6 = sext i32 %5 to i64
  %cmp = icmp slt i64 %indvars.iv.next214, %6
  br i1 %cmp, label %for.body, label %for.end.loopexit

for.end.loopexit:                                 ; preds = %for.body
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %entry
  %putchar = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -4.500000e+00, double 1.700000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call5 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %7 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp7192 = icmp sgt i32 %7, 0
  br i1 %cmp7192, label %for.body8.preheader, label %for.end14

for.body8.preheader:                              ; preds = %for.end
  br label %for.body8

for.body8:                                        ; preds = %for.body8, %for.body8.preheader
  %indvars.iv211 = phi i64 [ %indvars.iv.next212, %for.body8 ], [ 0, %for.body8.preheader ]
  %scevgep5 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv211
  %8 = load double, double* %scevgep5, align 8, !tbaa !5
  %call11 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %8)
  %indvars.iv.next212 = add nuw nsw i64 %indvars.iv211, 1
  %9 = load i32, i32* %solutions, align 4, !tbaa !1
  %10 = sext i32 %9 to i64
  %cmp7 = icmp slt i64 %indvars.iv.next212, %10
  br i1 %cmp7, label %for.body8, label %for.end14.loopexit

for.end14.loopexit:                               ; preds = %for.body8
  br label %for.end14

for.end14:                                        ; preds = %for.end14.loopexit, %for.end
  %putchar173 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -3.500000e+00, double 2.200000e+01, double -3.100000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call17 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %11 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp19190 = icmp sgt i32 %11, 0
  br i1 %cmp19190, label %for.body20.preheader, label %for.end26

for.body20.preheader:                             ; preds = %for.end14
  br label %for.body20

for.body20:                                       ; preds = %for.body20, %for.body20.preheader
  %indvars.iv209 = phi i64 [ %indvars.iv.next210, %for.body20 ], [ 0, %for.body20.preheader ]
  %scevgep4 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv209
  %12 = load double, double* %scevgep4, align 8, !tbaa !5
  %call23 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %12)
  %indvars.iv.next210 = add nuw nsw i64 %indvars.iv209, 1
  %13 = load i32, i32* %solutions, align 4, !tbaa !1
  %14 = sext i32 %13 to i64
  %cmp19 = icmp slt i64 %indvars.iv.next210, %14
  br i1 %cmp19, label %for.body20, label %for.end26.loopexit

for.end26.loopexit:                               ; preds = %for.body20
  br label %for.end26

for.end26:                                        ; preds = %for.end26.loopexit, %for.end14
  %putchar174 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -1.370000e+01, double 1.000000e+00, double -3.500000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call29 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %15 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp31188 = icmp sgt i32 %15, 0
  br i1 %cmp31188, label %for.body32.preheader, label %for.end38

for.body32.preheader:                             ; preds = %for.end26
  br label %for.body32

for.body32:                                       ; preds = %for.body32, %for.body32.preheader
  %indvars.iv207 = phi i64 [ %indvars.iv.next208, %for.body32 ], [ 0, %for.body32.preheader ]
  %scevgep3 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv207
  %16 = load double, double* %scevgep3, align 8, !tbaa !5
  %call35 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %16)
  %indvars.iv.next208 = add nuw nsw i64 %indvars.iv207, 1
  %17 = load i32, i32* %solutions, align 4, !tbaa !1
  %18 = sext i32 %17 to i64
  %cmp31 = icmp slt i64 %indvars.iv.next208, %18
  br i1 %cmp31, label %for.body32, label %for.end38.loopexit

for.end38.loopexit:                               ; preds = %for.body32
  br label %for.end38

for.end38:                                        ; preds = %for.end38.loopexit, %for.end26
  %putchar175 = call i32 @putchar(i32 10) #4
  br label %for.cond43.preheader

for.cond43.preheader:                             ; preds = %for.inc71, %for.end38
  %IV.S.1 = phi double [ 1.000000e+00, %for.end38 ], [ %IV.S.next.2, %for.inc71 ]
  %a1.0187.int = phi i32 [ 1, %for.end38 ], [ %inc72.int, %for.inc71 ]
  br label %for.cond46.preheader

for.cond46.preheader:                             ; preds = %for.inc68, %for.cond43.preheader
  %b1.0186.int = phi i32 [ 10, %for.cond43.preheader ], [ %dec69.int, %for.inc68 ]
  %indvar.conv203 = sitofp i32 %b1.0186.int to double
  br label %for.cond49.preheader

for.cond49.preheader:                             ; preds = %for.inc66, %for.cond46.preheader
  %c1.0185 = phi double [ 5.000000e+00, %for.cond46.preheader ], [ %add, %for.inc66 ]
  br label %for.body51

for.body51:                                       ; preds = %for.end62, %for.cond49.preheader
  %d1.0184.int = phi i32 [ -1, %for.cond49.preheader ], [ %dec.int, %for.end62 ]
  %indvar.conv201 = sitofp i32 %d1.0184.int to double
  call void @SolveCubic(double %IV.S.1, double %indvar.conv203, double %c1.0185, double %indvar.conv201, i32* nonnull %solutions, double* %arraydecay) #4
  %call53 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %19 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp55182 = icmp sgt i32 %19, 0
  br i1 %cmp55182, label %for.body56.preheader, label %for.end62

for.body56.preheader:                             ; preds = %for.body51
  br label %for.body56

for.body56:                                       ; preds = %for.body56, %for.body56.preheader
  %indvars.iv198 = phi i64 [ %indvars.iv.next199, %for.body56 ], [ 0, %for.body56.preheader ]
  %scevgep = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv198
  %20 = load double, double* %scevgep, align 8, !tbaa !5
  %call59 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %20)
  %indvars.iv.next199 = add nuw nsw i64 %indvars.iv198, 1
  %21 = load i32, i32* %solutions, align 4, !tbaa !1
  %22 = sext i32 %21 to i64
  %cmp55 = icmp slt i64 %indvars.iv.next199, %22
  br i1 %cmp55, label %for.body56, label %for.end62.loopexit

for.end62.loopexit:                               ; preds = %for.body56
  br label %for.end62

for.end62:                                        ; preds = %for.end62.loopexit, %for.body51
  %putchar178 = call i32 @putchar(i32 10) #4
  %dec.int = add nsw i32 %d1.0184.int, -1
  %cmp50 = icmp sgt i32 %dec.int, -11
  br i1 %cmp50, label %for.body51, label %for.inc66, !llvm.loop !7

for.inc66:                                        ; preds = %for.end62
  %add = fadd double %c1.0185, 5.000000e-01
  %cmp47 = fcmp olt double %add, 1.500000e+01
  br i1 %cmp47, label %for.cond49.preheader, label %for.inc68

for.inc68:                                        ; preds = %for.inc66
  %dec69.int = add nsw i32 %b1.0186.int, -1
  %cmp44 = icmp sgt i32 %b1.0186.int, 1
  br i1 %cmp44, label %for.cond46.preheader, label %for.inc71, !llvm.loop !7

for.inc71:                                        ; preds = %for.inc68
  %IV.S.next.2 = fadd double %IV.S.1, 1.000000e+00
  %inc72.int = add nuw nsw i32 %a1.0187.int, 1
  %exitcond206 = icmp eq i32 %inc72.int, 10
  br i1 %exitcond206, label %for.end73, label %for.cond43.preheader, !llvm.loop !7

for.end73:                                        ; preds = %for.inc71
  %puts176 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([40 x i8], [40 x i8]* @str.11, i64 0, i64 0)) #4
  %sqrt = getelementptr inbounds %struct.int_sqrt, %struct.int_sqrt* %q, i64 0, i32 0
  br label %for.body77

for.body77:                                       ; preds = %for.body77, %for.end73
  %indvars.iv = phi i64 [ 0, %for.end73 ], [ %indvars.iv.next, %for.body77 ]
  call void @usqrt(i64 %indvars.iv, %struct.int_sqrt* nonnull %q) #4
  %23 = load i32, i32* %sqrt, align 4, !tbaa !9
  %tmp = trunc i64 %indvars.iv to i32
  %call78 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.5, i64 0, i64 0), i32 %tmp, i32 %23)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond197 = icmp eq i64 %indvars.iv.next, 1001
  br i1 %exitcond197, label %for.end81, label %for.body77, !llvm.loop !7

for.end81:                                        ; preds = %for.body77
  call void @usqrt(i64 1072497001, %struct.int_sqrt* nonnull %q) #4
  %24 = load i32, i32* %sqrt, align 4, !tbaa !9
  %call83 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.6, i64 0, i64 0), i64 1072497001, i32 %24)
  %puts177 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @str.12, i64 0, i64 0)) #4
  br label %for.body88

for.body88:                                       ; preds = %for.body88, %for.end81
  %lsr.iv = phi i32 [ %lsr.iv.next, %for.body88 ], [ 361, %for.end81 ]
  %IV.S. = phi double [ 0.000000e+00, %for.end81 ], [ %IV.S.next., %for.body88 ]
  %mul90 = fmul double %IV.S., 0x400921FB54442D18
  %div = fdiv double %mul90, 1.800000e+02
  %call91 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.8, i64 0, i64 0), double %IV.S., double %div)
  %IV.S.next. = fadd double %IV.S., 1.000000e+00
  %lsr.iv.next = add nsw i32 %lsr.iv, -1
  %exitcond = icmp eq i32 %lsr.iv.next, 0
  br i1 %exitcond, label %for.end94, label %for.body88

for.end94:                                        ; preds = %for.body88
  %call95 = call i32 (i8*, ...) bitcast (i32 (...)* @puts to i32 (i8*, ...)*)(i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.9, i64 0, i64 0)) #4
  br label %for.body103

for.body103:                                      ; preds = %for.body103, %for.end94
  %X.1179 = phi double [ 0.000000e+00, %for.end94 ], [ %add113, %for.body103 ]
  %mul104 = fmul double %X.1179, 1.800000e+02
  %div107 = fdiv double %mul104, 0x400921FB54442D18
  %call108 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.10, i64 0, i64 0), double %X.1179, double %div107)
  %add113 = fadd double %X.1179, 0x3F91DF46A2529D39
  %cmp101 = fcmp ugt double %add113, 0x401921FB97600B9B
  br i1 %cmp101, label %for.end114, label %for.body103

for.end114:                                       ; preds = %for.body103
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %1) #4
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %0) #4
  ret i32 0
}
*** IR Dump After Lower Garbage Collection Instructions ***
; Function Attrs: nounwind uwtable
define i32 @main() #0 {
entry:
  %x = alloca [3 x double], align 16
  %solutions = alloca i32, align 4
  %q = alloca %struct.int_sqrt, align 4
  %0 = bitcast [3 x double]* %x to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %0) #4
  %1 = bitcast i32* %solutions to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #4
  %2 = bitcast %struct.int_sqrt* %q to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #4
  %puts = tail call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* getelementptr inbounds ([38 x i8], [38 x i8]* @str, i64 0, i64 0)) #4
  %arraydecay = getelementptr inbounds [3 x double], [3 x double]* %x, i64 0, i64 0
  call void @SolveCubic(double 1.000000e+00, double -1.050000e+01, double 3.200000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %3 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp194 = icmp sgt i32 %3, 0
  br i1 %cmp194, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body, %for.body.preheader
  %indvars.iv213 = phi i64 [ %indvars.iv.next214, %for.body ], [ 0, %for.body.preheader ]
  %scevgep6 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv213
  %4 = load double, double* %scevgep6, align 8, !tbaa !5
  %call2 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %4)
  %indvars.iv.next214 = add nuw nsw i64 %indvars.iv213, 1
  %5 = load i32, i32* %solutions, align 4, !tbaa !1
  %6 = sext i32 %5 to i64
  %cmp = icmp slt i64 %indvars.iv.next214, %6
  br i1 %cmp, label %for.body, label %for.end.loopexit

for.end.loopexit:                                 ; preds = %for.body
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %entry
  %putchar = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -4.500000e+00, double 1.700000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call5 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %7 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp7192 = icmp sgt i32 %7, 0
  br i1 %cmp7192, label %for.body8.preheader, label %for.end14

for.body8.preheader:                              ; preds = %for.end
  br label %for.body8

for.body8:                                        ; preds = %for.body8, %for.body8.preheader
  %indvars.iv211 = phi i64 [ %indvars.iv.next212, %for.body8 ], [ 0, %for.body8.preheader ]
  %scevgep5 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv211
  %8 = load double, double* %scevgep5, align 8, !tbaa !5
  %call11 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %8)
  %indvars.iv.next212 = add nuw nsw i64 %indvars.iv211, 1
  %9 = load i32, i32* %solutions, align 4, !tbaa !1
  %10 = sext i32 %9 to i64
  %cmp7 = icmp slt i64 %indvars.iv.next212, %10
  br i1 %cmp7, label %for.body8, label %for.end14.loopexit

for.end14.loopexit:                               ; preds = %for.body8
  br label %for.end14

for.end14:                                        ; preds = %for.end14.loopexit, %for.end
  %putchar173 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -3.500000e+00, double 2.200000e+01, double -3.100000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call17 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %11 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp19190 = icmp sgt i32 %11, 0
  br i1 %cmp19190, label %for.body20.preheader, label %for.end26

for.body20.preheader:                             ; preds = %for.end14
  br label %for.body20

for.body20:                                       ; preds = %for.body20, %for.body20.preheader
  %indvars.iv209 = phi i64 [ %indvars.iv.next210, %for.body20 ], [ 0, %for.body20.preheader ]
  %scevgep4 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv209
  %12 = load double, double* %scevgep4, align 8, !tbaa !5
  %call23 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %12)
  %indvars.iv.next210 = add nuw nsw i64 %indvars.iv209, 1
  %13 = load i32, i32* %solutions, align 4, !tbaa !1
  %14 = sext i32 %13 to i64
  %cmp19 = icmp slt i64 %indvars.iv.next210, %14
  br i1 %cmp19, label %for.body20, label %for.end26.loopexit

for.end26.loopexit:                               ; preds = %for.body20
  br label %for.end26

for.end26:                                        ; preds = %for.end26.loopexit, %for.end14
  %putchar174 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -1.370000e+01, double 1.000000e+00, double -3.500000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call29 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %15 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp31188 = icmp sgt i32 %15, 0
  br i1 %cmp31188, label %for.body32.preheader, label %for.end38

for.body32.preheader:                             ; preds = %for.end26
  br label %for.body32

for.body32:                                       ; preds = %for.body32, %for.body32.preheader
  %indvars.iv207 = phi i64 [ %indvars.iv.next208, %for.body32 ], [ 0, %for.body32.preheader ]
  %scevgep3 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv207
  %16 = load double, double* %scevgep3, align 8, !tbaa !5
  %call35 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %16)
  %indvars.iv.next208 = add nuw nsw i64 %indvars.iv207, 1
  %17 = load i32, i32* %solutions, align 4, !tbaa !1
  %18 = sext i32 %17 to i64
  %cmp31 = icmp slt i64 %indvars.iv.next208, %18
  br i1 %cmp31, label %for.body32, label %for.end38.loopexit

for.end38.loopexit:                               ; preds = %for.body32
  br label %for.end38

for.end38:                                        ; preds = %for.end38.loopexit, %for.end26
  %putchar175 = call i32 @putchar(i32 10) #4
  br label %for.cond43.preheader

for.cond43.preheader:                             ; preds = %for.inc71, %for.end38
  %IV.S.1 = phi double [ 1.000000e+00, %for.end38 ], [ %IV.S.next.2, %for.inc71 ]
  %a1.0187.int = phi i32 [ 1, %for.end38 ], [ %inc72.int, %for.inc71 ]
  br label %for.cond46.preheader

for.cond46.preheader:                             ; preds = %for.inc68, %for.cond43.preheader
  %b1.0186.int = phi i32 [ 10, %for.cond43.preheader ], [ %dec69.int, %for.inc68 ]
  %indvar.conv203 = sitofp i32 %b1.0186.int to double
  br label %for.cond49.preheader

for.cond49.preheader:                             ; preds = %for.inc66, %for.cond46.preheader
  %c1.0185 = phi double [ 5.000000e+00, %for.cond46.preheader ], [ %add, %for.inc66 ]
  br label %for.body51

for.body51:                                       ; preds = %for.end62, %for.cond49.preheader
  %d1.0184.int = phi i32 [ -1, %for.cond49.preheader ], [ %dec.int, %for.end62 ]
  %indvar.conv201 = sitofp i32 %d1.0184.int to double
  call void @SolveCubic(double %IV.S.1, double %indvar.conv203, double %c1.0185, double %indvar.conv201, i32* nonnull %solutions, double* %arraydecay) #4
  %call53 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %19 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp55182 = icmp sgt i32 %19, 0
  br i1 %cmp55182, label %for.body56.preheader, label %for.end62

for.body56.preheader:                             ; preds = %for.body51
  br label %for.body56

for.body56:                                       ; preds = %for.body56, %for.body56.preheader
  %indvars.iv198 = phi i64 [ %indvars.iv.next199, %for.body56 ], [ 0, %for.body56.preheader ]
  %scevgep = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv198
  %20 = load double, double* %scevgep, align 8, !tbaa !5
  %call59 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %20)
  %indvars.iv.next199 = add nuw nsw i64 %indvars.iv198, 1
  %21 = load i32, i32* %solutions, align 4, !tbaa !1
  %22 = sext i32 %21 to i64
  %cmp55 = icmp slt i64 %indvars.iv.next199, %22
  br i1 %cmp55, label %for.body56, label %for.end62.loopexit

for.end62.loopexit:                               ; preds = %for.body56
  br label %for.end62

for.end62:                                        ; preds = %for.end62.loopexit, %for.body51
  %putchar178 = call i32 @putchar(i32 10) #4
  %dec.int = add nsw i32 %d1.0184.int, -1
  %cmp50 = icmp sgt i32 %dec.int, -11
  br i1 %cmp50, label %for.body51, label %for.inc66, !llvm.loop !7

for.inc66:                                        ; preds = %for.end62
  %add = fadd double %c1.0185, 5.000000e-01
  %cmp47 = fcmp olt double %add, 1.500000e+01
  br i1 %cmp47, label %for.cond49.preheader, label %for.inc68

for.inc68:                                        ; preds = %for.inc66
  %dec69.int = add nsw i32 %b1.0186.int, -1
  %cmp44 = icmp sgt i32 %b1.0186.int, 1
  br i1 %cmp44, label %for.cond46.preheader, label %for.inc71, !llvm.loop !7

for.inc71:                                        ; preds = %for.inc68
  %IV.S.next.2 = fadd double %IV.S.1, 1.000000e+00
  %inc72.int = add nuw nsw i32 %a1.0187.int, 1
  %exitcond206 = icmp eq i32 %inc72.int, 10
  br i1 %exitcond206, label %for.end73, label %for.cond43.preheader, !llvm.loop !7

for.end73:                                        ; preds = %for.inc71
  %puts176 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([40 x i8], [40 x i8]* @str.11, i64 0, i64 0)) #4
  %sqrt = getelementptr inbounds %struct.int_sqrt, %struct.int_sqrt* %q, i64 0, i32 0
  br label %for.body77

for.body77:                                       ; preds = %for.body77, %for.end73
  %indvars.iv = phi i64 [ 0, %for.end73 ], [ %indvars.iv.next, %for.body77 ]
  call void @usqrt(i64 %indvars.iv, %struct.int_sqrt* nonnull %q) #4
  %23 = load i32, i32* %sqrt, align 4, !tbaa !9
  %tmp = trunc i64 %indvars.iv to i32
  %call78 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.5, i64 0, i64 0), i32 %tmp, i32 %23)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond197 = icmp eq i64 %indvars.iv.next, 1001
  br i1 %exitcond197, label %for.end81, label %for.body77, !llvm.loop !7

for.end81:                                        ; preds = %for.body77
  call void @usqrt(i64 1072497001, %struct.int_sqrt* nonnull %q) #4
  %24 = load i32, i32* %sqrt, align 4, !tbaa !9
  %call83 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.6, i64 0, i64 0), i64 1072497001, i32 %24)
  %puts177 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @str.12, i64 0, i64 0)) #4
  br label %for.body88

for.body88:                                       ; preds = %for.body88, %for.end81
  %lsr.iv = phi i32 [ %lsr.iv.next, %for.body88 ], [ 361, %for.end81 ]
  %IV.S. = phi double [ 0.000000e+00, %for.end81 ], [ %IV.S.next., %for.body88 ]
  %mul90 = fmul double %IV.S., 0x400921FB54442D18
  %div = fdiv double %mul90, 1.800000e+02
  %call91 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.8, i64 0, i64 0), double %IV.S., double %div)
  %IV.S.next. = fadd double %IV.S., 1.000000e+00
  %lsr.iv.next = add nsw i32 %lsr.iv, -1
  %exitcond = icmp eq i32 %lsr.iv.next, 0
  br i1 %exitcond, label %for.end94, label %for.body88

for.end94:                                        ; preds = %for.body88
  %call95 = call i32 (i8*, ...) bitcast (i32 (...)* @puts to i32 (i8*, ...)*)(i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.9, i64 0, i64 0)) #4
  br label %for.body103

for.body103:                                      ; preds = %for.body103, %for.end94
  %X.1179 = phi double [ 0.000000e+00, %for.end94 ], [ %add113, %for.body103 ]
  %mul104 = fmul double %X.1179, 1.800000e+02
  %div107 = fdiv double %mul104, 0x400921FB54442D18
  %call108 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.10, i64 0, i64 0), double %X.1179, double %div107)
  %add113 = fadd double %X.1179, 0x3F91DF46A2529D39
  %cmp101 = fcmp ugt double %add113, 0x401921FB97600B9B
  br i1 %cmp101, label %for.end114, label %for.body103

for.end114:                                       ; preds = %for.body103
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %1) #4
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %0) #4
  ret i32 0
}
*** IR Dump After Shadow Stack GC Lowering ***
; Function Attrs: nounwind uwtable
define i32 @main() #0 {
entry:
  %x = alloca [3 x double], align 16
  %solutions = alloca i32, align 4
  %q = alloca %struct.int_sqrt, align 4
  %0 = bitcast [3 x double]* %x to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %0) #4
  %1 = bitcast i32* %solutions to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #4
  %2 = bitcast %struct.int_sqrt* %q to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #4
  %puts = tail call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* getelementptr inbounds ([38 x i8], [38 x i8]* @str, i64 0, i64 0)) #4
  %arraydecay = getelementptr inbounds [3 x double], [3 x double]* %x, i64 0, i64 0
  call void @SolveCubic(double 1.000000e+00, double -1.050000e+01, double 3.200000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %3 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp194 = icmp sgt i32 %3, 0
  br i1 %cmp194, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body, %for.body.preheader
  %indvars.iv213 = phi i64 [ %indvars.iv.next214, %for.body ], [ 0, %for.body.preheader ]
  %scevgep6 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv213
  %4 = load double, double* %scevgep6, align 8, !tbaa !5
  %call2 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %4)
  %indvars.iv.next214 = add nuw nsw i64 %indvars.iv213, 1
  %5 = load i32, i32* %solutions, align 4, !tbaa !1
  %6 = sext i32 %5 to i64
  %cmp = icmp slt i64 %indvars.iv.next214, %6
  br i1 %cmp, label %for.body, label %for.end.loopexit

for.end.loopexit:                                 ; preds = %for.body
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %entry
  %putchar = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -4.500000e+00, double 1.700000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call5 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %7 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp7192 = icmp sgt i32 %7, 0
  br i1 %cmp7192, label %for.body8.preheader, label %for.end14

for.body8.preheader:                              ; preds = %for.end
  br label %for.body8

for.body8:                                        ; preds = %for.body8, %for.body8.preheader
  %indvars.iv211 = phi i64 [ %indvars.iv.next212, %for.body8 ], [ 0, %for.body8.preheader ]
  %scevgep5 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv211
  %8 = load double, double* %scevgep5, align 8, !tbaa !5
  %call11 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %8)
  %indvars.iv.next212 = add nuw nsw i64 %indvars.iv211, 1
  %9 = load i32, i32* %solutions, align 4, !tbaa !1
  %10 = sext i32 %9 to i64
  %cmp7 = icmp slt i64 %indvars.iv.next212, %10
  br i1 %cmp7, label %for.body8, label %for.end14.loopexit

for.end14.loopexit:                               ; preds = %for.body8
  br label %for.end14

for.end14:                                        ; preds = %for.end14.loopexit, %for.end
  %putchar173 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -3.500000e+00, double 2.200000e+01, double -3.100000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call17 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %11 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp19190 = icmp sgt i32 %11, 0
  br i1 %cmp19190, label %for.body20.preheader, label %for.end26

for.body20.preheader:                             ; preds = %for.end14
  br label %for.body20

for.body20:                                       ; preds = %for.body20, %for.body20.preheader
  %indvars.iv209 = phi i64 [ %indvars.iv.next210, %for.body20 ], [ 0, %for.body20.preheader ]
  %scevgep4 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv209
  %12 = load double, double* %scevgep4, align 8, !tbaa !5
  %call23 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %12)
  %indvars.iv.next210 = add nuw nsw i64 %indvars.iv209, 1
  %13 = load i32, i32* %solutions, align 4, !tbaa !1
  %14 = sext i32 %13 to i64
  %cmp19 = icmp slt i64 %indvars.iv.next210, %14
  br i1 %cmp19, label %for.body20, label %for.end26.loopexit

for.end26.loopexit:                               ; preds = %for.body20
  br label %for.end26

for.end26:                                        ; preds = %for.end26.loopexit, %for.end14
  %putchar174 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -1.370000e+01, double 1.000000e+00, double -3.500000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call29 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %15 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp31188 = icmp sgt i32 %15, 0
  br i1 %cmp31188, label %for.body32.preheader, label %for.end38

for.body32.preheader:                             ; preds = %for.end26
  br label %for.body32

for.body32:                                       ; preds = %for.body32, %for.body32.preheader
  %indvars.iv207 = phi i64 [ %indvars.iv.next208, %for.body32 ], [ 0, %for.body32.preheader ]
  %scevgep3 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv207
  %16 = load double, double* %scevgep3, align 8, !tbaa !5
  %call35 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %16)
  %indvars.iv.next208 = add nuw nsw i64 %indvars.iv207, 1
  %17 = load i32, i32* %solutions, align 4, !tbaa !1
  %18 = sext i32 %17 to i64
  %cmp31 = icmp slt i64 %indvars.iv.next208, %18
  br i1 %cmp31, label %for.body32, label %for.end38.loopexit

for.end38.loopexit:                               ; preds = %for.body32
  br label %for.end38

for.end38:                                        ; preds = %for.end38.loopexit, %for.end26
  %putchar175 = call i32 @putchar(i32 10) #4
  br label %for.cond43.preheader

for.cond43.preheader:                             ; preds = %for.inc71, %for.end38
  %IV.S.1 = phi double [ 1.000000e+00, %for.end38 ], [ %IV.S.next.2, %for.inc71 ]
  %a1.0187.int = phi i32 [ 1, %for.end38 ], [ %inc72.int, %for.inc71 ]
  br label %for.cond46.preheader

for.cond46.preheader:                             ; preds = %for.inc68, %for.cond43.preheader
  %b1.0186.int = phi i32 [ 10, %for.cond43.preheader ], [ %dec69.int, %for.inc68 ]
  %indvar.conv203 = sitofp i32 %b1.0186.int to double
  br label %for.cond49.preheader

for.cond49.preheader:                             ; preds = %for.inc66, %for.cond46.preheader
  %c1.0185 = phi double [ 5.000000e+00, %for.cond46.preheader ], [ %add, %for.inc66 ]
  br label %for.body51

for.body51:                                       ; preds = %for.end62, %for.cond49.preheader
  %d1.0184.int = phi i32 [ -1, %for.cond49.preheader ], [ %dec.int, %for.end62 ]
  %indvar.conv201 = sitofp i32 %d1.0184.int to double
  call void @SolveCubic(double %IV.S.1, double %indvar.conv203, double %c1.0185, double %indvar.conv201, i32* nonnull %solutions, double* %arraydecay) #4
  %call53 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %19 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp55182 = icmp sgt i32 %19, 0
  br i1 %cmp55182, label %for.body56.preheader, label %for.end62

for.body56.preheader:                             ; preds = %for.body51
  br label %for.body56

for.body56:                                       ; preds = %for.body56, %for.body56.preheader
  %indvars.iv198 = phi i64 [ %indvars.iv.next199, %for.body56 ], [ 0, %for.body56.preheader ]
  %scevgep = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv198
  %20 = load double, double* %scevgep, align 8, !tbaa !5
  %call59 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %20)
  %indvars.iv.next199 = add nuw nsw i64 %indvars.iv198, 1
  %21 = load i32, i32* %solutions, align 4, !tbaa !1
  %22 = sext i32 %21 to i64
  %cmp55 = icmp slt i64 %indvars.iv.next199, %22
  br i1 %cmp55, label %for.body56, label %for.end62.loopexit

for.end62.loopexit:                               ; preds = %for.body56
  br label %for.end62

for.end62:                                        ; preds = %for.end62.loopexit, %for.body51
  %putchar178 = call i32 @putchar(i32 10) #4
  %dec.int = add nsw i32 %d1.0184.int, -1
  %cmp50 = icmp sgt i32 %dec.int, -11
  br i1 %cmp50, label %for.body51, label %for.inc66, !llvm.loop !7

for.inc66:                                        ; preds = %for.end62
  %add = fadd double %c1.0185, 5.000000e-01
  %cmp47 = fcmp olt double %add, 1.500000e+01
  br i1 %cmp47, label %for.cond49.preheader, label %for.inc68

for.inc68:                                        ; preds = %for.inc66
  %dec69.int = add nsw i32 %b1.0186.int, -1
  %cmp44 = icmp sgt i32 %b1.0186.int, 1
  br i1 %cmp44, label %for.cond46.preheader, label %for.inc71, !llvm.loop !7

for.inc71:                                        ; preds = %for.inc68
  %IV.S.next.2 = fadd double %IV.S.1, 1.000000e+00
  %inc72.int = add nuw nsw i32 %a1.0187.int, 1
  %exitcond206 = icmp eq i32 %inc72.int, 10
  br i1 %exitcond206, label %for.end73, label %for.cond43.preheader, !llvm.loop !7

for.end73:                                        ; preds = %for.inc71
  %puts176 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([40 x i8], [40 x i8]* @str.11, i64 0, i64 0)) #4
  %sqrt = getelementptr inbounds %struct.int_sqrt, %struct.int_sqrt* %q, i64 0, i32 0
  br label %for.body77

for.body77:                                       ; preds = %for.body77, %for.end73
  %indvars.iv = phi i64 [ 0, %for.end73 ], [ %indvars.iv.next, %for.body77 ]
  call void @usqrt(i64 %indvars.iv, %struct.int_sqrt* nonnull %q) #4
  %23 = load i32, i32* %sqrt, align 4, !tbaa !9
  %tmp = trunc i64 %indvars.iv to i32
  %call78 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.5, i64 0, i64 0), i32 %tmp, i32 %23)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond197 = icmp eq i64 %indvars.iv.next, 1001
  br i1 %exitcond197, label %for.end81, label %for.body77, !llvm.loop !7

for.end81:                                        ; preds = %for.body77
  call void @usqrt(i64 1072497001, %struct.int_sqrt* nonnull %q) #4
  %24 = load i32, i32* %sqrt, align 4, !tbaa !9
  %call83 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.6, i64 0, i64 0), i64 1072497001, i32 %24)
  %puts177 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @str.12, i64 0, i64 0)) #4
  br label %for.body88

for.body88:                                       ; preds = %for.body88, %for.end81
  %lsr.iv = phi i32 [ %lsr.iv.next, %for.body88 ], [ 361, %for.end81 ]
  %IV.S. = phi double [ 0.000000e+00, %for.end81 ], [ %IV.S.next., %for.body88 ]
  %mul90 = fmul double %IV.S., 0x400921FB54442D18
  %div = fdiv double %mul90, 1.800000e+02
  %call91 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.8, i64 0, i64 0), double %IV.S., double %div)
  %IV.S.next. = fadd double %IV.S., 1.000000e+00
  %lsr.iv.next = add nsw i32 %lsr.iv, -1
  %exitcond = icmp eq i32 %lsr.iv.next, 0
  br i1 %exitcond, label %for.end94, label %for.body88

for.end94:                                        ; preds = %for.body88
  %call95 = call i32 (i8*, ...) bitcast (i32 (...)* @puts to i32 (i8*, ...)*)(i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.9, i64 0, i64 0)) #4
  br label %for.body103

for.body103:                                      ; preds = %for.body103, %for.end94
  %X.1179 = phi double [ 0.000000e+00, %for.end94 ], [ %add113, %for.body103 ]
  %mul104 = fmul double %X.1179, 1.800000e+02
  %div107 = fdiv double %mul104, 0x400921FB54442D18
  %call108 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.10, i64 0, i64 0), double %X.1179, double %div107)
  %add113 = fadd double %X.1179, 0x3F91DF46A2529D39
  %cmp101 = fcmp ugt double %add113, 0x401921FB97600B9B
  br i1 %cmp101, label %for.end114, label %for.body103

for.end114:                                       ; preds = %for.body103
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %1) #4
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %0) #4
  ret i32 0
}
*** IR Dump After Lower constant intrinsics ***
; Function Attrs: nounwind uwtable
define i32 @main() #0 {
entry:
  %x = alloca [3 x double], align 16
  %solutions = alloca i32, align 4
  %q = alloca %struct.int_sqrt, align 4
  %0 = bitcast [3 x double]* %x to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %0) #4
  %1 = bitcast i32* %solutions to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #4
  %2 = bitcast %struct.int_sqrt* %q to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #4
  %puts = tail call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* getelementptr inbounds ([38 x i8], [38 x i8]* @str, i64 0, i64 0)) #4
  %arraydecay = getelementptr inbounds [3 x double], [3 x double]* %x, i64 0, i64 0
  call void @SolveCubic(double 1.000000e+00, double -1.050000e+01, double 3.200000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %3 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp194 = icmp sgt i32 %3, 0
  br i1 %cmp194, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body, %for.body.preheader
  %indvars.iv213 = phi i64 [ %indvars.iv.next214, %for.body ], [ 0, %for.body.preheader ]
  %scevgep6 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv213
  %4 = load double, double* %scevgep6, align 8, !tbaa !5
  %call2 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %4)
  %indvars.iv.next214 = add nuw nsw i64 %indvars.iv213, 1
  %5 = load i32, i32* %solutions, align 4, !tbaa !1
  %6 = sext i32 %5 to i64
  %cmp = icmp slt i64 %indvars.iv.next214, %6
  br i1 %cmp, label %for.body, label %for.end.loopexit

for.end.loopexit:                                 ; preds = %for.body
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %entry
  %putchar = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -4.500000e+00, double 1.700000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call5 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %7 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp7192 = icmp sgt i32 %7, 0
  br i1 %cmp7192, label %for.body8.preheader, label %for.end14

for.body8.preheader:                              ; preds = %for.end
  br label %for.body8

for.body8:                                        ; preds = %for.body8, %for.body8.preheader
  %indvars.iv211 = phi i64 [ %indvars.iv.next212, %for.body8 ], [ 0, %for.body8.preheader ]
  %scevgep5 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv211
  %8 = load double, double* %scevgep5, align 8, !tbaa !5
  %call11 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %8)
  %indvars.iv.next212 = add nuw nsw i64 %indvars.iv211, 1
  %9 = load i32, i32* %solutions, align 4, !tbaa !1
  %10 = sext i32 %9 to i64
  %cmp7 = icmp slt i64 %indvars.iv.next212, %10
  br i1 %cmp7, label %for.body8, label %for.end14.loopexit

for.end14.loopexit:                               ; preds = %for.body8
  br label %for.end14

for.end14:                                        ; preds = %for.end14.loopexit, %for.end
  %putchar173 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -3.500000e+00, double 2.200000e+01, double -3.100000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call17 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %11 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp19190 = icmp sgt i32 %11, 0
  br i1 %cmp19190, label %for.body20.preheader, label %for.end26

for.body20.preheader:                             ; preds = %for.end14
  br label %for.body20

for.body20:                                       ; preds = %for.body20, %for.body20.preheader
  %indvars.iv209 = phi i64 [ %indvars.iv.next210, %for.body20 ], [ 0, %for.body20.preheader ]
  %scevgep4 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv209
  %12 = load double, double* %scevgep4, align 8, !tbaa !5
  %call23 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %12)
  %indvars.iv.next210 = add nuw nsw i64 %indvars.iv209, 1
  %13 = load i32, i32* %solutions, align 4, !tbaa !1
  %14 = sext i32 %13 to i64
  %cmp19 = icmp slt i64 %indvars.iv.next210, %14
  br i1 %cmp19, label %for.body20, label %for.end26.loopexit

for.end26.loopexit:                               ; preds = %for.body20
  br label %for.end26

for.end26:                                        ; preds = %for.end26.loopexit, %for.end14
  %putchar174 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -1.370000e+01, double 1.000000e+00, double -3.500000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call29 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %15 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp31188 = icmp sgt i32 %15, 0
  br i1 %cmp31188, label %for.body32.preheader, label %for.end38

for.body32.preheader:                             ; preds = %for.end26
  br label %for.body32

for.body32:                                       ; preds = %for.body32, %for.body32.preheader
  %indvars.iv207 = phi i64 [ %indvars.iv.next208, %for.body32 ], [ 0, %for.body32.preheader ]
  %scevgep3 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv207
  %16 = load double, double* %scevgep3, align 8, !tbaa !5
  %call35 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %16)
  %indvars.iv.next208 = add nuw nsw i64 %indvars.iv207, 1
  %17 = load i32, i32* %solutions, align 4, !tbaa !1
  %18 = sext i32 %17 to i64
  %cmp31 = icmp slt i64 %indvars.iv.next208, %18
  br i1 %cmp31, label %for.body32, label %for.end38.loopexit

for.end38.loopexit:                               ; preds = %for.body32
  br label %for.end38

for.end38:                                        ; preds = %for.end38.loopexit, %for.end26
  %putchar175 = call i32 @putchar(i32 10) #4
  br label %for.cond43.preheader

for.cond43.preheader:                             ; preds = %for.inc71, %for.end38
  %IV.S.1 = phi double [ 1.000000e+00, %for.end38 ], [ %IV.S.next.2, %for.inc71 ]
  %a1.0187.int = phi i32 [ 1, %for.end38 ], [ %inc72.int, %for.inc71 ]
  br label %for.cond46.preheader

for.cond46.preheader:                             ; preds = %for.inc68, %for.cond43.preheader
  %b1.0186.int = phi i32 [ 10, %for.cond43.preheader ], [ %dec69.int, %for.inc68 ]
  %indvar.conv203 = sitofp i32 %b1.0186.int to double
  br label %for.cond49.preheader

for.cond49.preheader:                             ; preds = %for.inc66, %for.cond46.preheader
  %c1.0185 = phi double [ 5.000000e+00, %for.cond46.preheader ], [ %add, %for.inc66 ]
  br label %for.body51

for.body51:                                       ; preds = %for.end62, %for.cond49.preheader
  %d1.0184.int = phi i32 [ -1, %for.cond49.preheader ], [ %dec.int, %for.end62 ]
  %indvar.conv201 = sitofp i32 %d1.0184.int to double
  call void @SolveCubic(double %IV.S.1, double %indvar.conv203, double %c1.0185, double %indvar.conv201, i32* nonnull %solutions, double* %arraydecay) #4
  %call53 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %19 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp55182 = icmp sgt i32 %19, 0
  br i1 %cmp55182, label %for.body56.preheader, label %for.end62

for.body56.preheader:                             ; preds = %for.body51
  br label %for.body56

for.body56:                                       ; preds = %for.body56, %for.body56.preheader
  %indvars.iv198 = phi i64 [ %indvars.iv.next199, %for.body56 ], [ 0, %for.body56.preheader ]
  %scevgep = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv198
  %20 = load double, double* %scevgep, align 8, !tbaa !5
  %call59 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %20)
  %indvars.iv.next199 = add nuw nsw i64 %indvars.iv198, 1
  %21 = load i32, i32* %solutions, align 4, !tbaa !1
  %22 = sext i32 %21 to i64
  %cmp55 = icmp slt i64 %indvars.iv.next199, %22
  br i1 %cmp55, label %for.body56, label %for.end62.loopexit

for.end62.loopexit:                               ; preds = %for.body56
  br label %for.end62

for.end62:                                        ; preds = %for.end62.loopexit, %for.body51
  %putchar178 = call i32 @putchar(i32 10) #4
  %dec.int = add nsw i32 %d1.0184.int, -1
  %cmp50 = icmp sgt i32 %dec.int, -11
  br i1 %cmp50, label %for.body51, label %for.inc66, !llvm.loop !7

for.inc66:                                        ; preds = %for.end62
  %add = fadd double %c1.0185, 5.000000e-01
  %cmp47 = fcmp olt double %add, 1.500000e+01
  br i1 %cmp47, label %for.cond49.preheader, label %for.inc68

for.inc68:                                        ; preds = %for.inc66
  %dec69.int = add nsw i32 %b1.0186.int, -1
  %cmp44 = icmp sgt i32 %b1.0186.int, 1
  br i1 %cmp44, label %for.cond46.preheader, label %for.inc71, !llvm.loop !7

for.inc71:                                        ; preds = %for.inc68
  %IV.S.next.2 = fadd double %IV.S.1, 1.000000e+00
  %inc72.int = add nuw nsw i32 %a1.0187.int, 1
  %exitcond206 = icmp eq i32 %inc72.int, 10
  br i1 %exitcond206, label %for.end73, label %for.cond43.preheader, !llvm.loop !7

for.end73:                                        ; preds = %for.inc71
  %puts176 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([40 x i8], [40 x i8]* @str.11, i64 0, i64 0)) #4
  %sqrt = getelementptr inbounds %struct.int_sqrt, %struct.int_sqrt* %q, i64 0, i32 0
  br label %for.body77

for.body77:                                       ; preds = %for.body77, %for.end73
  %indvars.iv = phi i64 [ 0, %for.end73 ], [ %indvars.iv.next, %for.body77 ]
  call void @usqrt(i64 %indvars.iv, %struct.int_sqrt* nonnull %q) #4
  %23 = load i32, i32* %sqrt, align 4, !tbaa !9
  %tmp = trunc i64 %indvars.iv to i32
  %call78 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.5, i64 0, i64 0), i32 %tmp, i32 %23)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond197 = icmp eq i64 %indvars.iv.next, 1001
  br i1 %exitcond197, label %for.end81, label %for.body77, !llvm.loop !7

for.end81:                                        ; preds = %for.body77
  call void @usqrt(i64 1072497001, %struct.int_sqrt* nonnull %q) #4
  %24 = load i32, i32* %sqrt, align 4, !tbaa !9
  %call83 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.6, i64 0, i64 0), i64 1072497001, i32 %24)
  %puts177 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @str.12, i64 0, i64 0)) #4
  br label %for.body88

for.body88:                                       ; preds = %for.body88, %for.end81
  %lsr.iv = phi i32 [ %lsr.iv.next, %for.body88 ], [ 361, %for.end81 ]
  %IV.S. = phi double [ 0.000000e+00, %for.end81 ], [ %IV.S.next., %for.body88 ]
  %mul90 = fmul double %IV.S., 0x400921FB54442D18
  %div = fdiv double %mul90, 1.800000e+02
  %call91 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.8, i64 0, i64 0), double %IV.S., double %div)
  %IV.S.next. = fadd double %IV.S., 1.000000e+00
  %lsr.iv.next = add nsw i32 %lsr.iv, -1
  %exitcond = icmp eq i32 %lsr.iv.next, 0
  br i1 %exitcond, label %for.end94, label %for.body88

for.end94:                                        ; preds = %for.body88
  %call95 = call i32 (i8*, ...) bitcast (i32 (...)* @puts to i32 (i8*, ...)*)(i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.9, i64 0, i64 0)) #4
  br label %for.body103

for.body103:                                      ; preds = %for.body103, %for.end94
  %X.1179 = phi double [ 0.000000e+00, %for.end94 ], [ %add113, %for.body103 ]
  %mul104 = fmul double %X.1179, 1.800000e+02
  %div107 = fdiv double %mul104, 0x400921FB54442D18
  %call108 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.10, i64 0, i64 0), double %X.1179, double %div107)
  %add113 = fadd double %X.1179, 0x3F91DF46A2529D39
  %cmp101 = fcmp ugt double %add113, 0x401921FB97600B9B
  br i1 %cmp101, label %for.end114, label %for.body103

for.end114:                                       ; preds = %for.body103
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %1) #4
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %0) #4
  ret i32 0
}
*** IR Dump After Remove unreachable blocks from the CFG ***
; Function Attrs: nounwind uwtable
define i32 @main() #0 {
entry:
  %x = alloca [3 x double], align 16
  %solutions = alloca i32, align 4
  %q = alloca %struct.int_sqrt, align 4
  %0 = bitcast [3 x double]* %x to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %0) #4
  %1 = bitcast i32* %solutions to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #4
  %2 = bitcast %struct.int_sqrt* %q to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #4
  %puts = tail call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* getelementptr inbounds ([38 x i8], [38 x i8]* @str, i64 0, i64 0)) #4
  %arraydecay = getelementptr inbounds [3 x double], [3 x double]* %x, i64 0, i64 0
  call void @SolveCubic(double 1.000000e+00, double -1.050000e+01, double 3.200000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %3 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp194 = icmp sgt i32 %3, 0
  br i1 %cmp194, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body, %for.body.preheader
  %indvars.iv213 = phi i64 [ %indvars.iv.next214, %for.body ], [ 0, %for.body.preheader ]
  %scevgep6 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv213
  %4 = load double, double* %scevgep6, align 8, !tbaa !5
  %call2 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %4)
  %indvars.iv.next214 = add nuw nsw i64 %indvars.iv213, 1
  %5 = load i32, i32* %solutions, align 4, !tbaa !1
  %6 = sext i32 %5 to i64
  %cmp = icmp slt i64 %indvars.iv.next214, %6
  br i1 %cmp, label %for.body, label %for.end.loopexit

for.end.loopexit:                                 ; preds = %for.body
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %entry
  %putchar = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -4.500000e+00, double 1.700000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call5 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %7 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp7192 = icmp sgt i32 %7, 0
  br i1 %cmp7192, label %for.body8.preheader, label %for.end14

for.body8.preheader:                              ; preds = %for.end
  br label %for.body8

for.body8:                                        ; preds = %for.body8, %for.body8.preheader
  %indvars.iv211 = phi i64 [ %indvars.iv.next212, %for.body8 ], [ 0, %for.body8.preheader ]
  %scevgep5 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv211
  %8 = load double, double* %scevgep5, align 8, !tbaa !5
  %call11 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %8)
  %indvars.iv.next212 = add nuw nsw i64 %indvars.iv211, 1
  %9 = load i32, i32* %solutions, align 4, !tbaa !1
  %10 = sext i32 %9 to i64
  %cmp7 = icmp slt i64 %indvars.iv.next212, %10
  br i1 %cmp7, label %for.body8, label %for.end14.loopexit

for.end14.loopexit:                               ; preds = %for.body8
  br label %for.end14

for.end14:                                        ; preds = %for.end14.loopexit, %for.end
  %putchar173 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -3.500000e+00, double 2.200000e+01, double -3.100000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call17 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %11 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp19190 = icmp sgt i32 %11, 0
  br i1 %cmp19190, label %for.body20.preheader, label %for.end26

for.body20.preheader:                             ; preds = %for.end14
  br label %for.body20

for.body20:                                       ; preds = %for.body20, %for.body20.preheader
  %indvars.iv209 = phi i64 [ %indvars.iv.next210, %for.body20 ], [ 0, %for.body20.preheader ]
  %scevgep4 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv209
  %12 = load double, double* %scevgep4, align 8, !tbaa !5
  %call23 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %12)
  %indvars.iv.next210 = add nuw nsw i64 %indvars.iv209, 1
  %13 = load i32, i32* %solutions, align 4, !tbaa !1
  %14 = sext i32 %13 to i64
  %cmp19 = icmp slt i64 %indvars.iv.next210, %14
  br i1 %cmp19, label %for.body20, label %for.end26.loopexit

for.end26.loopexit:                               ; preds = %for.body20
  br label %for.end26

for.end26:                                        ; preds = %for.end26.loopexit, %for.end14
  %putchar174 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -1.370000e+01, double 1.000000e+00, double -3.500000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call29 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %15 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp31188 = icmp sgt i32 %15, 0
  br i1 %cmp31188, label %for.body32.preheader, label %for.end38

for.body32.preheader:                             ; preds = %for.end26
  br label %for.body32

for.body32:                                       ; preds = %for.body32, %for.body32.preheader
  %indvars.iv207 = phi i64 [ %indvars.iv.next208, %for.body32 ], [ 0, %for.body32.preheader ]
  %scevgep3 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv207
  %16 = load double, double* %scevgep3, align 8, !tbaa !5
  %call35 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %16)
  %indvars.iv.next208 = add nuw nsw i64 %indvars.iv207, 1
  %17 = load i32, i32* %solutions, align 4, !tbaa !1
  %18 = sext i32 %17 to i64
  %cmp31 = icmp slt i64 %indvars.iv.next208, %18
  br i1 %cmp31, label %for.body32, label %for.end38.loopexit

for.end38.loopexit:                               ; preds = %for.body32
  br label %for.end38

for.end38:                                        ; preds = %for.end38.loopexit, %for.end26
  %putchar175 = call i32 @putchar(i32 10) #4
  br label %for.cond43.preheader

for.cond43.preheader:                             ; preds = %for.inc71, %for.end38
  %IV.S.1 = phi double [ 1.000000e+00, %for.end38 ], [ %IV.S.next.2, %for.inc71 ]
  %a1.0187.int = phi i32 [ 1, %for.end38 ], [ %inc72.int, %for.inc71 ]
  br label %for.cond46.preheader

for.cond46.preheader:                             ; preds = %for.inc68, %for.cond43.preheader
  %b1.0186.int = phi i32 [ 10, %for.cond43.preheader ], [ %dec69.int, %for.inc68 ]
  %indvar.conv203 = sitofp i32 %b1.0186.int to double
  br label %for.cond49.preheader

for.cond49.preheader:                             ; preds = %for.inc66, %for.cond46.preheader
  %c1.0185 = phi double [ 5.000000e+00, %for.cond46.preheader ], [ %add, %for.inc66 ]
  br label %for.body51

for.body51:                                       ; preds = %for.end62, %for.cond49.preheader
  %d1.0184.int = phi i32 [ -1, %for.cond49.preheader ], [ %dec.int, %for.end62 ]
  %indvar.conv201 = sitofp i32 %d1.0184.int to double
  call void @SolveCubic(double %IV.S.1, double %indvar.conv203, double %c1.0185, double %indvar.conv201, i32* nonnull %solutions, double* %arraydecay) #4
  %call53 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %19 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp55182 = icmp sgt i32 %19, 0
  br i1 %cmp55182, label %for.body56.preheader, label %for.end62

for.body56.preheader:                             ; preds = %for.body51
  br label %for.body56

for.body56:                                       ; preds = %for.body56, %for.body56.preheader
  %indvars.iv198 = phi i64 [ %indvars.iv.next199, %for.body56 ], [ 0, %for.body56.preheader ]
  %scevgep = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv198
  %20 = load double, double* %scevgep, align 8, !tbaa !5
  %call59 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %20)
  %indvars.iv.next199 = add nuw nsw i64 %indvars.iv198, 1
  %21 = load i32, i32* %solutions, align 4, !tbaa !1
  %22 = sext i32 %21 to i64
  %cmp55 = icmp slt i64 %indvars.iv.next199, %22
  br i1 %cmp55, label %for.body56, label %for.end62.loopexit

for.end62.loopexit:                               ; preds = %for.body56
  br label %for.end62

for.end62:                                        ; preds = %for.end62.loopexit, %for.body51
  %putchar178 = call i32 @putchar(i32 10) #4
  %dec.int = add nsw i32 %d1.0184.int, -1
  %cmp50 = icmp sgt i32 %dec.int, -11
  br i1 %cmp50, label %for.body51, label %for.inc66, !llvm.loop !7

for.inc66:                                        ; preds = %for.end62
  %add = fadd double %c1.0185, 5.000000e-01
  %cmp47 = fcmp olt double %add, 1.500000e+01
  br i1 %cmp47, label %for.cond49.preheader, label %for.inc68

for.inc68:                                        ; preds = %for.inc66
  %dec69.int = add nsw i32 %b1.0186.int, -1
  %cmp44 = icmp sgt i32 %b1.0186.int, 1
  br i1 %cmp44, label %for.cond46.preheader, label %for.inc71, !llvm.loop !7

for.inc71:                                        ; preds = %for.inc68
  %IV.S.next.2 = fadd double %IV.S.1, 1.000000e+00
  %inc72.int = add nuw nsw i32 %a1.0187.int, 1
  %exitcond206 = icmp eq i32 %inc72.int, 10
  br i1 %exitcond206, label %for.end73, label %for.cond43.preheader, !llvm.loop !7

for.end73:                                        ; preds = %for.inc71
  %puts176 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([40 x i8], [40 x i8]* @str.11, i64 0, i64 0)) #4
  %sqrt = getelementptr inbounds %struct.int_sqrt, %struct.int_sqrt* %q, i64 0, i32 0
  br label %for.body77

for.body77:                                       ; preds = %for.body77, %for.end73
  %indvars.iv = phi i64 [ 0, %for.end73 ], [ %indvars.iv.next, %for.body77 ]
  call void @usqrt(i64 %indvars.iv, %struct.int_sqrt* nonnull %q) #4
  %23 = load i32, i32* %sqrt, align 4, !tbaa !9
  %tmp = trunc i64 %indvars.iv to i32
  %call78 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.5, i64 0, i64 0), i32 %tmp, i32 %23)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond197 = icmp eq i64 %indvars.iv.next, 1001
  br i1 %exitcond197, label %for.end81, label %for.body77, !llvm.loop !7

for.end81:                                        ; preds = %for.body77
  call void @usqrt(i64 1072497001, %struct.int_sqrt* nonnull %q) #4
  %24 = load i32, i32* %sqrt, align 4, !tbaa !9
  %call83 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.6, i64 0, i64 0), i64 1072497001, i32 %24)
  %puts177 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @str.12, i64 0, i64 0)) #4
  br label %for.body88

for.body88:                                       ; preds = %for.body88, %for.end81
  %lsr.iv = phi i32 [ %lsr.iv.next, %for.body88 ], [ 361, %for.end81 ]
  %IV.S. = phi double [ 0.000000e+00, %for.end81 ], [ %IV.S.next., %for.body88 ]
  %mul90 = fmul double %IV.S., 0x400921FB54442D18
  %div = fdiv double %mul90, 1.800000e+02
  %call91 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.8, i64 0, i64 0), double %IV.S., double %div)
  %IV.S.next. = fadd double %IV.S., 1.000000e+00
  %lsr.iv.next = add nsw i32 %lsr.iv, -1
  %exitcond = icmp eq i32 %lsr.iv.next, 0
  br i1 %exitcond, label %for.end94, label %for.body88

for.end94:                                        ; preds = %for.body88
  %call95 = call i32 (i8*, ...) bitcast (i32 (...)* @puts to i32 (i8*, ...)*)(i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.9, i64 0, i64 0)) #4
  br label %for.body103

for.body103:                                      ; preds = %for.body103, %for.end94
  %X.1179 = phi double [ 0.000000e+00, %for.end94 ], [ %add113, %for.body103 ]
  %mul104 = fmul double %X.1179, 1.800000e+02
  %div107 = fdiv double %mul104, 0x400921FB54442D18
  %call108 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.10, i64 0, i64 0), double %X.1179, double %div107)
  %add113 = fadd double %X.1179, 0x3F91DF46A2529D39
  %cmp101 = fcmp ugt double %add113, 0x401921FB97600B9B
  br i1 %cmp101, label %for.end114, label %for.body103

for.end114:                                       ; preds = %for.body103
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %1) #4
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %0) #4
  ret i32 0
}
*** IR Dump After Constant Hoisting ***
; Function Attrs: nounwind uwtable
define i32 @main() #0 {
entry:
  %x = alloca [3 x double], align 16
  %solutions = alloca i32, align 4
  %q = alloca %struct.int_sqrt, align 4
  %0 = bitcast [3 x double]* %x to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %0) #4
  %1 = bitcast i32* %solutions to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #4
  %2 = bitcast %struct.int_sqrt* %q to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #4
  %puts = tail call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* getelementptr inbounds ([38 x i8], [38 x i8]* @str, i64 0, i64 0)) #4
  %arraydecay = getelementptr inbounds [3 x double], [3 x double]* %x, i64 0, i64 0
  call void @SolveCubic(double 1.000000e+00, double -1.050000e+01, double 3.200000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %3 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp194 = icmp sgt i32 %3, 0
  br i1 %cmp194, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body, %for.body.preheader
  %indvars.iv213 = phi i64 [ %indvars.iv.next214, %for.body ], [ 0, %for.body.preheader ]
  %scevgep6 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv213
  %4 = load double, double* %scevgep6, align 8, !tbaa !5
  %call2 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %4)
  %indvars.iv.next214 = add nuw nsw i64 %indvars.iv213, 1
  %5 = load i32, i32* %solutions, align 4, !tbaa !1
  %6 = sext i32 %5 to i64
  %cmp = icmp slt i64 %indvars.iv.next214, %6
  br i1 %cmp, label %for.body, label %for.end.loopexit

for.end.loopexit:                                 ; preds = %for.body
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %entry
  %putchar = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -4.500000e+00, double 1.700000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call5 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %7 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp7192 = icmp sgt i32 %7, 0
  br i1 %cmp7192, label %for.body8.preheader, label %for.end14

for.body8.preheader:                              ; preds = %for.end
  br label %for.body8

for.body8:                                        ; preds = %for.body8, %for.body8.preheader
  %indvars.iv211 = phi i64 [ %indvars.iv.next212, %for.body8 ], [ 0, %for.body8.preheader ]
  %scevgep5 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv211
  %8 = load double, double* %scevgep5, align 8, !tbaa !5
  %call11 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %8)
  %indvars.iv.next212 = add nuw nsw i64 %indvars.iv211, 1
  %9 = load i32, i32* %solutions, align 4, !tbaa !1
  %10 = sext i32 %9 to i64
  %cmp7 = icmp slt i64 %indvars.iv.next212, %10
  br i1 %cmp7, label %for.body8, label %for.end14.loopexit

for.end14.loopexit:                               ; preds = %for.body8
  br label %for.end14

for.end14:                                        ; preds = %for.end14.loopexit, %for.end
  %putchar173 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -3.500000e+00, double 2.200000e+01, double -3.100000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call17 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %11 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp19190 = icmp sgt i32 %11, 0
  br i1 %cmp19190, label %for.body20.preheader, label %for.end26

for.body20.preheader:                             ; preds = %for.end14
  br label %for.body20

for.body20:                                       ; preds = %for.body20, %for.body20.preheader
  %indvars.iv209 = phi i64 [ %indvars.iv.next210, %for.body20 ], [ 0, %for.body20.preheader ]
  %scevgep4 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv209
  %12 = load double, double* %scevgep4, align 8, !tbaa !5
  %call23 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %12)
  %indvars.iv.next210 = add nuw nsw i64 %indvars.iv209, 1
  %13 = load i32, i32* %solutions, align 4, !tbaa !1
  %14 = sext i32 %13 to i64
  %cmp19 = icmp slt i64 %indvars.iv.next210, %14
  br i1 %cmp19, label %for.body20, label %for.end26.loopexit

for.end26.loopexit:                               ; preds = %for.body20
  br label %for.end26

for.end26:                                        ; preds = %for.end26.loopexit, %for.end14
  %putchar174 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -1.370000e+01, double 1.000000e+00, double -3.500000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call29 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %15 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp31188 = icmp sgt i32 %15, 0
  br i1 %cmp31188, label %for.body32.preheader, label %for.end38

for.body32.preheader:                             ; preds = %for.end26
  br label %for.body32

for.body32:                                       ; preds = %for.body32, %for.body32.preheader
  %indvars.iv207 = phi i64 [ %indvars.iv.next208, %for.body32 ], [ 0, %for.body32.preheader ]
  %scevgep3 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv207
  %16 = load double, double* %scevgep3, align 8, !tbaa !5
  %call35 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %16)
  %indvars.iv.next208 = add nuw nsw i64 %indvars.iv207, 1
  %17 = load i32, i32* %solutions, align 4, !tbaa !1
  %18 = sext i32 %17 to i64
  %cmp31 = icmp slt i64 %indvars.iv.next208, %18
  br i1 %cmp31, label %for.body32, label %for.end38.loopexit

for.end38.loopexit:                               ; preds = %for.body32
  br label %for.end38

for.end38:                                        ; preds = %for.end38.loopexit, %for.end26
  %putchar175 = call i32 @putchar(i32 10) #4
  br label %for.cond43.preheader

for.cond43.preheader:                             ; preds = %for.inc71, %for.end38
  %IV.S.1 = phi double [ 1.000000e+00, %for.end38 ], [ %IV.S.next.2, %for.inc71 ]
  %a1.0187.int = phi i32 [ 1, %for.end38 ], [ %inc72.int, %for.inc71 ]
  br label %for.cond46.preheader

for.cond46.preheader:                             ; preds = %for.inc68, %for.cond43.preheader
  %b1.0186.int = phi i32 [ 10, %for.cond43.preheader ], [ %dec69.int, %for.inc68 ]
  %indvar.conv203 = sitofp i32 %b1.0186.int to double
  br label %for.cond49.preheader

for.cond49.preheader:                             ; preds = %for.inc66, %for.cond46.preheader
  %c1.0185 = phi double [ 5.000000e+00, %for.cond46.preheader ], [ %add, %for.inc66 ]
  br label %for.body51

for.body51:                                       ; preds = %for.end62, %for.cond49.preheader
  %d1.0184.int = phi i32 [ -1, %for.cond49.preheader ], [ %dec.int, %for.end62 ]
  %indvar.conv201 = sitofp i32 %d1.0184.int to double
  call void @SolveCubic(double %IV.S.1, double %indvar.conv203, double %c1.0185, double %indvar.conv201, i32* nonnull %solutions, double* %arraydecay) #4
  %call53 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %19 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp55182 = icmp sgt i32 %19, 0
  br i1 %cmp55182, label %for.body56.preheader, label %for.end62

for.body56.preheader:                             ; preds = %for.body51
  br label %for.body56

for.body56:                                       ; preds = %for.body56, %for.body56.preheader
  %indvars.iv198 = phi i64 [ %indvars.iv.next199, %for.body56 ], [ 0, %for.body56.preheader ]
  %scevgep = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv198
  %20 = load double, double* %scevgep, align 8, !tbaa !5
  %call59 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %20)
  %indvars.iv.next199 = add nuw nsw i64 %indvars.iv198, 1
  %21 = load i32, i32* %solutions, align 4, !tbaa !1
  %22 = sext i32 %21 to i64
  %cmp55 = icmp slt i64 %indvars.iv.next199, %22
  br i1 %cmp55, label %for.body56, label %for.end62.loopexit

for.end62.loopexit:                               ; preds = %for.body56
  br label %for.end62

for.end62:                                        ; preds = %for.end62.loopexit, %for.body51
  %putchar178 = call i32 @putchar(i32 10) #4
  %dec.int = add nsw i32 %d1.0184.int, -1
  %cmp50 = icmp sgt i32 %dec.int, -11
  br i1 %cmp50, label %for.body51, label %for.inc66, !llvm.loop !7

for.inc66:                                        ; preds = %for.end62
  %add = fadd double %c1.0185, 5.000000e-01
  %cmp47 = fcmp olt double %add, 1.500000e+01
  br i1 %cmp47, label %for.cond49.preheader, label %for.inc68

for.inc68:                                        ; preds = %for.inc66
  %dec69.int = add nsw i32 %b1.0186.int, -1
  %cmp44 = icmp sgt i32 %b1.0186.int, 1
  br i1 %cmp44, label %for.cond46.preheader, label %for.inc71, !llvm.loop !7

for.inc71:                                        ; preds = %for.inc68
  %IV.S.next.2 = fadd double %IV.S.1, 1.000000e+00
  %inc72.int = add nuw nsw i32 %a1.0187.int, 1
  %exitcond206 = icmp eq i32 %inc72.int, 10
  br i1 %exitcond206, label %for.end73, label %for.cond43.preheader, !llvm.loop !7

for.end73:                                        ; preds = %for.inc71
  %puts176 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([40 x i8], [40 x i8]* @str.11, i64 0, i64 0)) #4
  %sqrt = getelementptr inbounds %struct.int_sqrt, %struct.int_sqrt* %q, i64 0, i32 0
  br label %for.body77

for.body77:                                       ; preds = %for.body77, %for.end73
  %indvars.iv = phi i64 [ 0, %for.end73 ], [ %indvars.iv.next, %for.body77 ]
  call void @usqrt(i64 %indvars.iv, %struct.int_sqrt* nonnull %q) #4
  %23 = load i32, i32* %sqrt, align 4, !tbaa !9
  %tmp = trunc i64 %indvars.iv to i32
  %call78 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.5, i64 0, i64 0), i32 %tmp, i32 %23)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond197 = icmp eq i64 %indvars.iv.next, 1001
  br i1 %exitcond197, label %for.end81, label %for.body77, !llvm.loop !7

for.end81:                                        ; preds = %for.body77
  call void @usqrt(i64 1072497001, %struct.int_sqrt* nonnull %q) #4
  %24 = load i32, i32* %sqrt, align 4, !tbaa !9
  %call83 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.6, i64 0, i64 0), i64 1072497001, i32 %24)
  %puts177 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @str.12, i64 0, i64 0)) #4
  br label %for.body88

for.body88:                                       ; preds = %for.body88, %for.end81
  %lsr.iv = phi i32 [ %lsr.iv.next, %for.body88 ], [ 361, %for.end81 ]
  %IV.S. = phi double [ 0.000000e+00, %for.end81 ], [ %IV.S.next., %for.body88 ]
  %mul90 = fmul double %IV.S., 0x400921FB54442D18
  %div = fdiv double %mul90, 1.800000e+02
  %call91 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.8, i64 0, i64 0), double %IV.S., double %div)
  %IV.S.next. = fadd double %IV.S., 1.000000e+00
  %lsr.iv.next = add nsw i32 %lsr.iv, -1
  %exitcond = icmp eq i32 %lsr.iv.next, 0
  br i1 %exitcond, label %for.end94, label %for.body88

for.end94:                                        ; preds = %for.body88
  %call95 = call i32 (i8*, ...) bitcast (i32 (...)* @puts to i32 (i8*, ...)*)(i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.9, i64 0, i64 0)) #4
  br label %for.body103

for.body103:                                      ; preds = %for.body103, %for.end94
  %X.1179 = phi double [ 0.000000e+00, %for.end94 ], [ %add113, %for.body103 ]
  %mul104 = fmul double %X.1179, 1.800000e+02
  %div107 = fdiv double %mul104, 0x400921FB54442D18
  %call108 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.10, i64 0, i64 0), double %X.1179, double %div107)
  %add113 = fadd double %X.1179, 0x3F91DF46A2529D39
  %cmp101 = fcmp ugt double %add113, 0x401921FB97600B9B
  br i1 %cmp101, label %for.end114, label %for.body103

for.end114:                                       ; preds = %for.body103
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %1) #4
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %0) #4
  ret i32 0
}
*** IR Dump After Partially inline calls to library functions ***
; Function Attrs: nounwind uwtable
define i32 @main() #0 {
entry:
  %x = alloca [3 x double], align 16
  %solutions = alloca i32, align 4
  %q = alloca %struct.int_sqrt, align 4
  %0 = bitcast [3 x double]* %x to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %0) #4
  %1 = bitcast i32* %solutions to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #4
  %2 = bitcast %struct.int_sqrt* %q to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #4
  %puts = tail call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* getelementptr inbounds ([38 x i8], [38 x i8]* @str, i64 0, i64 0)) #4
  %arraydecay = getelementptr inbounds [3 x double], [3 x double]* %x, i64 0, i64 0
  call void @SolveCubic(double 1.000000e+00, double -1.050000e+01, double 3.200000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %3 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp194 = icmp sgt i32 %3, 0
  br i1 %cmp194, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body, %for.body.preheader
  %indvars.iv213 = phi i64 [ %indvars.iv.next214, %for.body ], [ 0, %for.body.preheader ]
  %scevgep6 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv213
  %4 = load double, double* %scevgep6, align 8, !tbaa !5
  %call2 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %4)
  %indvars.iv.next214 = add nuw nsw i64 %indvars.iv213, 1
  %5 = load i32, i32* %solutions, align 4, !tbaa !1
  %6 = sext i32 %5 to i64
  %cmp = icmp slt i64 %indvars.iv.next214, %6
  br i1 %cmp, label %for.body, label %for.end.loopexit

for.end.loopexit:                                 ; preds = %for.body
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %entry
  %putchar = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -4.500000e+00, double 1.700000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call5 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %7 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp7192 = icmp sgt i32 %7, 0
  br i1 %cmp7192, label %for.body8.preheader, label %for.end14

for.body8.preheader:                              ; preds = %for.end
  br label %for.body8

for.body8:                                        ; preds = %for.body8, %for.body8.preheader
  %indvars.iv211 = phi i64 [ %indvars.iv.next212, %for.body8 ], [ 0, %for.body8.preheader ]
  %scevgep5 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv211
  %8 = load double, double* %scevgep5, align 8, !tbaa !5
  %call11 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %8)
  %indvars.iv.next212 = add nuw nsw i64 %indvars.iv211, 1
  %9 = load i32, i32* %solutions, align 4, !tbaa !1
  %10 = sext i32 %9 to i64
  %cmp7 = icmp slt i64 %indvars.iv.next212, %10
  br i1 %cmp7, label %for.body8, label %for.end14.loopexit

for.end14.loopexit:                               ; preds = %for.body8
  br label %for.end14

for.end14:                                        ; preds = %for.end14.loopexit, %for.end
  %putchar173 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -3.500000e+00, double 2.200000e+01, double -3.100000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call17 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %11 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp19190 = icmp sgt i32 %11, 0
  br i1 %cmp19190, label %for.body20.preheader, label %for.end26

for.body20.preheader:                             ; preds = %for.end14
  br label %for.body20

for.body20:                                       ; preds = %for.body20, %for.body20.preheader
  %indvars.iv209 = phi i64 [ %indvars.iv.next210, %for.body20 ], [ 0, %for.body20.preheader ]
  %scevgep4 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv209
  %12 = load double, double* %scevgep4, align 8, !tbaa !5
  %call23 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %12)
  %indvars.iv.next210 = add nuw nsw i64 %indvars.iv209, 1
  %13 = load i32, i32* %solutions, align 4, !tbaa !1
  %14 = sext i32 %13 to i64
  %cmp19 = icmp slt i64 %indvars.iv.next210, %14
  br i1 %cmp19, label %for.body20, label %for.end26.loopexit

for.end26.loopexit:                               ; preds = %for.body20
  br label %for.end26

for.end26:                                        ; preds = %for.end26.loopexit, %for.end14
  %putchar174 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -1.370000e+01, double 1.000000e+00, double -3.500000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call29 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %15 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp31188 = icmp sgt i32 %15, 0
  br i1 %cmp31188, label %for.body32.preheader, label %for.end38

for.body32.preheader:                             ; preds = %for.end26
  br label %for.body32

for.body32:                                       ; preds = %for.body32, %for.body32.preheader
  %indvars.iv207 = phi i64 [ %indvars.iv.next208, %for.body32 ], [ 0, %for.body32.preheader ]
  %scevgep3 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv207
  %16 = load double, double* %scevgep3, align 8, !tbaa !5
  %call35 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %16)
  %indvars.iv.next208 = add nuw nsw i64 %indvars.iv207, 1
  %17 = load i32, i32* %solutions, align 4, !tbaa !1
  %18 = sext i32 %17 to i64
  %cmp31 = icmp slt i64 %indvars.iv.next208, %18
  br i1 %cmp31, label %for.body32, label %for.end38.loopexit

for.end38.loopexit:                               ; preds = %for.body32
  br label %for.end38

for.end38:                                        ; preds = %for.end38.loopexit, %for.end26
  %putchar175 = call i32 @putchar(i32 10) #4
  br label %for.cond43.preheader

for.cond43.preheader:                             ; preds = %for.inc71, %for.end38
  %IV.S.1 = phi double [ 1.000000e+00, %for.end38 ], [ %IV.S.next.2, %for.inc71 ]
  %a1.0187.int = phi i32 [ 1, %for.end38 ], [ %inc72.int, %for.inc71 ]
  br label %for.cond46.preheader

for.cond46.preheader:                             ; preds = %for.inc68, %for.cond43.preheader
  %b1.0186.int = phi i32 [ 10, %for.cond43.preheader ], [ %dec69.int, %for.inc68 ]
  %indvar.conv203 = sitofp i32 %b1.0186.int to double
  br label %for.cond49.preheader

for.cond49.preheader:                             ; preds = %for.inc66, %for.cond46.preheader
  %c1.0185 = phi double [ 5.000000e+00, %for.cond46.preheader ], [ %add, %for.inc66 ]
  br label %for.body51

for.body51:                                       ; preds = %for.end62, %for.cond49.preheader
  %d1.0184.int = phi i32 [ -1, %for.cond49.preheader ], [ %dec.int, %for.end62 ]
  %indvar.conv201 = sitofp i32 %d1.0184.int to double
  call void @SolveCubic(double %IV.S.1, double %indvar.conv203, double %c1.0185, double %indvar.conv201, i32* nonnull %solutions, double* %arraydecay) #4
  %call53 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %19 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp55182 = icmp sgt i32 %19, 0
  br i1 %cmp55182, label %for.body56.preheader, label %for.end62

for.body56.preheader:                             ; preds = %for.body51
  br label %for.body56

for.body56:                                       ; preds = %for.body56, %for.body56.preheader
  %indvars.iv198 = phi i64 [ %indvars.iv.next199, %for.body56 ], [ 0, %for.body56.preheader ]
  %scevgep = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv198
  %20 = load double, double* %scevgep, align 8, !tbaa !5
  %call59 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %20)
  %indvars.iv.next199 = add nuw nsw i64 %indvars.iv198, 1
  %21 = load i32, i32* %solutions, align 4, !tbaa !1
  %22 = sext i32 %21 to i64
  %cmp55 = icmp slt i64 %indvars.iv.next199, %22
  br i1 %cmp55, label %for.body56, label %for.end62.loopexit

for.end62.loopexit:                               ; preds = %for.body56
  br label %for.end62

for.end62:                                        ; preds = %for.end62.loopexit, %for.body51
  %putchar178 = call i32 @putchar(i32 10) #4
  %dec.int = add nsw i32 %d1.0184.int, -1
  %cmp50 = icmp sgt i32 %dec.int, -11
  br i1 %cmp50, label %for.body51, label %for.inc66, !llvm.loop !7

for.inc66:                                        ; preds = %for.end62
  %add = fadd double %c1.0185, 5.000000e-01
  %cmp47 = fcmp olt double %add, 1.500000e+01
  br i1 %cmp47, label %for.cond49.preheader, label %for.inc68

for.inc68:                                        ; preds = %for.inc66
  %dec69.int = add nsw i32 %b1.0186.int, -1
  %cmp44 = icmp sgt i32 %b1.0186.int, 1
  br i1 %cmp44, label %for.cond46.preheader, label %for.inc71, !llvm.loop !7

for.inc71:                                        ; preds = %for.inc68
  %IV.S.next.2 = fadd double %IV.S.1, 1.000000e+00
  %inc72.int = add nuw nsw i32 %a1.0187.int, 1
  %exitcond206 = icmp eq i32 %inc72.int, 10
  br i1 %exitcond206, label %for.end73, label %for.cond43.preheader, !llvm.loop !7

for.end73:                                        ; preds = %for.inc71
  %puts176 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([40 x i8], [40 x i8]* @str.11, i64 0, i64 0)) #4
  %sqrt = getelementptr inbounds %struct.int_sqrt, %struct.int_sqrt* %q, i64 0, i32 0
  br label %for.body77

for.body77:                                       ; preds = %for.body77, %for.end73
  %indvars.iv = phi i64 [ 0, %for.end73 ], [ %indvars.iv.next, %for.body77 ]
  call void @usqrt(i64 %indvars.iv, %struct.int_sqrt* nonnull %q) #4
  %23 = load i32, i32* %sqrt, align 4, !tbaa !9
  %tmp = trunc i64 %indvars.iv to i32
  %call78 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.5, i64 0, i64 0), i32 %tmp, i32 %23)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond197 = icmp eq i64 %indvars.iv.next, 1001
  br i1 %exitcond197, label %for.end81, label %for.body77, !llvm.loop !7

for.end81:                                        ; preds = %for.body77
  call void @usqrt(i64 1072497001, %struct.int_sqrt* nonnull %q) #4
  %24 = load i32, i32* %sqrt, align 4, !tbaa !9
  %call83 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.6, i64 0, i64 0), i64 1072497001, i32 %24)
  %puts177 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @str.12, i64 0, i64 0)) #4
  br label %for.body88

for.body88:                                       ; preds = %for.body88, %for.end81
  %lsr.iv = phi i32 [ %lsr.iv.next, %for.body88 ], [ 361, %for.end81 ]
  %IV.S. = phi double [ 0.000000e+00, %for.end81 ], [ %IV.S.next., %for.body88 ]
  %mul90 = fmul double %IV.S., 0x400921FB54442D18
  %div = fdiv double %mul90, 1.800000e+02
  %call91 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.8, i64 0, i64 0), double %IV.S., double %div)
  %IV.S.next. = fadd double %IV.S., 1.000000e+00
  %lsr.iv.next = add nsw i32 %lsr.iv, -1
  %exitcond = icmp eq i32 %lsr.iv.next, 0
  br i1 %exitcond, label %for.end94, label %for.body88

for.end94:                                        ; preds = %for.body88
  %call95 = call i32 (i8*, ...) bitcast (i32 (...)* @puts to i32 (i8*, ...)*)(i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.9, i64 0, i64 0)) #4
  br label %for.body103

for.body103:                                      ; preds = %for.body103, %for.end94
  %X.1179 = phi double [ 0.000000e+00, %for.end94 ], [ %add113, %for.body103 ]
  %mul104 = fmul double %X.1179, 1.800000e+02
  %div107 = fdiv double %mul104, 0x400921FB54442D18
  %call108 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.10, i64 0, i64 0), double %X.1179, double %div107)
  %add113 = fadd double %X.1179, 0x3F91DF46A2529D39
  %cmp101 = fcmp ugt double %add113, 0x401921FB97600B9B
  br i1 %cmp101, label %for.end114, label %for.body103

for.end114:                                       ; preds = %for.body103
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %1) #4
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %0) #4
  ret i32 0
}
*** IR Dump After Instrument function entry/exit with calls to e.g. mcount() (post inlining) ***
; Function Attrs: nounwind uwtable
define i32 @main() #0 {
entry:
  %x = alloca [3 x double], align 16
  %solutions = alloca i32, align 4
  %q = alloca %struct.int_sqrt, align 4
  %0 = bitcast [3 x double]* %x to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %0) #4
  %1 = bitcast i32* %solutions to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #4
  %2 = bitcast %struct.int_sqrt* %q to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #4
  %puts = tail call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* getelementptr inbounds ([38 x i8], [38 x i8]* @str, i64 0, i64 0)) #4
  %arraydecay = getelementptr inbounds [3 x double], [3 x double]* %x, i64 0, i64 0
  call void @SolveCubic(double 1.000000e+00, double -1.050000e+01, double 3.200000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %3 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp194 = icmp sgt i32 %3, 0
  br i1 %cmp194, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body, %for.body.preheader
  %indvars.iv213 = phi i64 [ %indvars.iv.next214, %for.body ], [ 0, %for.body.preheader ]
  %scevgep6 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv213
  %4 = load double, double* %scevgep6, align 8, !tbaa !5
  %call2 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %4)
  %indvars.iv.next214 = add nuw nsw i64 %indvars.iv213, 1
  %5 = load i32, i32* %solutions, align 4, !tbaa !1
  %6 = sext i32 %5 to i64
  %cmp = icmp slt i64 %indvars.iv.next214, %6
  br i1 %cmp, label %for.body, label %for.end.loopexit

for.end.loopexit:                                 ; preds = %for.body
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %entry
  %putchar = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -4.500000e+00, double 1.700000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call5 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %7 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp7192 = icmp sgt i32 %7, 0
  br i1 %cmp7192, label %for.body8.preheader, label %for.end14

for.body8.preheader:                              ; preds = %for.end
  br label %for.body8

for.body8:                                        ; preds = %for.body8, %for.body8.preheader
  %indvars.iv211 = phi i64 [ %indvars.iv.next212, %for.body8 ], [ 0, %for.body8.preheader ]
  %scevgep5 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv211
  %8 = load double, double* %scevgep5, align 8, !tbaa !5
  %call11 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %8)
  %indvars.iv.next212 = add nuw nsw i64 %indvars.iv211, 1
  %9 = load i32, i32* %solutions, align 4, !tbaa !1
  %10 = sext i32 %9 to i64
  %cmp7 = icmp slt i64 %indvars.iv.next212, %10
  br i1 %cmp7, label %for.body8, label %for.end14.loopexit

for.end14.loopexit:                               ; preds = %for.body8
  br label %for.end14

for.end14:                                        ; preds = %for.end14.loopexit, %for.end
  %putchar173 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -3.500000e+00, double 2.200000e+01, double -3.100000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call17 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %11 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp19190 = icmp sgt i32 %11, 0
  br i1 %cmp19190, label %for.body20.preheader, label %for.end26

for.body20.preheader:                             ; preds = %for.end14
  br label %for.body20

for.body20:                                       ; preds = %for.body20, %for.body20.preheader
  %indvars.iv209 = phi i64 [ %indvars.iv.next210, %for.body20 ], [ 0, %for.body20.preheader ]
  %scevgep4 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv209
  %12 = load double, double* %scevgep4, align 8, !tbaa !5
  %call23 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %12)
  %indvars.iv.next210 = add nuw nsw i64 %indvars.iv209, 1
  %13 = load i32, i32* %solutions, align 4, !tbaa !1
  %14 = sext i32 %13 to i64
  %cmp19 = icmp slt i64 %indvars.iv.next210, %14
  br i1 %cmp19, label %for.body20, label %for.end26.loopexit

for.end26.loopexit:                               ; preds = %for.body20
  br label %for.end26

for.end26:                                        ; preds = %for.end26.loopexit, %for.end14
  %putchar174 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -1.370000e+01, double 1.000000e+00, double -3.500000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call29 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %15 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp31188 = icmp sgt i32 %15, 0
  br i1 %cmp31188, label %for.body32.preheader, label %for.end38

for.body32.preheader:                             ; preds = %for.end26
  br label %for.body32

for.body32:                                       ; preds = %for.body32, %for.body32.preheader
  %indvars.iv207 = phi i64 [ %indvars.iv.next208, %for.body32 ], [ 0, %for.body32.preheader ]
  %scevgep3 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv207
  %16 = load double, double* %scevgep3, align 8, !tbaa !5
  %call35 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %16)
  %indvars.iv.next208 = add nuw nsw i64 %indvars.iv207, 1
  %17 = load i32, i32* %solutions, align 4, !tbaa !1
  %18 = sext i32 %17 to i64
  %cmp31 = icmp slt i64 %indvars.iv.next208, %18
  br i1 %cmp31, label %for.body32, label %for.end38.loopexit

for.end38.loopexit:                               ; preds = %for.body32
  br label %for.end38

for.end38:                                        ; preds = %for.end38.loopexit, %for.end26
  %putchar175 = call i32 @putchar(i32 10) #4
  br label %for.cond43.preheader

for.cond43.preheader:                             ; preds = %for.inc71, %for.end38
  %IV.S.1 = phi double [ 1.000000e+00, %for.end38 ], [ %IV.S.next.2, %for.inc71 ]
  %a1.0187.int = phi i32 [ 1, %for.end38 ], [ %inc72.int, %for.inc71 ]
  br label %for.cond46.preheader

for.cond46.preheader:                             ; preds = %for.inc68, %for.cond43.preheader
  %b1.0186.int = phi i32 [ 10, %for.cond43.preheader ], [ %dec69.int, %for.inc68 ]
  %indvar.conv203 = sitofp i32 %b1.0186.int to double
  br label %for.cond49.preheader

for.cond49.preheader:                             ; preds = %for.inc66, %for.cond46.preheader
  %c1.0185 = phi double [ 5.000000e+00, %for.cond46.preheader ], [ %add, %for.inc66 ]
  br label %for.body51

for.body51:                                       ; preds = %for.end62, %for.cond49.preheader
  %d1.0184.int = phi i32 [ -1, %for.cond49.preheader ], [ %dec.int, %for.end62 ]
  %indvar.conv201 = sitofp i32 %d1.0184.int to double
  call void @SolveCubic(double %IV.S.1, double %indvar.conv203, double %c1.0185, double %indvar.conv201, i32* nonnull %solutions, double* %arraydecay) #4
  %call53 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %19 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp55182 = icmp sgt i32 %19, 0
  br i1 %cmp55182, label %for.body56.preheader, label %for.end62

for.body56.preheader:                             ; preds = %for.body51
  br label %for.body56

for.body56:                                       ; preds = %for.body56, %for.body56.preheader
  %indvars.iv198 = phi i64 [ %indvars.iv.next199, %for.body56 ], [ 0, %for.body56.preheader ]
  %scevgep = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv198
  %20 = load double, double* %scevgep, align 8, !tbaa !5
  %call59 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %20)
  %indvars.iv.next199 = add nuw nsw i64 %indvars.iv198, 1
  %21 = load i32, i32* %solutions, align 4, !tbaa !1
  %22 = sext i32 %21 to i64
  %cmp55 = icmp slt i64 %indvars.iv.next199, %22
  br i1 %cmp55, label %for.body56, label %for.end62.loopexit

for.end62.loopexit:                               ; preds = %for.body56
  br label %for.end62

for.end62:                                        ; preds = %for.end62.loopexit, %for.body51
  %putchar178 = call i32 @putchar(i32 10) #4
  %dec.int = add nsw i32 %d1.0184.int, -1
  %cmp50 = icmp sgt i32 %dec.int, -11
  br i1 %cmp50, label %for.body51, label %for.inc66, !llvm.loop !7

for.inc66:                                        ; preds = %for.end62
  %add = fadd double %c1.0185, 5.000000e-01
  %cmp47 = fcmp olt double %add, 1.500000e+01
  br i1 %cmp47, label %for.cond49.preheader, label %for.inc68

for.inc68:                                        ; preds = %for.inc66
  %dec69.int = add nsw i32 %b1.0186.int, -1
  %cmp44 = icmp sgt i32 %b1.0186.int, 1
  br i1 %cmp44, label %for.cond46.preheader, label %for.inc71, !llvm.loop !7

for.inc71:                                        ; preds = %for.inc68
  %IV.S.next.2 = fadd double %IV.S.1, 1.000000e+00
  %inc72.int = add nuw nsw i32 %a1.0187.int, 1
  %exitcond206 = icmp eq i32 %inc72.int, 10
  br i1 %exitcond206, label %for.end73, label %for.cond43.preheader, !llvm.loop !7

for.end73:                                        ; preds = %for.inc71
  %puts176 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([40 x i8], [40 x i8]* @str.11, i64 0, i64 0)) #4
  %sqrt = getelementptr inbounds %struct.int_sqrt, %struct.int_sqrt* %q, i64 0, i32 0
  br label %for.body77

for.body77:                                       ; preds = %for.body77, %for.end73
  %indvars.iv = phi i64 [ 0, %for.end73 ], [ %indvars.iv.next, %for.body77 ]
  call void @usqrt(i64 %indvars.iv, %struct.int_sqrt* nonnull %q) #4
  %23 = load i32, i32* %sqrt, align 4, !tbaa !9
  %tmp = trunc i64 %indvars.iv to i32
  %call78 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.5, i64 0, i64 0), i32 %tmp, i32 %23)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond197 = icmp eq i64 %indvars.iv.next, 1001
  br i1 %exitcond197, label %for.end81, label %for.body77, !llvm.loop !7

for.end81:                                        ; preds = %for.body77
  call void @usqrt(i64 1072497001, %struct.int_sqrt* nonnull %q) #4
  %24 = load i32, i32* %sqrt, align 4, !tbaa !9
  %call83 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.6, i64 0, i64 0), i64 1072497001, i32 %24)
  %puts177 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @str.12, i64 0, i64 0)) #4
  br label %for.body88

for.body88:                                       ; preds = %for.body88, %for.end81
  %lsr.iv = phi i32 [ %lsr.iv.next, %for.body88 ], [ 361, %for.end81 ]
  %IV.S. = phi double [ 0.000000e+00, %for.end81 ], [ %IV.S.next., %for.body88 ]
  %mul90 = fmul double %IV.S., 0x400921FB54442D18
  %div = fdiv double %mul90, 1.800000e+02
  %call91 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.8, i64 0, i64 0), double %IV.S., double %div)
  %IV.S.next. = fadd double %IV.S., 1.000000e+00
  %lsr.iv.next = add nsw i32 %lsr.iv, -1
  %exitcond = icmp eq i32 %lsr.iv.next, 0
  br i1 %exitcond, label %for.end94, label %for.body88

for.end94:                                        ; preds = %for.body88
  %call95 = call i32 (i8*, ...) bitcast (i32 (...)* @puts to i32 (i8*, ...)*)(i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.9, i64 0, i64 0)) #4
  br label %for.body103

for.body103:                                      ; preds = %for.body103, %for.end94
  %X.1179 = phi double [ 0.000000e+00, %for.end94 ], [ %add113, %for.body103 ]
  %mul104 = fmul double %X.1179, 1.800000e+02
  %div107 = fdiv double %mul104, 0x400921FB54442D18
  %call108 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.10, i64 0, i64 0), double %X.1179, double %div107)
  %add113 = fadd double %X.1179, 0x3F91DF46A2529D39
  %cmp101 = fcmp ugt double %add113, 0x401921FB97600B9B
  br i1 %cmp101, label %for.end114, label %for.body103

for.end114:                                       ; preds = %for.body103
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %1) #4
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %0) #4
  ret i32 0
}
*** IR Dump After Scalarize Masked Memory Intrinsics ***
; Function Attrs: nounwind uwtable
define i32 @main() #0 {
entry:
  %x = alloca [3 x double], align 16
  %solutions = alloca i32, align 4
  %q = alloca %struct.int_sqrt, align 4
  %0 = bitcast [3 x double]* %x to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %0) #4
  %1 = bitcast i32* %solutions to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #4
  %2 = bitcast %struct.int_sqrt* %q to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #4
  %puts = tail call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* getelementptr inbounds ([38 x i8], [38 x i8]* @str, i64 0, i64 0)) #4
  %arraydecay = getelementptr inbounds [3 x double], [3 x double]* %x, i64 0, i64 0
  call void @SolveCubic(double 1.000000e+00, double -1.050000e+01, double 3.200000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %3 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp194 = icmp sgt i32 %3, 0
  br i1 %cmp194, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body, %for.body.preheader
  %indvars.iv213 = phi i64 [ %indvars.iv.next214, %for.body ], [ 0, %for.body.preheader ]
  %scevgep6 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv213
  %4 = load double, double* %scevgep6, align 8, !tbaa !5
  %call2 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %4)
  %indvars.iv.next214 = add nuw nsw i64 %indvars.iv213, 1
  %5 = load i32, i32* %solutions, align 4, !tbaa !1
  %6 = sext i32 %5 to i64
  %cmp = icmp slt i64 %indvars.iv.next214, %6
  br i1 %cmp, label %for.body, label %for.end.loopexit

for.end.loopexit:                                 ; preds = %for.body
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %entry
  %putchar = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -4.500000e+00, double 1.700000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call5 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %7 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp7192 = icmp sgt i32 %7, 0
  br i1 %cmp7192, label %for.body8.preheader, label %for.end14

for.body8.preheader:                              ; preds = %for.end
  br label %for.body8

for.body8:                                        ; preds = %for.body8, %for.body8.preheader
  %indvars.iv211 = phi i64 [ %indvars.iv.next212, %for.body8 ], [ 0, %for.body8.preheader ]
  %scevgep5 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv211
  %8 = load double, double* %scevgep5, align 8, !tbaa !5
  %call11 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %8)
  %indvars.iv.next212 = add nuw nsw i64 %indvars.iv211, 1
  %9 = load i32, i32* %solutions, align 4, !tbaa !1
  %10 = sext i32 %9 to i64
  %cmp7 = icmp slt i64 %indvars.iv.next212, %10
  br i1 %cmp7, label %for.body8, label %for.end14.loopexit

for.end14.loopexit:                               ; preds = %for.body8
  br label %for.end14

for.end14:                                        ; preds = %for.end14.loopexit, %for.end
  %putchar173 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -3.500000e+00, double 2.200000e+01, double -3.100000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call17 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %11 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp19190 = icmp sgt i32 %11, 0
  br i1 %cmp19190, label %for.body20.preheader, label %for.end26

for.body20.preheader:                             ; preds = %for.end14
  br label %for.body20

for.body20:                                       ; preds = %for.body20, %for.body20.preheader
  %indvars.iv209 = phi i64 [ %indvars.iv.next210, %for.body20 ], [ 0, %for.body20.preheader ]
  %scevgep4 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv209
  %12 = load double, double* %scevgep4, align 8, !tbaa !5
  %call23 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %12)
  %indvars.iv.next210 = add nuw nsw i64 %indvars.iv209, 1
  %13 = load i32, i32* %solutions, align 4, !tbaa !1
  %14 = sext i32 %13 to i64
  %cmp19 = icmp slt i64 %indvars.iv.next210, %14
  br i1 %cmp19, label %for.body20, label %for.end26.loopexit

for.end26.loopexit:                               ; preds = %for.body20
  br label %for.end26

for.end26:                                        ; preds = %for.end26.loopexit, %for.end14
  %putchar174 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -1.370000e+01, double 1.000000e+00, double -3.500000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call29 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %15 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp31188 = icmp sgt i32 %15, 0
  br i1 %cmp31188, label %for.body32.preheader, label %for.end38

for.body32.preheader:                             ; preds = %for.end26
  br label %for.body32

for.body32:                                       ; preds = %for.body32, %for.body32.preheader
  %indvars.iv207 = phi i64 [ %indvars.iv.next208, %for.body32 ], [ 0, %for.body32.preheader ]
  %scevgep3 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv207
  %16 = load double, double* %scevgep3, align 8, !tbaa !5
  %call35 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %16)
  %indvars.iv.next208 = add nuw nsw i64 %indvars.iv207, 1
  %17 = load i32, i32* %solutions, align 4, !tbaa !1
  %18 = sext i32 %17 to i64
  %cmp31 = icmp slt i64 %indvars.iv.next208, %18
  br i1 %cmp31, label %for.body32, label %for.end38.loopexit

for.end38.loopexit:                               ; preds = %for.body32
  br label %for.end38

for.end38:                                        ; preds = %for.end38.loopexit, %for.end26
  %putchar175 = call i32 @putchar(i32 10) #4
  br label %for.cond43.preheader

for.cond43.preheader:                             ; preds = %for.inc71, %for.end38
  %IV.S.1 = phi double [ 1.000000e+00, %for.end38 ], [ %IV.S.next.2, %for.inc71 ]
  %a1.0187.int = phi i32 [ 1, %for.end38 ], [ %inc72.int, %for.inc71 ]
  br label %for.cond46.preheader

for.cond46.preheader:                             ; preds = %for.inc68, %for.cond43.preheader
  %b1.0186.int = phi i32 [ 10, %for.cond43.preheader ], [ %dec69.int, %for.inc68 ]
  %indvar.conv203 = sitofp i32 %b1.0186.int to double
  br label %for.cond49.preheader

for.cond49.preheader:                             ; preds = %for.inc66, %for.cond46.preheader
  %c1.0185 = phi double [ 5.000000e+00, %for.cond46.preheader ], [ %add, %for.inc66 ]
  br label %for.body51

for.body51:                                       ; preds = %for.end62, %for.cond49.preheader
  %d1.0184.int = phi i32 [ -1, %for.cond49.preheader ], [ %dec.int, %for.end62 ]
  %indvar.conv201 = sitofp i32 %d1.0184.int to double
  call void @SolveCubic(double %IV.S.1, double %indvar.conv203, double %c1.0185, double %indvar.conv201, i32* nonnull %solutions, double* %arraydecay) #4
  %call53 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %19 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp55182 = icmp sgt i32 %19, 0
  br i1 %cmp55182, label %for.body56.preheader, label %for.end62

for.body56.preheader:                             ; preds = %for.body51
  br label %for.body56

for.body56:                                       ; preds = %for.body56, %for.body56.preheader
  %indvars.iv198 = phi i64 [ %indvars.iv.next199, %for.body56 ], [ 0, %for.body56.preheader ]
  %scevgep = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv198
  %20 = load double, double* %scevgep, align 8, !tbaa !5
  %call59 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %20)
  %indvars.iv.next199 = add nuw nsw i64 %indvars.iv198, 1
  %21 = load i32, i32* %solutions, align 4, !tbaa !1
  %22 = sext i32 %21 to i64
  %cmp55 = icmp slt i64 %indvars.iv.next199, %22
  br i1 %cmp55, label %for.body56, label %for.end62.loopexit

for.end62.loopexit:                               ; preds = %for.body56
  br label %for.end62

for.end62:                                        ; preds = %for.end62.loopexit, %for.body51
  %putchar178 = call i32 @putchar(i32 10) #4
  %dec.int = add nsw i32 %d1.0184.int, -1
  %cmp50 = icmp sgt i32 %dec.int, -11
  br i1 %cmp50, label %for.body51, label %for.inc66, !llvm.loop !7

for.inc66:                                        ; preds = %for.end62
  %add = fadd double %c1.0185, 5.000000e-01
  %cmp47 = fcmp olt double %add, 1.500000e+01
  br i1 %cmp47, label %for.cond49.preheader, label %for.inc68

for.inc68:                                        ; preds = %for.inc66
  %dec69.int = add nsw i32 %b1.0186.int, -1
  %cmp44 = icmp sgt i32 %b1.0186.int, 1
  br i1 %cmp44, label %for.cond46.preheader, label %for.inc71, !llvm.loop !7

for.inc71:                                        ; preds = %for.inc68
  %IV.S.next.2 = fadd double %IV.S.1, 1.000000e+00
  %inc72.int = add nuw nsw i32 %a1.0187.int, 1
  %exitcond206 = icmp eq i32 %inc72.int, 10
  br i1 %exitcond206, label %for.end73, label %for.cond43.preheader, !llvm.loop !7

for.end73:                                        ; preds = %for.inc71
  %puts176 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([40 x i8], [40 x i8]* @str.11, i64 0, i64 0)) #4
  %sqrt = getelementptr inbounds %struct.int_sqrt, %struct.int_sqrt* %q, i64 0, i32 0
  br label %for.body77

for.body77:                                       ; preds = %for.body77, %for.end73
  %indvars.iv = phi i64 [ 0, %for.end73 ], [ %indvars.iv.next, %for.body77 ]
  call void @usqrt(i64 %indvars.iv, %struct.int_sqrt* nonnull %q) #4
  %23 = load i32, i32* %sqrt, align 4, !tbaa !9
  %tmp = trunc i64 %indvars.iv to i32
  %call78 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.5, i64 0, i64 0), i32 %tmp, i32 %23)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond197 = icmp eq i64 %indvars.iv.next, 1001
  br i1 %exitcond197, label %for.end81, label %for.body77, !llvm.loop !7

for.end81:                                        ; preds = %for.body77
  call void @usqrt(i64 1072497001, %struct.int_sqrt* nonnull %q) #4
  %24 = load i32, i32* %sqrt, align 4, !tbaa !9
  %call83 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.6, i64 0, i64 0), i64 1072497001, i32 %24)
  %puts177 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @str.12, i64 0, i64 0)) #4
  br label %for.body88

for.body88:                                       ; preds = %for.body88, %for.end81
  %lsr.iv = phi i32 [ %lsr.iv.next, %for.body88 ], [ 361, %for.end81 ]
  %IV.S. = phi double [ 0.000000e+00, %for.end81 ], [ %IV.S.next., %for.body88 ]
  %mul90 = fmul double %IV.S., 0x400921FB54442D18
  %div = fdiv double %mul90, 1.800000e+02
  %call91 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.8, i64 0, i64 0), double %IV.S., double %div)
  %IV.S.next. = fadd double %IV.S., 1.000000e+00
  %lsr.iv.next = add nsw i32 %lsr.iv, -1
  %exitcond = icmp eq i32 %lsr.iv.next, 0
  br i1 %exitcond, label %for.end94, label %for.body88

for.end94:                                        ; preds = %for.body88
  %call95 = call i32 (i8*, ...) bitcast (i32 (...)* @puts to i32 (i8*, ...)*)(i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.9, i64 0, i64 0)) #4
  br label %for.body103

for.body103:                                      ; preds = %for.body103, %for.end94
  %X.1179 = phi double [ 0.000000e+00, %for.end94 ], [ %add113, %for.body103 ]
  %mul104 = fmul double %X.1179, 1.800000e+02
  %div107 = fdiv double %mul104, 0x400921FB54442D18
  %call108 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.10, i64 0, i64 0), double %X.1179, double %div107)
  %add113 = fadd double %X.1179, 0x3F91DF46A2529D39
  %cmp101 = fcmp ugt double %add113, 0x401921FB97600B9B
  br i1 %cmp101, label %for.end114, label %for.body103

for.end114:                                       ; preds = %for.body103
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %1) #4
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %0) #4
  ret i32 0
}
*** IR Dump After Expand reduction intrinsics ***
; Function Attrs: nounwind uwtable
define i32 @main() #0 {
entry:
  %x = alloca [3 x double], align 16
  %solutions = alloca i32, align 4
  %q = alloca %struct.int_sqrt, align 4
  %0 = bitcast [3 x double]* %x to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %0) #4
  %1 = bitcast i32* %solutions to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #4
  %2 = bitcast %struct.int_sqrt* %q to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #4
  %puts = tail call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* getelementptr inbounds ([38 x i8], [38 x i8]* @str, i64 0, i64 0)) #4
  %arraydecay = getelementptr inbounds [3 x double], [3 x double]* %x, i64 0, i64 0
  call void @SolveCubic(double 1.000000e+00, double -1.050000e+01, double 3.200000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %3 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp194 = icmp sgt i32 %3, 0
  br i1 %cmp194, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body, %for.body.preheader
  %indvars.iv213 = phi i64 [ %indvars.iv.next214, %for.body ], [ 0, %for.body.preheader ]
  %scevgep6 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv213
  %4 = load double, double* %scevgep6, align 8, !tbaa !5
  %call2 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %4)
  %indvars.iv.next214 = add nuw nsw i64 %indvars.iv213, 1
  %5 = load i32, i32* %solutions, align 4, !tbaa !1
  %6 = sext i32 %5 to i64
  %cmp = icmp slt i64 %indvars.iv.next214, %6
  br i1 %cmp, label %for.body, label %for.end.loopexit

for.end.loopexit:                                 ; preds = %for.body
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %entry
  %putchar = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -4.500000e+00, double 1.700000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call5 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %7 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp7192 = icmp sgt i32 %7, 0
  br i1 %cmp7192, label %for.body8.preheader, label %for.end14

for.body8.preheader:                              ; preds = %for.end
  br label %for.body8

for.body8:                                        ; preds = %for.body8, %for.body8.preheader
  %indvars.iv211 = phi i64 [ %indvars.iv.next212, %for.body8 ], [ 0, %for.body8.preheader ]
  %scevgep5 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv211
  %8 = load double, double* %scevgep5, align 8, !tbaa !5
  %call11 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %8)
  %indvars.iv.next212 = add nuw nsw i64 %indvars.iv211, 1
  %9 = load i32, i32* %solutions, align 4, !tbaa !1
  %10 = sext i32 %9 to i64
  %cmp7 = icmp slt i64 %indvars.iv.next212, %10
  br i1 %cmp7, label %for.body8, label %for.end14.loopexit

for.end14.loopexit:                               ; preds = %for.body8
  br label %for.end14

for.end14:                                        ; preds = %for.end14.loopexit, %for.end
  %putchar173 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -3.500000e+00, double 2.200000e+01, double -3.100000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call17 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %11 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp19190 = icmp sgt i32 %11, 0
  br i1 %cmp19190, label %for.body20.preheader, label %for.end26

for.body20.preheader:                             ; preds = %for.end14
  br label %for.body20

for.body20:                                       ; preds = %for.body20, %for.body20.preheader
  %indvars.iv209 = phi i64 [ %indvars.iv.next210, %for.body20 ], [ 0, %for.body20.preheader ]
  %scevgep4 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv209
  %12 = load double, double* %scevgep4, align 8, !tbaa !5
  %call23 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %12)
  %indvars.iv.next210 = add nuw nsw i64 %indvars.iv209, 1
  %13 = load i32, i32* %solutions, align 4, !tbaa !1
  %14 = sext i32 %13 to i64
  %cmp19 = icmp slt i64 %indvars.iv.next210, %14
  br i1 %cmp19, label %for.body20, label %for.end26.loopexit

for.end26.loopexit:                               ; preds = %for.body20
  br label %for.end26

for.end26:                                        ; preds = %for.end26.loopexit, %for.end14
  %putchar174 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -1.370000e+01, double 1.000000e+00, double -3.500000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call29 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %15 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp31188 = icmp sgt i32 %15, 0
  br i1 %cmp31188, label %for.body32.preheader, label %for.end38

for.body32.preheader:                             ; preds = %for.end26
  br label %for.body32

for.body32:                                       ; preds = %for.body32, %for.body32.preheader
  %indvars.iv207 = phi i64 [ %indvars.iv.next208, %for.body32 ], [ 0, %for.body32.preheader ]
  %scevgep3 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv207
  %16 = load double, double* %scevgep3, align 8, !tbaa !5
  %call35 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %16)
  %indvars.iv.next208 = add nuw nsw i64 %indvars.iv207, 1
  %17 = load i32, i32* %solutions, align 4, !tbaa !1
  %18 = sext i32 %17 to i64
  %cmp31 = icmp slt i64 %indvars.iv.next208, %18
  br i1 %cmp31, label %for.body32, label %for.end38.loopexit

for.end38.loopexit:                               ; preds = %for.body32
  br label %for.end38

for.end38:                                        ; preds = %for.end38.loopexit, %for.end26
  %putchar175 = call i32 @putchar(i32 10) #4
  br label %for.cond43.preheader

for.cond43.preheader:                             ; preds = %for.inc71, %for.end38
  %IV.S.1 = phi double [ 1.000000e+00, %for.end38 ], [ %IV.S.next.2, %for.inc71 ]
  %a1.0187.int = phi i32 [ 1, %for.end38 ], [ %inc72.int, %for.inc71 ]
  br label %for.cond46.preheader

for.cond46.preheader:                             ; preds = %for.inc68, %for.cond43.preheader
  %b1.0186.int = phi i32 [ 10, %for.cond43.preheader ], [ %dec69.int, %for.inc68 ]
  %indvar.conv203 = sitofp i32 %b1.0186.int to double
  br label %for.cond49.preheader

for.cond49.preheader:                             ; preds = %for.inc66, %for.cond46.preheader
  %c1.0185 = phi double [ 5.000000e+00, %for.cond46.preheader ], [ %add, %for.inc66 ]
  br label %for.body51

for.body51:                                       ; preds = %for.end62, %for.cond49.preheader
  %d1.0184.int = phi i32 [ -1, %for.cond49.preheader ], [ %dec.int, %for.end62 ]
  %indvar.conv201 = sitofp i32 %d1.0184.int to double
  call void @SolveCubic(double %IV.S.1, double %indvar.conv203, double %c1.0185, double %indvar.conv201, i32* nonnull %solutions, double* %arraydecay) #4
  %call53 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %19 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp55182 = icmp sgt i32 %19, 0
  br i1 %cmp55182, label %for.body56.preheader, label %for.end62

for.body56.preheader:                             ; preds = %for.body51
  br label %for.body56

for.body56:                                       ; preds = %for.body56, %for.body56.preheader
  %indvars.iv198 = phi i64 [ %indvars.iv.next199, %for.body56 ], [ 0, %for.body56.preheader ]
  %scevgep = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv198
  %20 = load double, double* %scevgep, align 8, !tbaa !5
  %call59 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %20)
  %indvars.iv.next199 = add nuw nsw i64 %indvars.iv198, 1
  %21 = load i32, i32* %solutions, align 4, !tbaa !1
  %22 = sext i32 %21 to i64
  %cmp55 = icmp slt i64 %indvars.iv.next199, %22
  br i1 %cmp55, label %for.body56, label %for.end62.loopexit

for.end62.loopexit:                               ; preds = %for.body56
  br label %for.end62

for.end62:                                        ; preds = %for.end62.loopexit, %for.body51
  %putchar178 = call i32 @putchar(i32 10) #4
  %dec.int = add nsw i32 %d1.0184.int, -1
  %cmp50 = icmp sgt i32 %dec.int, -11
  br i1 %cmp50, label %for.body51, label %for.inc66, !llvm.loop !7

for.inc66:                                        ; preds = %for.end62
  %add = fadd double %c1.0185, 5.000000e-01
  %cmp47 = fcmp olt double %add, 1.500000e+01
  br i1 %cmp47, label %for.cond49.preheader, label %for.inc68

for.inc68:                                        ; preds = %for.inc66
  %dec69.int = add nsw i32 %b1.0186.int, -1
  %cmp44 = icmp sgt i32 %b1.0186.int, 1
  br i1 %cmp44, label %for.cond46.preheader, label %for.inc71, !llvm.loop !7

for.inc71:                                        ; preds = %for.inc68
  %IV.S.next.2 = fadd double %IV.S.1, 1.000000e+00
  %inc72.int = add nuw nsw i32 %a1.0187.int, 1
  %exitcond206 = icmp eq i32 %inc72.int, 10
  br i1 %exitcond206, label %for.end73, label %for.cond43.preheader, !llvm.loop !7

for.end73:                                        ; preds = %for.inc71
  %puts176 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([40 x i8], [40 x i8]* @str.11, i64 0, i64 0)) #4
  %sqrt = getelementptr inbounds %struct.int_sqrt, %struct.int_sqrt* %q, i64 0, i32 0
  br label %for.body77

for.body77:                                       ; preds = %for.body77, %for.end73
  %indvars.iv = phi i64 [ 0, %for.end73 ], [ %indvars.iv.next, %for.body77 ]
  call void @usqrt(i64 %indvars.iv, %struct.int_sqrt* nonnull %q) #4
  %23 = load i32, i32* %sqrt, align 4, !tbaa !9
  %tmp = trunc i64 %indvars.iv to i32
  %call78 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.5, i64 0, i64 0), i32 %tmp, i32 %23)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond197 = icmp eq i64 %indvars.iv.next, 1001
  br i1 %exitcond197, label %for.end81, label %for.body77, !llvm.loop !7

for.end81:                                        ; preds = %for.body77
  call void @usqrt(i64 1072497001, %struct.int_sqrt* nonnull %q) #4
  %24 = load i32, i32* %sqrt, align 4, !tbaa !9
  %call83 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.6, i64 0, i64 0), i64 1072497001, i32 %24)
  %puts177 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @str.12, i64 0, i64 0)) #4
  br label %for.body88

for.body88:                                       ; preds = %for.body88, %for.end81
  %lsr.iv = phi i32 [ %lsr.iv.next, %for.body88 ], [ 361, %for.end81 ]
  %IV.S. = phi double [ 0.000000e+00, %for.end81 ], [ %IV.S.next., %for.body88 ]
  %mul90 = fmul double %IV.S., 0x400921FB54442D18
  %div = fdiv double %mul90, 1.800000e+02
  %call91 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.8, i64 0, i64 0), double %IV.S., double %div)
  %IV.S.next. = fadd double %IV.S., 1.000000e+00
  %lsr.iv.next = add nsw i32 %lsr.iv, -1
  %exitcond = icmp eq i32 %lsr.iv.next, 0
  br i1 %exitcond, label %for.end94, label %for.body88

for.end94:                                        ; preds = %for.body88
  %call95 = call i32 (i8*, ...) bitcast (i32 (...)* @puts to i32 (i8*, ...)*)(i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.9, i64 0, i64 0)) #4
  br label %for.body103

for.body103:                                      ; preds = %for.body103, %for.end94
  %X.1179 = phi double [ 0.000000e+00, %for.end94 ], [ %add113, %for.body103 ]
  %mul104 = fmul double %X.1179, 1.800000e+02
  %div107 = fdiv double %mul104, 0x400921FB54442D18
  %call108 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.10, i64 0, i64 0), double %X.1179, double %div107)
  %add113 = fadd double %X.1179, 0x3F91DF46A2529D39
  %cmp101 = fcmp ugt double %add113, 0x401921FB97600B9B
  br i1 %cmp101, label %for.end114, label %for.body103

for.end114:                                       ; preds = %for.body103
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %1) #4
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %0) #4
  ret i32 0
}
*** IR Dump After Interleaved Access Pass ***
; Function Attrs: nounwind uwtable
define i32 @main() #0 {
entry:
  %x = alloca [3 x double], align 16
  %solutions = alloca i32, align 4
  %q = alloca %struct.int_sqrt, align 4
  %0 = bitcast [3 x double]* %x to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %0) #4
  %1 = bitcast i32* %solutions to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #4
  %2 = bitcast %struct.int_sqrt* %q to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #4
  %puts = tail call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* getelementptr inbounds ([38 x i8], [38 x i8]* @str, i64 0, i64 0)) #4
  %arraydecay = getelementptr inbounds [3 x double], [3 x double]* %x, i64 0, i64 0
  call void @SolveCubic(double 1.000000e+00, double -1.050000e+01, double 3.200000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %3 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp194 = icmp sgt i32 %3, 0
  br i1 %cmp194, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body, %for.body.preheader
  %indvars.iv213 = phi i64 [ %indvars.iv.next214, %for.body ], [ 0, %for.body.preheader ]
  %scevgep6 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv213
  %4 = load double, double* %scevgep6, align 8, !tbaa !5
  %call2 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %4)
  %indvars.iv.next214 = add nuw nsw i64 %indvars.iv213, 1
  %5 = load i32, i32* %solutions, align 4, !tbaa !1
  %6 = sext i32 %5 to i64
  %cmp = icmp slt i64 %indvars.iv.next214, %6
  br i1 %cmp, label %for.body, label %for.end.loopexit

for.end.loopexit:                                 ; preds = %for.body
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %entry
  %putchar = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -4.500000e+00, double 1.700000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call5 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %7 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp7192 = icmp sgt i32 %7, 0
  br i1 %cmp7192, label %for.body8.preheader, label %for.end14

for.body8.preheader:                              ; preds = %for.end
  br label %for.body8

for.body8:                                        ; preds = %for.body8, %for.body8.preheader
  %indvars.iv211 = phi i64 [ %indvars.iv.next212, %for.body8 ], [ 0, %for.body8.preheader ]
  %scevgep5 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv211
  %8 = load double, double* %scevgep5, align 8, !tbaa !5
  %call11 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %8)
  %indvars.iv.next212 = add nuw nsw i64 %indvars.iv211, 1
  %9 = load i32, i32* %solutions, align 4, !tbaa !1
  %10 = sext i32 %9 to i64
  %cmp7 = icmp slt i64 %indvars.iv.next212, %10
  br i1 %cmp7, label %for.body8, label %for.end14.loopexit

for.end14.loopexit:                               ; preds = %for.body8
  br label %for.end14

for.end14:                                        ; preds = %for.end14.loopexit, %for.end
  %putchar173 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -3.500000e+00, double 2.200000e+01, double -3.100000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call17 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %11 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp19190 = icmp sgt i32 %11, 0
  br i1 %cmp19190, label %for.body20.preheader, label %for.end26

for.body20.preheader:                             ; preds = %for.end14
  br label %for.body20

for.body20:                                       ; preds = %for.body20, %for.body20.preheader
  %indvars.iv209 = phi i64 [ %indvars.iv.next210, %for.body20 ], [ 0, %for.body20.preheader ]
  %scevgep4 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv209
  %12 = load double, double* %scevgep4, align 8, !tbaa !5
  %call23 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %12)
  %indvars.iv.next210 = add nuw nsw i64 %indvars.iv209, 1
  %13 = load i32, i32* %solutions, align 4, !tbaa !1
  %14 = sext i32 %13 to i64
  %cmp19 = icmp slt i64 %indvars.iv.next210, %14
  br i1 %cmp19, label %for.body20, label %for.end26.loopexit

for.end26.loopexit:                               ; preds = %for.body20
  br label %for.end26

for.end26:                                        ; preds = %for.end26.loopexit, %for.end14
  %putchar174 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -1.370000e+01, double 1.000000e+00, double -3.500000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call29 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %15 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp31188 = icmp sgt i32 %15, 0
  br i1 %cmp31188, label %for.body32.preheader, label %for.end38

for.body32.preheader:                             ; preds = %for.end26
  br label %for.body32

for.body32:                                       ; preds = %for.body32, %for.body32.preheader
  %indvars.iv207 = phi i64 [ %indvars.iv.next208, %for.body32 ], [ 0, %for.body32.preheader ]
  %scevgep3 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv207
  %16 = load double, double* %scevgep3, align 8, !tbaa !5
  %call35 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %16)
  %indvars.iv.next208 = add nuw nsw i64 %indvars.iv207, 1
  %17 = load i32, i32* %solutions, align 4, !tbaa !1
  %18 = sext i32 %17 to i64
  %cmp31 = icmp slt i64 %indvars.iv.next208, %18
  br i1 %cmp31, label %for.body32, label %for.end38.loopexit

for.end38.loopexit:                               ; preds = %for.body32
  br label %for.end38

for.end38:                                        ; preds = %for.end38.loopexit, %for.end26
  %putchar175 = call i32 @putchar(i32 10) #4
  br label %for.cond43.preheader

for.cond43.preheader:                             ; preds = %for.inc71, %for.end38
  %IV.S.1 = phi double [ 1.000000e+00, %for.end38 ], [ %IV.S.next.2, %for.inc71 ]
  %a1.0187.int = phi i32 [ 1, %for.end38 ], [ %inc72.int, %for.inc71 ]
  br label %for.cond46.preheader

for.cond46.preheader:                             ; preds = %for.inc68, %for.cond43.preheader
  %b1.0186.int = phi i32 [ 10, %for.cond43.preheader ], [ %dec69.int, %for.inc68 ]
  %indvar.conv203 = sitofp i32 %b1.0186.int to double
  br label %for.cond49.preheader

for.cond49.preheader:                             ; preds = %for.inc66, %for.cond46.preheader
  %c1.0185 = phi double [ 5.000000e+00, %for.cond46.preheader ], [ %add, %for.inc66 ]
  br label %for.body51

for.body51:                                       ; preds = %for.end62, %for.cond49.preheader
  %d1.0184.int = phi i32 [ -1, %for.cond49.preheader ], [ %dec.int, %for.end62 ]
  %indvar.conv201 = sitofp i32 %d1.0184.int to double
  call void @SolveCubic(double %IV.S.1, double %indvar.conv203, double %c1.0185, double %indvar.conv201, i32* nonnull %solutions, double* %arraydecay) #4
  %call53 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %19 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp55182 = icmp sgt i32 %19, 0
  br i1 %cmp55182, label %for.body56.preheader, label %for.end62

for.body56.preheader:                             ; preds = %for.body51
  br label %for.body56

for.body56:                                       ; preds = %for.body56, %for.body56.preheader
  %indvars.iv198 = phi i64 [ %indvars.iv.next199, %for.body56 ], [ 0, %for.body56.preheader ]
  %scevgep = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv198
  %20 = load double, double* %scevgep, align 8, !tbaa !5
  %call59 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %20)
  %indvars.iv.next199 = add nuw nsw i64 %indvars.iv198, 1
  %21 = load i32, i32* %solutions, align 4, !tbaa !1
  %22 = sext i32 %21 to i64
  %cmp55 = icmp slt i64 %indvars.iv.next199, %22
  br i1 %cmp55, label %for.body56, label %for.end62.loopexit

for.end62.loopexit:                               ; preds = %for.body56
  br label %for.end62

for.end62:                                        ; preds = %for.end62.loopexit, %for.body51
  %putchar178 = call i32 @putchar(i32 10) #4
  %dec.int = add nsw i32 %d1.0184.int, -1
  %cmp50 = icmp sgt i32 %dec.int, -11
  br i1 %cmp50, label %for.body51, label %for.inc66, !llvm.loop !7

for.inc66:                                        ; preds = %for.end62
  %add = fadd double %c1.0185, 5.000000e-01
  %cmp47 = fcmp olt double %add, 1.500000e+01
  br i1 %cmp47, label %for.cond49.preheader, label %for.inc68

for.inc68:                                        ; preds = %for.inc66
  %dec69.int = add nsw i32 %b1.0186.int, -1
  %cmp44 = icmp sgt i32 %b1.0186.int, 1
  br i1 %cmp44, label %for.cond46.preheader, label %for.inc71, !llvm.loop !7

for.inc71:                                        ; preds = %for.inc68
  %IV.S.next.2 = fadd double %IV.S.1, 1.000000e+00
  %inc72.int = add nuw nsw i32 %a1.0187.int, 1
  %exitcond206 = icmp eq i32 %inc72.int, 10
  br i1 %exitcond206, label %for.end73, label %for.cond43.preheader, !llvm.loop !7

for.end73:                                        ; preds = %for.inc71
  %puts176 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([40 x i8], [40 x i8]* @str.11, i64 0, i64 0)) #4
  %sqrt = getelementptr inbounds %struct.int_sqrt, %struct.int_sqrt* %q, i64 0, i32 0
  br label %for.body77

for.body77:                                       ; preds = %for.body77, %for.end73
  %indvars.iv = phi i64 [ 0, %for.end73 ], [ %indvars.iv.next, %for.body77 ]
  call void @usqrt(i64 %indvars.iv, %struct.int_sqrt* nonnull %q) #4
  %23 = load i32, i32* %sqrt, align 4, !tbaa !9
  %tmp = trunc i64 %indvars.iv to i32
  %call78 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.5, i64 0, i64 0), i32 %tmp, i32 %23)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond197 = icmp eq i64 %indvars.iv.next, 1001
  br i1 %exitcond197, label %for.end81, label %for.body77, !llvm.loop !7

for.end81:                                        ; preds = %for.body77
  call void @usqrt(i64 1072497001, %struct.int_sqrt* nonnull %q) #4
  %24 = load i32, i32* %sqrt, align 4, !tbaa !9
  %call83 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.6, i64 0, i64 0), i64 1072497001, i32 %24)
  %puts177 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @str.12, i64 0, i64 0)) #4
  br label %for.body88

for.body88:                                       ; preds = %for.body88, %for.end81
  %lsr.iv = phi i32 [ %lsr.iv.next, %for.body88 ], [ 361, %for.end81 ]
  %IV.S. = phi double [ 0.000000e+00, %for.end81 ], [ %IV.S.next., %for.body88 ]
  %mul90 = fmul double %IV.S., 0x400921FB54442D18
  %div = fdiv double %mul90, 1.800000e+02
  %call91 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.8, i64 0, i64 0), double %IV.S., double %div)
  %IV.S.next. = fadd double %IV.S., 1.000000e+00
  %lsr.iv.next = add nsw i32 %lsr.iv, -1
  %exitcond = icmp eq i32 %lsr.iv.next, 0
  br i1 %exitcond, label %for.end94, label %for.body88

for.end94:                                        ; preds = %for.body88
  %call95 = call i32 (i8*, ...) bitcast (i32 (...)* @puts to i32 (i8*, ...)*)(i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.9, i64 0, i64 0)) #4
  br label %for.body103

for.body103:                                      ; preds = %for.body103, %for.end94
  %X.1179 = phi double [ 0.000000e+00, %for.end94 ], [ %add113, %for.body103 ]
  %mul104 = fmul double %X.1179, 1.800000e+02
  %div107 = fdiv double %mul104, 0x400921FB54442D18
  %call108 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.10, i64 0, i64 0), double %X.1179, double %div107)
  %add113 = fadd double %X.1179, 0x3F91DF46A2529D39
  %cmp101 = fcmp ugt double %add113, 0x401921FB97600B9B
  br i1 %cmp101, label %for.end114, label %for.body103

for.end114:                                       ; preds = %for.body103
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %1) #4
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %0) #4
  ret i32 0
}
*** IR Dump After Expand indirectbr instructions ***
; Function Attrs: nounwind uwtable
define i32 @main() #0 {
entry:
  %x = alloca [3 x double], align 16
  %solutions = alloca i32, align 4
  %q = alloca %struct.int_sqrt, align 4
  %0 = bitcast [3 x double]* %x to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %0) #4
  %1 = bitcast i32* %solutions to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #4
  %2 = bitcast %struct.int_sqrt* %q to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #4
  %puts = tail call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* getelementptr inbounds ([38 x i8], [38 x i8]* @str, i64 0, i64 0)) #4
  %arraydecay = getelementptr inbounds [3 x double], [3 x double]* %x, i64 0, i64 0
  call void @SolveCubic(double 1.000000e+00, double -1.050000e+01, double 3.200000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %3 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp194 = icmp sgt i32 %3, 0
  br i1 %cmp194, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body, %for.body.preheader
  %indvars.iv213 = phi i64 [ %indvars.iv.next214, %for.body ], [ 0, %for.body.preheader ]
  %scevgep6 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv213
  %4 = load double, double* %scevgep6, align 8, !tbaa !5
  %call2 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %4)
  %indvars.iv.next214 = add nuw nsw i64 %indvars.iv213, 1
  %5 = load i32, i32* %solutions, align 4, !tbaa !1
  %6 = sext i32 %5 to i64
  %cmp = icmp slt i64 %indvars.iv.next214, %6
  br i1 %cmp, label %for.body, label %for.end.loopexit

for.end.loopexit:                                 ; preds = %for.body
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %entry
  %putchar = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -4.500000e+00, double 1.700000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call5 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %7 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp7192 = icmp sgt i32 %7, 0
  br i1 %cmp7192, label %for.body8.preheader, label %for.end14

for.body8.preheader:                              ; preds = %for.end
  br label %for.body8

for.body8:                                        ; preds = %for.body8, %for.body8.preheader
  %indvars.iv211 = phi i64 [ %indvars.iv.next212, %for.body8 ], [ 0, %for.body8.preheader ]
  %scevgep5 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv211
  %8 = load double, double* %scevgep5, align 8, !tbaa !5
  %call11 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %8)
  %indvars.iv.next212 = add nuw nsw i64 %indvars.iv211, 1
  %9 = load i32, i32* %solutions, align 4, !tbaa !1
  %10 = sext i32 %9 to i64
  %cmp7 = icmp slt i64 %indvars.iv.next212, %10
  br i1 %cmp7, label %for.body8, label %for.end14.loopexit

for.end14.loopexit:                               ; preds = %for.body8
  br label %for.end14

for.end14:                                        ; preds = %for.end14.loopexit, %for.end
  %putchar173 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -3.500000e+00, double 2.200000e+01, double -3.100000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call17 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %11 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp19190 = icmp sgt i32 %11, 0
  br i1 %cmp19190, label %for.body20.preheader, label %for.end26

for.body20.preheader:                             ; preds = %for.end14
  br label %for.body20

for.body20:                                       ; preds = %for.body20, %for.body20.preheader
  %indvars.iv209 = phi i64 [ %indvars.iv.next210, %for.body20 ], [ 0, %for.body20.preheader ]
  %scevgep4 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv209
  %12 = load double, double* %scevgep4, align 8, !tbaa !5
  %call23 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %12)
  %indvars.iv.next210 = add nuw nsw i64 %indvars.iv209, 1
  %13 = load i32, i32* %solutions, align 4, !tbaa !1
  %14 = sext i32 %13 to i64
  %cmp19 = icmp slt i64 %indvars.iv.next210, %14
  br i1 %cmp19, label %for.body20, label %for.end26.loopexit

for.end26.loopexit:                               ; preds = %for.body20
  br label %for.end26

for.end26:                                        ; preds = %for.end26.loopexit, %for.end14
  %putchar174 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -1.370000e+01, double 1.000000e+00, double -3.500000e+01, i32* nonnull %solutions, double* %arraydecay) #4
  %call29 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %15 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp31188 = icmp sgt i32 %15, 0
  br i1 %cmp31188, label %for.body32.preheader, label %for.end38

for.body32.preheader:                             ; preds = %for.end26
  br label %for.body32

for.body32:                                       ; preds = %for.body32, %for.body32.preheader
  %indvars.iv207 = phi i64 [ %indvars.iv.next208, %for.body32 ], [ 0, %for.body32.preheader ]
  %scevgep3 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv207
  %16 = load double, double* %scevgep3, align 8, !tbaa !5
  %call35 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %16)
  %indvars.iv.next208 = add nuw nsw i64 %indvars.iv207, 1
  %17 = load i32, i32* %solutions, align 4, !tbaa !1
  %18 = sext i32 %17 to i64
  %cmp31 = icmp slt i64 %indvars.iv.next208, %18
  br i1 %cmp31, label %for.body32, label %for.end38.loopexit

for.end38.loopexit:                               ; preds = %for.body32
  br label %for.end38

for.end38:                                        ; preds = %for.end38.loopexit, %for.end26
  %putchar175 = call i32 @putchar(i32 10) #4
  br label %for.cond43.preheader

for.cond43.preheader:                             ; preds = %for.inc71, %for.end38
  %IV.S.1 = phi double [ 1.000000e+00, %for.end38 ], [ %IV.S.next.2, %for.inc71 ]
  %a1.0187.int = phi i32 [ 1, %for.end38 ], [ %inc72.int, %for.inc71 ]
  br label %for.cond46.preheader

for.cond46.preheader:                             ; preds = %for.inc68, %for.cond43.preheader
  %b1.0186.int = phi i32 [ 10, %for.cond43.preheader ], [ %dec69.int, %for.inc68 ]
  %indvar.conv203 = sitofp i32 %b1.0186.int to double
  br label %for.cond49.preheader

for.cond49.preheader:                             ; preds = %for.inc66, %for.cond46.preheader
  %c1.0185 = phi double [ 5.000000e+00, %for.cond46.preheader ], [ %add, %for.inc66 ]
  br label %for.body51

for.body51:                                       ; preds = %for.end62, %for.cond49.preheader
  %d1.0184.int = phi i32 [ -1, %for.cond49.preheader ], [ %dec.int, %for.end62 ]
  %indvar.conv201 = sitofp i32 %d1.0184.int to double
  call void @SolveCubic(double %IV.S.1, double %indvar.conv203, double %c1.0185, double %indvar.conv201, i32* nonnull %solutions, double* %arraydecay) #4
  %call53 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %19 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp55182 = icmp sgt i32 %19, 0
  br i1 %cmp55182, label %for.body56.preheader, label %for.end62

for.body56.preheader:                             ; preds = %for.body51
  br label %for.body56

for.body56:                                       ; preds = %for.body56, %for.body56.preheader
  %indvars.iv198 = phi i64 [ %indvars.iv.next199, %for.body56 ], [ 0, %for.body56.preheader ]
  %scevgep = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv198
  %20 = load double, double* %scevgep, align 8, !tbaa !5
  %call59 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %20)
  %indvars.iv.next199 = add nuw nsw i64 %indvars.iv198, 1
  %21 = load i32, i32* %solutions, align 4, !tbaa !1
  %22 = sext i32 %21 to i64
  %cmp55 = icmp slt i64 %indvars.iv.next199, %22
  br i1 %cmp55, label %for.body56, label %for.end62.loopexit

for.end62.loopexit:                               ; preds = %for.body56
  br label %for.end62

for.end62:                                        ; preds = %for.end62.loopexit, %for.body51
  %putchar178 = call i32 @putchar(i32 10) #4
  %dec.int = add nsw i32 %d1.0184.int, -1
  %cmp50 = icmp sgt i32 %dec.int, -11
  br i1 %cmp50, label %for.body51, label %for.inc66, !llvm.loop !7

for.inc66:                                        ; preds = %for.end62
  %add = fadd double %c1.0185, 5.000000e-01
  %cmp47 = fcmp olt double %add, 1.500000e+01
  br i1 %cmp47, label %for.cond49.preheader, label %for.inc68

for.inc68:                                        ; preds = %for.inc66
  %dec69.int = add nsw i32 %b1.0186.int, -1
  %cmp44 = icmp sgt i32 %b1.0186.int, 1
  br i1 %cmp44, label %for.cond46.preheader, label %for.inc71, !llvm.loop !7

for.inc71:                                        ; preds = %for.inc68
  %IV.S.next.2 = fadd double %IV.S.1, 1.000000e+00
  %inc72.int = add nuw nsw i32 %a1.0187.int, 1
  %exitcond206 = icmp eq i32 %inc72.int, 10
  br i1 %exitcond206, label %for.end73, label %for.cond43.preheader, !llvm.loop !7

for.end73:                                        ; preds = %for.inc71
  %puts176 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([40 x i8], [40 x i8]* @str.11, i64 0, i64 0)) #4
  %sqrt = getelementptr inbounds %struct.int_sqrt, %struct.int_sqrt* %q, i64 0, i32 0
  br label %for.body77

for.body77:                                       ; preds = %for.body77, %for.end73
  %indvars.iv = phi i64 [ 0, %for.end73 ], [ %indvars.iv.next, %for.body77 ]
  call void @usqrt(i64 %indvars.iv, %struct.int_sqrt* nonnull %q) #4
  %23 = load i32, i32* %sqrt, align 4, !tbaa !9
  %tmp = trunc i64 %indvars.iv to i32
  %call78 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.5, i64 0, i64 0), i32 %tmp, i32 %23)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond197 = icmp eq i64 %indvars.iv.next, 1001
  br i1 %exitcond197, label %for.end81, label %for.body77, !llvm.loop !7

for.end81:                                        ; preds = %for.body77
  call void @usqrt(i64 1072497001, %struct.int_sqrt* nonnull %q) #4
  %24 = load i32, i32* %sqrt, align 4, !tbaa !9
  %call83 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.6, i64 0, i64 0), i64 1072497001, i32 %24)
  %puts177 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @str.12, i64 0, i64 0)) #4
  br label %for.body88

for.body88:                                       ; preds = %for.body88, %for.end81
  %lsr.iv = phi i32 [ %lsr.iv.next, %for.body88 ], [ 361, %for.end81 ]
  %IV.S. = phi double [ 0.000000e+00, %for.end81 ], [ %IV.S.next., %for.body88 ]
  %mul90 = fmul double %IV.S., 0x400921FB54442D18
  %div = fdiv double %mul90, 1.800000e+02
  %call91 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.8, i64 0, i64 0), double %IV.S., double %div)
  %IV.S.next. = fadd double %IV.S., 1.000000e+00
  %lsr.iv.next = add nsw i32 %lsr.iv, -1
  %exitcond = icmp eq i32 %lsr.iv.next, 0
  br i1 %exitcond, label %for.end94, label %for.body88

for.end94:                                        ; preds = %for.body88
  %call95 = call i32 (i8*, ...) bitcast (i32 (...)* @puts to i32 (i8*, ...)*)(i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.9, i64 0, i64 0)) #4
  br label %for.body103

for.body103:                                      ; preds = %for.body103, %for.end94
  %X.1179 = phi double [ 0.000000e+00, %for.end94 ], [ %add113, %for.body103 ]
  %mul104 = fmul double %X.1179, 1.800000e+02
  %div107 = fdiv double %mul104, 0x400921FB54442D18
  %call108 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.10, i64 0, i64 0), double %X.1179, double %div107)
  %add113 = fadd double %X.1179, 0x3F91DF46A2529D39
  %cmp101 = fcmp ugt double %add113, 0x401921FB97600B9B
  br i1 %cmp101, label %for.end114, label %for.body103

for.end114:                                       ; preds = %for.body103
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %1) #4
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %0) #4
  ret i32 0
}
*** IR Dump After CodeGen Prepare ***
; Function Attrs: nounwind uwtable
define i32 @main() #0 {
entry:
  %x = alloca [3 x double], align 16
  %solutions = alloca i32, align 4
  %q = alloca %struct.int_sqrt, align 4
  %0 = bitcast [3 x double]* %x to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %0) #4
  %1 = bitcast i32* %solutions to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #4
  %2 = bitcast %struct.int_sqrt* %q to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #4
  %puts = tail call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* getelementptr inbounds ([38 x i8], [38 x i8]* @str, i64 0, i64 0)) #4
  %arraydecay7 = bitcast [3 x double]* %x to double*
  call void @SolveCubic(double 1.000000e+00, double -1.050000e+01, double 3.200000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %arraydecay7) #4
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %3 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp194 = icmp sgt i32 %3, 0
  br i1 %cmp194, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body, %for.body.preheader
  %indvars.iv213 = phi i64 [ %indvars.iv.next214, %for.body ], [ 0, %for.body.preheader ]
  %scevgep6 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv213
  %4 = load double, double* %scevgep6, align 8, !tbaa !5
  %call2 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %4)
  %indvars.iv.next214 = add nuw nsw i64 %indvars.iv213, 1
  %5 = load i32, i32* %solutions, align 4, !tbaa !1
  %6 = sext i32 %5 to i64
  %cmp = icmp slt i64 %indvars.iv.next214, %6
  br i1 %cmp, label %for.body, label %for.end

for.end:                                          ; preds = %for.body, %entry
  %7 = bitcast [3 x double]* %x to double*
  %putchar = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -4.500000e+00, double 1.700000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %7) #4
  %call5 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %8 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp7192 = icmp sgt i32 %8, 0
  br i1 %cmp7192, label %for.body8.preheader, label %for.end14

for.body8.preheader:                              ; preds = %for.end
  br label %for.body8

for.body8:                                        ; preds = %for.body8, %for.body8.preheader
  %indvars.iv211 = phi i64 [ %indvars.iv.next212, %for.body8 ], [ 0, %for.body8.preheader ]
  %scevgep5 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv211
  %9 = load double, double* %scevgep5, align 8, !tbaa !5
  %call11 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %9)
  %indvars.iv.next212 = add nuw nsw i64 %indvars.iv211, 1
  %10 = load i32, i32* %solutions, align 4, !tbaa !1
  %11 = sext i32 %10 to i64
  %cmp7 = icmp slt i64 %indvars.iv.next212, %11
  br i1 %cmp7, label %for.body8, label %for.end14

for.end14:                                        ; preds = %for.body8, %for.end
  %12 = bitcast [3 x double]* %x to double*
  %putchar173 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -3.500000e+00, double 2.200000e+01, double -3.100000e+01, i32* nonnull %solutions, double* %12) #4
  %call17 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %13 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp19190 = icmp sgt i32 %13, 0
  br i1 %cmp19190, label %for.body20.preheader, label %for.end26

for.body20.preheader:                             ; preds = %for.end14
  br label %for.body20

for.body20:                                       ; preds = %for.body20, %for.body20.preheader
  %indvars.iv209 = phi i64 [ %indvars.iv.next210, %for.body20 ], [ 0, %for.body20.preheader ]
  %scevgep4 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv209
  %14 = load double, double* %scevgep4, align 8, !tbaa !5
  %call23 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %14)
  %indvars.iv.next210 = add nuw nsw i64 %indvars.iv209, 1
  %15 = load i32, i32* %solutions, align 4, !tbaa !1
  %16 = sext i32 %15 to i64
  %cmp19 = icmp slt i64 %indvars.iv.next210, %16
  br i1 %cmp19, label %for.body20, label %for.end26

for.end26:                                        ; preds = %for.body20, %for.end14
  %17 = bitcast [3 x double]* %x to double*
  %putchar174 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -1.370000e+01, double 1.000000e+00, double -3.500000e+01, i32* nonnull %solutions, double* %17) #4
  %call29 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %18 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp31188 = icmp sgt i32 %18, 0
  br i1 %cmp31188, label %for.body32.preheader, label %for.end38

for.body32.preheader:                             ; preds = %for.end26
  br label %for.body32

for.body32:                                       ; preds = %for.body32, %for.body32.preheader
  %indvars.iv207 = phi i64 [ %indvars.iv.next208, %for.body32 ], [ 0, %for.body32.preheader ]
  %scevgep3 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv207
  %19 = load double, double* %scevgep3, align 8, !tbaa !5
  %call35 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %19)
  %indvars.iv.next208 = add nuw nsw i64 %indvars.iv207, 1
  %20 = load i32, i32* %solutions, align 4, !tbaa !1
  %21 = sext i32 %20 to i64
  %cmp31 = icmp slt i64 %indvars.iv.next208, %21
  br i1 %cmp31, label %for.body32, label %for.end38

for.end38:                                        ; preds = %for.body32, %for.end26
  %putchar175 = call i32 @putchar(i32 10) #4
  br label %for.cond43.preheader

for.cond43.preheader:                             ; preds = %for.inc71, %for.end38
  %IV.S.1 = phi double [ 1.000000e+00, %for.end38 ], [ %IV.S.next.2, %for.inc71 ]
  %a1.0187.int = phi i32 [ 1, %for.end38 ], [ %inc72.int, %for.inc71 ]
  br label %for.cond46.preheader

for.cond46.preheader:                             ; preds = %for.inc68, %for.cond43.preheader
  %b1.0186.int = phi i32 [ 10, %for.cond43.preheader ], [ %dec69.int, %for.inc68 ]
  %indvar.conv203 = sitofp i32 %b1.0186.int to double
  br label %for.cond49.preheader

for.cond49.preheader:                             ; preds = %for.inc66, %for.cond46.preheader
  %c1.0185 = phi double [ 5.000000e+00, %for.cond46.preheader ], [ %add, %for.inc66 ]
  br label %for.body51

for.body51:                                       ; preds = %for.end62, %for.cond49.preheader
  %d1.0184.int = phi i32 [ -1, %for.cond49.preheader ], [ %dec.int, %for.end62 ]
  %22 = bitcast [3 x double]* %x to double*
  %indvar.conv201 = sitofp i32 %d1.0184.int to double
  call void @SolveCubic(double %IV.S.1, double %indvar.conv203, double %c1.0185, double %indvar.conv201, i32* nonnull %solutions, double* %22) #4
  %call53 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %23 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp55182 = icmp sgt i32 %23, 0
  br i1 %cmp55182, label %for.body56.preheader, label %for.end62

for.body56.preheader:                             ; preds = %for.body51
  br label %for.body56

for.body56:                                       ; preds = %for.body56, %for.body56.preheader
  %indvars.iv198 = phi i64 [ %indvars.iv.next199, %for.body56 ], [ 0, %for.body56.preheader ]
  %scevgep = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv198
  %24 = load double, double* %scevgep, align 8, !tbaa !5
  %call59 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %24)
  %indvars.iv.next199 = add nuw nsw i64 %indvars.iv198, 1
  %25 = load i32, i32* %solutions, align 4, !tbaa !1
  %26 = sext i32 %25 to i64
  %cmp55 = icmp slt i64 %indvars.iv.next199, %26
  br i1 %cmp55, label %for.body56, label %for.end62

for.end62:                                        ; preds = %for.body56, %for.body51
  %putchar178 = call i32 @putchar(i32 10) #4
  %dec.int = add nsw i32 %d1.0184.int, -1
  %cmp50 = icmp sgt i32 %dec.int, -11
  br i1 %cmp50, label %for.body51, label %for.inc66, !llvm.loop !7

for.inc66:                                        ; preds = %for.end62
  %add = fadd double %c1.0185, 5.000000e-01
  %cmp47 = fcmp olt double %add, 1.500000e+01
  br i1 %cmp47, label %for.cond49.preheader, label %for.inc68

for.inc68:                                        ; preds = %for.inc66
  %dec69.int = add nsw i32 %b1.0186.int, -1
  %cmp44 = icmp sgt i32 %b1.0186.int, 1
  br i1 %cmp44, label %for.cond46.preheader, label %for.inc71, !llvm.loop !7

for.inc71:                                        ; preds = %for.inc68
  %IV.S.next.2 = fadd double %IV.S.1, 1.000000e+00
  %inc72.int = add nuw nsw i32 %a1.0187.int, 1
  %exitcond206 = icmp eq i32 %inc72.int, 10
  br i1 %exitcond206, label %for.end73, label %for.cond43.preheader, !llvm.loop !7

for.end73:                                        ; preds = %for.inc71
  %puts176 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([40 x i8], [40 x i8]* @str.11, i64 0, i64 0)) #4
  br label %for.body77

for.body77:                                       ; preds = %for.body77, %for.end73
  %indvars.iv = phi i64 [ 0, %for.end73 ], [ %indvars.iv.next, %for.body77 ]
  %27 = bitcast %struct.int_sqrt* %q to i32*
  call void @usqrt(i64 %indvars.iv, %struct.int_sqrt* nonnull %q) #4
  %28 = load i32, i32* %27, align 4, !tbaa !9
  %tmp = trunc i64 %indvars.iv to i32
  %call78 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.5, i64 0, i64 0), i32 %tmp, i32 %28)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond197 = icmp eq i64 %indvars.iv.next, 1001
  br i1 %exitcond197, label %for.end81, label %for.body77, !llvm.loop !7

for.end81:                                        ; preds = %for.body77
  %29 = bitcast %struct.int_sqrt* %q to i32*
  call void @usqrt(i64 1072497001, %struct.int_sqrt* nonnull %q) #4
  %30 = load i32, i32* %29, align 4, !tbaa !9
  %call83 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.6, i64 0, i64 0), i64 1072497001, i32 %30)
  %puts177 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @str.12, i64 0, i64 0)) #4
  br label %for.body88

for.body88:                                       ; preds = %for.body88, %for.end81
  %lsr.iv = phi i32 [ %lsr.iv.next, %for.body88 ], [ 361, %for.end81 ]
  %IV.S. = phi double [ 0.000000e+00, %for.end81 ], [ %IV.S.next., %for.body88 ]
  %mul90 = fmul double %IV.S., 0x400921FB54442D18
  %div = fdiv double %mul90, 1.800000e+02
  %call91 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.8, i64 0, i64 0), double %IV.S., double %div)
  %IV.S.next. = fadd double %IV.S., 1.000000e+00
  %lsr.iv.next = add nsw i32 %lsr.iv, -1
  %exitcond = icmp eq i32 %lsr.iv.next, 0
  br i1 %exitcond, label %for.end94, label %for.body88

for.end94:                                        ; preds = %for.body88
  %call95 = call i32 (i8*, ...) bitcast (i32 (...)* @puts to i32 (i8*, ...)*)(i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.9, i64 0, i64 0)) #4
  br label %for.body103

for.body103:                                      ; preds = %for.body103, %for.end94
  %X.1179 = phi double [ 0.000000e+00, %for.end94 ], [ %add113, %for.body103 ]
  %mul104 = fmul double %X.1179, 1.800000e+02
  %div107 = fdiv double %mul104, 0x400921FB54442D18
  %call108 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.10, i64 0, i64 0), double %X.1179, double %div107)
  %add113 = fadd double %X.1179, 0x3F91DF46A2529D39
  %cmp101 = fcmp ugt double %add113, 0x401921FB97600B9B
  br i1 %cmp101, label %for.end114, label %for.body103

for.end114:                                       ; preds = %for.body103
  %31 = bitcast %struct.int_sqrt* %q to i8*
  %32 = bitcast i32* %solutions to i8*
  %33 = bitcast [3 x double]* %x to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %31) #4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %32) #4
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %33) #4
  ret i32 0
}
*** IR Dump After Rewrite Symbols ***
; ModuleID = 'basicmath_small.ll'
source_filename = "basicmath_small.ll"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.int_sqrt = type { i32, i32 }

@.str.1 = private unnamed_addr constant [11 x i8] c"Solutions:\00", align 1
@.str.2 = private unnamed_addr constant [4 x i8] c" %f\00", align 1
@.str.5 = private unnamed_addr constant [17 x i8] c"sqrt(%3d) = %2d\0A\00", align 1
@.str.6 = private unnamed_addr constant [17 x i8] c"\0Asqrt(%lX) = %X\0A\00", align 1
@.str.8 = private unnamed_addr constant [31 x i8] c"%3.0f degrees = %.12f radians\0A\00", align 1
@.str.9 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.10 = private unnamed_addr constant [31 x i8] c"%.12f radians = %3.0f degrees\0A\00", align 1
@str = private unnamed_addr constant [38 x i8] c"********* CUBIC FUNCTIONS ***********\00"
@str.11 = private unnamed_addr constant [40 x i8] c"********* INTEGER SQR ROOTS ***********\00"
@str.12 = private unnamed_addr constant [39 x i8] c"********* ANGLE CONVERSION ***********\00"

; Function Attrs: nounwind uwtable
define i32 @main() #0 {
entry:
  %x = alloca [3 x double], align 16
  %solutions = alloca i32, align 4
  %q = alloca %struct.int_sqrt, align 4
  %0 = bitcast [3 x double]* %x to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %0) #4
  %1 = bitcast i32* %solutions to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #4
  %2 = bitcast %struct.int_sqrt* %q to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #4
  %puts = tail call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* getelementptr inbounds ([38 x i8], [38 x i8]* @str, i64 0, i64 0)) #4
  %arraydecay7 = bitcast [3 x double]* %x to double*
  call void @SolveCubic(double 1.000000e+00, double -1.050000e+01, double 3.200000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %arraydecay7) #4
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %3 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp194 = icmp sgt i32 %3, 0
  br i1 %cmp194, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body, %for.body.preheader
  %indvars.iv213 = phi i64 [ %indvars.iv.next214, %for.body ], [ 0, %for.body.preheader ]
  %scevgep6 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv213
  %4 = load double, double* %scevgep6, align 8, !tbaa !5
  %call2 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %4)
  %indvars.iv.next214 = add nuw nsw i64 %indvars.iv213, 1
  %5 = load i32, i32* %solutions, align 4, !tbaa !1
  %6 = sext i32 %5 to i64
  %cmp = icmp slt i64 %indvars.iv.next214, %6
  br i1 %cmp, label %for.body, label %for.end

for.end:                                          ; preds = %for.body, %entry
  %7 = bitcast [3 x double]* %x to double*
  %putchar = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -4.500000e+00, double 1.700000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %7) #4
  %call5 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %8 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp7192 = icmp sgt i32 %8, 0
  br i1 %cmp7192, label %for.body8.preheader, label %for.end14

for.body8.preheader:                              ; preds = %for.end
  br label %for.body8

for.body8:                                        ; preds = %for.body8, %for.body8.preheader
  %indvars.iv211 = phi i64 [ %indvars.iv.next212, %for.body8 ], [ 0, %for.body8.preheader ]
  %scevgep5 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv211
  %9 = load double, double* %scevgep5, align 8, !tbaa !5
  %call11 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %9)
  %indvars.iv.next212 = add nuw nsw i64 %indvars.iv211, 1
  %10 = load i32, i32* %solutions, align 4, !tbaa !1
  %11 = sext i32 %10 to i64
  %cmp7 = icmp slt i64 %indvars.iv.next212, %11
  br i1 %cmp7, label %for.body8, label %for.end14

for.end14:                                        ; preds = %for.body8, %for.end
  %12 = bitcast [3 x double]* %x to double*
  %putchar173 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -3.500000e+00, double 2.200000e+01, double -3.100000e+01, i32* nonnull %solutions, double* %12) #4
  %call17 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %13 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp19190 = icmp sgt i32 %13, 0
  br i1 %cmp19190, label %for.body20.preheader, label %for.end26

for.body20.preheader:                             ; preds = %for.end14
  br label %for.body20

for.body20:                                       ; preds = %for.body20, %for.body20.preheader
  %indvars.iv209 = phi i64 [ %indvars.iv.next210, %for.body20 ], [ 0, %for.body20.preheader ]
  %scevgep4 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv209
  %14 = load double, double* %scevgep4, align 8, !tbaa !5
  %call23 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %14)
  %indvars.iv.next210 = add nuw nsw i64 %indvars.iv209, 1
  %15 = load i32, i32* %solutions, align 4, !tbaa !1
  %16 = sext i32 %15 to i64
  %cmp19 = icmp slt i64 %indvars.iv.next210, %16
  br i1 %cmp19, label %for.body20, label %for.end26

for.end26:                                        ; preds = %for.body20, %for.end14
  %17 = bitcast [3 x double]* %x to double*
  %putchar174 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -1.370000e+01, double 1.000000e+00, double -3.500000e+01, i32* nonnull %solutions, double* %17) #4
  %call29 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %18 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp31188 = icmp sgt i32 %18, 0
  br i1 %cmp31188, label %for.body32.preheader, label %for.end38

for.body32.preheader:                             ; preds = %for.end26
  br label %for.body32

for.body32:                                       ; preds = %for.body32, %for.body32.preheader
  %indvars.iv207 = phi i64 [ %indvars.iv.next208, %for.body32 ], [ 0, %for.body32.preheader ]
  %scevgep3 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv207
  %19 = load double, double* %scevgep3, align 8, !tbaa !5
  %call35 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %19)
  %indvars.iv.next208 = add nuw nsw i64 %indvars.iv207, 1
  %20 = load i32, i32* %solutions, align 4, !tbaa !1
  %21 = sext i32 %20 to i64
  %cmp31 = icmp slt i64 %indvars.iv.next208, %21
  br i1 %cmp31, label %for.body32, label %for.end38

for.end38:                                        ; preds = %for.body32, %for.end26
  %putchar175 = call i32 @putchar(i32 10) #4
  br label %for.cond43.preheader

for.cond43.preheader:                             ; preds = %for.inc71, %for.end38
  %IV.S.1 = phi double [ 1.000000e+00, %for.end38 ], [ %IV.S.next.2, %for.inc71 ]
  %a1.0187.int = phi i32 [ 1, %for.end38 ], [ %inc72.int, %for.inc71 ]
  br label %for.cond46.preheader

for.cond46.preheader:                             ; preds = %for.inc68, %for.cond43.preheader
  %b1.0186.int = phi i32 [ 10, %for.cond43.preheader ], [ %dec69.int, %for.inc68 ]
  %indvar.conv203 = sitofp i32 %b1.0186.int to double
  br label %for.cond49.preheader

for.cond49.preheader:                             ; preds = %for.inc66, %for.cond46.preheader
  %c1.0185 = phi double [ 5.000000e+00, %for.cond46.preheader ], [ %add, %for.inc66 ]
  br label %for.body51

for.body51:                                       ; preds = %for.end62, %for.cond49.preheader
  %d1.0184.int = phi i32 [ -1, %for.cond49.preheader ], [ %dec.int, %for.end62 ]
  %22 = bitcast [3 x double]* %x to double*
  %indvar.conv201 = sitofp i32 %d1.0184.int to double
  call void @SolveCubic(double %IV.S.1, double %indvar.conv203, double %c1.0185, double %indvar.conv201, i32* nonnull %solutions, double* %22) #4
  %call53 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %23 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp55182 = icmp sgt i32 %23, 0
  br i1 %cmp55182, label %for.body56.preheader, label %for.end62

for.body56.preheader:                             ; preds = %for.body51
  br label %for.body56

for.body56:                                       ; preds = %for.body56, %for.body56.preheader
  %indvars.iv198 = phi i64 [ %indvars.iv.next199, %for.body56 ], [ 0, %for.body56.preheader ]
  %scevgep = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv198
  %24 = load double, double* %scevgep, align 8, !tbaa !5
  %call59 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %24)
  %indvars.iv.next199 = add nuw nsw i64 %indvars.iv198, 1
  %25 = load i32, i32* %solutions, align 4, !tbaa !1
  %26 = sext i32 %25 to i64
  %cmp55 = icmp slt i64 %indvars.iv.next199, %26
  br i1 %cmp55, label %for.body56, label %for.end62

for.end62:                                        ; preds = %for.body56, %for.body51
  %putchar178 = call i32 @putchar(i32 10) #4
  %dec.int = add nsw i32 %d1.0184.int, -1
  %cmp50 = icmp sgt i32 %dec.int, -11
  br i1 %cmp50, label %for.body51, label %for.inc66, !llvm.loop !7

for.inc66:                                        ; preds = %for.end62
  %add = fadd double %c1.0185, 5.000000e-01
  %cmp47 = fcmp olt double %add, 1.500000e+01
  br i1 %cmp47, label %for.cond49.preheader, label %for.inc68

for.inc68:                                        ; preds = %for.inc66
  %dec69.int = add nsw i32 %b1.0186.int, -1
  %cmp44 = icmp sgt i32 %b1.0186.int, 1
  br i1 %cmp44, label %for.cond46.preheader, label %for.inc71, !llvm.loop !7

for.inc71:                                        ; preds = %for.inc68
  %IV.S.next.2 = fadd double %IV.S.1, 1.000000e+00
  %inc72.int = add nuw nsw i32 %a1.0187.int, 1
  %exitcond206 = icmp eq i32 %inc72.int, 10
  br i1 %exitcond206, label %for.end73, label %for.cond43.preheader, !llvm.loop !7

for.end73:                                        ; preds = %for.inc71
  %puts176 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([40 x i8], [40 x i8]* @str.11, i64 0, i64 0)) #4
  br label %for.body77

for.body77:                                       ; preds = %for.body77, %for.end73
  %indvars.iv = phi i64 [ 0, %for.end73 ], [ %indvars.iv.next, %for.body77 ]
  %27 = bitcast %struct.int_sqrt* %q to i32*
  call void @usqrt(i64 %indvars.iv, %struct.int_sqrt* nonnull %q) #4
  %28 = load i32, i32* %27, align 4, !tbaa !9
  %tmp = trunc i64 %indvars.iv to i32
  %call78 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.5, i64 0, i64 0), i32 %tmp, i32 %28)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond197 = icmp eq i64 %indvars.iv.next, 1001
  br i1 %exitcond197, label %for.end81, label %for.body77, !llvm.loop !7

for.end81:                                        ; preds = %for.body77
  %29 = bitcast %struct.int_sqrt* %q to i32*
  call void @usqrt(i64 1072497001, %struct.int_sqrt* nonnull %q) #4
  %30 = load i32, i32* %29, align 4, !tbaa !9
  %call83 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.6, i64 0, i64 0), i64 1072497001, i32 %30)
  %puts177 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @str.12, i64 0, i64 0)) #4
  br label %for.body88

for.body88:                                       ; preds = %for.body88, %for.end81
  %lsr.iv = phi i32 [ %lsr.iv.next, %for.body88 ], [ 361, %for.end81 ]
  %IV.S. = phi double [ 0.000000e+00, %for.end81 ], [ %IV.S.next., %for.body88 ]
  %mul90 = fmul double %IV.S., 0x400921FB54442D18
  %div = fdiv double %mul90, 1.800000e+02
  %call91 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.8, i64 0, i64 0), double %IV.S., double %div)
  %IV.S.next. = fadd double %IV.S., 1.000000e+00
  %lsr.iv.next = add nsw i32 %lsr.iv, -1
  %exitcond = icmp eq i32 %lsr.iv.next, 0
  br i1 %exitcond, label %for.end94, label %for.body88

for.end94:                                        ; preds = %for.body88
  %call95 = call i32 (i8*, ...) bitcast (i32 (...)* @puts to i32 (i8*, ...)*)(i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.9, i64 0, i64 0)) #4
  br label %for.body103

for.body103:                                      ; preds = %for.body103, %for.end94
  %X.1179 = phi double [ 0.000000e+00, %for.end94 ], [ %add113, %for.body103 ]
  %mul104 = fmul double %X.1179, 1.800000e+02
  %div107 = fdiv double %mul104, 0x400921FB54442D18
  %call108 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.10, i64 0, i64 0), double %X.1179, double %div107)
  %add113 = fadd double %X.1179, 0x3F91DF46A2529D39
  %cmp101 = fcmp ugt double %add113, 0x401921FB97600B9B
  br i1 %cmp101, label %for.end114, label %for.body103

for.end114:                                       ; preds = %for.body103
  %31 = bitcast %struct.int_sqrt* %q to i8*
  %32 = bitcast i32* %solutions to i8*
  %33 = bitcast [3 x double]* %x to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %31) #4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %32) #4
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %33) #4
  ret i32 0
}

; Function Attrs: nounwind
declare i32 @printf(i8* nocapture readonly, ...) #1

declare void @SolveCubic(double, double, double, double, i32*, double*) #2

declare void @usqrt(i64, %struct.int_sqrt*) #2

declare i32 @puts(...) #2

declare i32 @putchar(i32)

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.lifetime.start.p0i8(i64 immarg, i8* nocapture) #3

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.lifetime.end.p0i8(i64 immarg, i8* nocapture) #3

attributes #0 = { nounwind uwtable "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind willreturn }
attributes #4 = { nounwind }

!llvm.ident = !{!0}

!0 = !{!"clang version 3.8.0 (tags/RELEASE_380/final)"}
!1 = !{!2, !2, i64 0}
!2 = !{!"int", !3, i64 0}
!3 = !{!"omnipotent char", !4, i64 0}
!4 = !{!"Simple C/C++ TBAA"}
!5 = !{!6, !6, i64 0}
!6 = !{!"double", !3, i64 0}
!7 = distinct !{!7, !8}
!8 = !{!"llvm.loop.loop2recursion.copy.enable"}
!9 = !{!10, !2, i64 0}
!10 = !{!"int_sqrt", !2, i64 0, !2, i64 4}
*** IR Dump After Exception handling preparation ***
; Function Attrs: nounwind uwtable
define i32 @main() #0 {
entry:
  %x = alloca [3 x double], align 16
  %solutions = alloca i32, align 4
  %q = alloca %struct.int_sqrt, align 4
  %0 = bitcast [3 x double]* %x to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %0) #4
  %1 = bitcast i32* %solutions to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #4
  %2 = bitcast %struct.int_sqrt* %q to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #4
  %puts = tail call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* getelementptr inbounds ([38 x i8], [38 x i8]* @str, i64 0, i64 0)) #4
  %arraydecay7 = bitcast [3 x double]* %x to double*
  call void @SolveCubic(double 1.000000e+00, double -1.050000e+01, double 3.200000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %arraydecay7) #4
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %3 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp194 = icmp sgt i32 %3, 0
  br i1 %cmp194, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body, %for.body.preheader
  %indvars.iv213 = phi i64 [ %indvars.iv.next214, %for.body ], [ 0, %for.body.preheader ]
  %scevgep6 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv213
  %4 = load double, double* %scevgep6, align 8, !tbaa !5
  %call2 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %4)
  %indvars.iv.next214 = add nuw nsw i64 %indvars.iv213, 1
  %5 = load i32, i32* %solutions, align 4, !tbaa !1
  %6 = sext i32 %5 to i64
  %cmp = icmp slt i64 %indvars.iv.next214, %6
  br i1 %cmp, label %for.body, label %for.end

for.end:                                          ; preds = %for.body, %entry
  %7 = bitcast [3 x double]* %x to double*
  %putchar = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -4.500000e+00, double 1.700000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %7) #4
  %call5 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %8 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp7192 = icmp sgt i32 %8, 0
  br i1 %cmp7192, label %for.body8.preheader, label %for.end14

for.body8.preheader:                              ; preds = %for.end
  br label %for.body8

for.body8:                                        ; preds = %for.body8, %for.body8.preheader
  %indvars.iv211 = phi i64 [ %indvars.iv.next212, %for.body8 ], [ 0, %for.body8.preheader ]
  %scevgep5 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv211
  %9 = load double, double* %scevgep5, align 8, !tbaa !5
  %call11 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %9)
  %indvars.iv.next212 = add nuw nsw i64 %indvars.iv211, 1
  %10 = load i32, i32* %solutions, align 4, !tbaa !1
  %11 = sext i32 %10 to i64
  %cmp7 = icmp slt i64 %indvars.iv.next212, %11
  br i1 %cmp7, label %for.body8, label %for.end14

for.end14:                                        ; preds = %for.body8, %for.end
  %12 = bitcast [3 x double]* %x to double*
  %putchar173 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -3.500000e+00, double 2.200000e+01, double -3.100000e+01, i32* nonnull %solutions, double* %12) #4
  %call17 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %13 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp19190 = icmp sgt i32 %13, 0
  br i1 %cmp19190, label %for.body20.preheader, label %for.end26

for.body20.preheader:                             ; preds = %for.end14
  br label %for.body20

for.body20:                                       ; preds = %for.body20, %for.body20.preheader
  %indvars.iv209 = phi i64 [ %indvars.iv.next210, %for.body20 ], [ 0, %for.body20.preheader ]
  %scevgep4 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv209
  %14 = load double, double* %scevgep4, align 8, !tbaa !5
  %call23 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %14)
  %indvars.iv.next210 = add nuw nsw i64 %indvars.iv209, 1
  %15 = load i32, i32* %solutions, align 4, !tbaa !1
  %16 = sext i32 %15 to i64
  %cmp19 = icmp slt i64 %indvars.iv.next210, %16
  br i1 %cmp19, label %for.body20, label %for.end26

for.end26:                                        ; preds = %for.body20, %for.end14
  %17 = bitcast [3 x double]* %x to double*
  %putchar174 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -1.370000e+01, double 1.000000e+00, double -3.500000e+01, i32* nonnull %solutions, double* %17) #4
  %call29 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %18 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp31188 = icmp sgt i32 %18, 0
  br i1 %cmp31188, label %for.body32.preheader, label %for.end38

for.body32.preheader:                             ; preds = %for.end26
  br label %for.body32

for.body32:                                       ; preds = %for.body32, %for.body32.preheader
  %indvars.iv207 = phi i64 [ %indvars.iv.next208, %for.body32 ], [ 0, %for.body32.preheader ]
  %scevgep3 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv207
  %19 = load double, double* %scevgep3, align 8, !tbaa !5
  %call35 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %19)
  %indvars.iv.next208 = add nuw nsw i64 %indvars.iv207, 1
  %20 = load i32, i32* %solutions, align 4, !tbaa !1
  %21 = sext i32 %20 to i64
  %cmp31 = icmp slt i64 %indvars.iv.next208, %21
  br i1 %cmp31, label %for.body32, label %for.end38

for.end38:                                        ; preds = %for.body32, %for.end26
  %putchar175 = call i32 @putchar(i32 10) #4
  br label %for.cond43.preheader

for.cond43.preheader:                             ; preds = %for.inc71, %for.end38
  %IV.S.1 = phi double [ 1.000000e+00, %for.end38 ], [ %IV.S.next.2, %for.inc71 ]
  %a1.0187.int = phi i32 [ 1, %for.end38 ], [ %inc72.int, %for.inc71 ]
  br label %for.cond46.preheader

for.cond46.preheader:                             ; preds = %for.inc68, %for.cond43.preheader
  %b1.0186.int = phi i32 [ 10, %for.cond43.preheader ], [ %dec69.int, %for.inc68 ]
  %indvar.conv203 = sitofp i32 %b1.0186.int to double
  br label %for.cond49.preheader

for.cond49.preheader:                             ; preds = %for.inc66, %for.cond46.preheader
  %c1.0185 = phi double [ 5.000000e+00, %for.cond46.preheader ], [ %add, %for.inc66 ]
  br label %for.body51

for.body51:                                       ; preds = %for.end62, %for.cond49.preheader
  %d1.0184.int = phi i32 [ -1, %for.cond49.preheader ], [ %dec.int, %for.end62 ]
  %22 = bitcast [3 x double]* %x to double*
  %indvar.conv201 = sitofp i32 %d1.0184.int to double
  call void @SolveCubic(double %IV.S.1, double %indvar.conv203, double %c1.0185, double %indvar.conv201, i32* nonnull %solutions, double* %22) #4
  %call53 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %23 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp55182 = icmp sgt i32 %23, 0
  br i1 %cmp55182, label %for.body56.preheader, label %for.end62

for.body56.preheader:                             ; preds = %for.body51
  br label %for.body56

for.body56:                                       ; preds = %for.body56, %for.body56.preheader
  %indvars.iv198 = phi i64 [ %indvars.iv.next199, %for.body56 ], [ 0, %for.body56.preheader ]
  %scevgep = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv198
  %24 = load double, double* %scevgep, align 8, !tbaa !5
  %call59 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %24)
  %indvars.iv.next199 = add nuw nsw i64 %indvars.iv198, 1
  %25 = load i32, i32* %solutions, align 4, !tbaa !1
  %26 = sext i32 %25 to i64
  %cmp55 = icmp slt i64 %indvars.iv.next199, %26
  br i1 %cmp55, label %for.body56, label %for.end62

for.end62:                                        ; preds = %for.body56, %for.body51
  %putchar178 = call i32 @putchar(i32 10) #4
  %dec.int = add nsw i32 %d1.0184.int, -1
  %cmp50 = icmp sgt i32 %dec.int, -11
  br i1 %cmp50, label %for.body51, label %for.inc66, !llvm.loop !7

for.inc66:                                        ; preds = %for.end62
  %add = fadd double %c1.0185, 5.000000e-01
  %cmp47 = fcmp olt double %add, 1.500000e+01
  br i1 %cmp47, label %for.cond49.preheader, label %for.inc68

for.inc68:                                        ; preds = %for.inc66
  %dec69.int = add nsw i32 %b1.0186.int, -1
  %cmp44 = icmp sgt i32 %b1.0186.int, 1
  br i1 %cmp44, label %for.cond46.preheader, label %for.inc71, !llvm.loop !7

for.inc71:                                        ; preds = %for.inc68
  %IV.S.next.2 = fadd double %IV.S.1, 1.000000e+00
  %inc72.int = add nuw nsw i32 %a1.0187.int, 1
  %exitcond206 = icmp eq i32 %inc72.int, 10
  br i1 %exitcond206, label %for.end73, label %for.cond43.preheader, !llvm.loop !7

for.end73:                                        ; preds = %for.inc71
  %puts176 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([40 x i8], [40 x i8]* @str.11, i64 0, i64 0)) #4
  br label %for.body77

for.body77:                                       ; preds = %for.body77, %for.end73
  %indvars.iv = phi i64 [ 0, %for.end73 ], [ %indvars.iv.next, %for.body77 ]
  %27 = bitcast %struct.int_sqrt* %q to i32*
  call void @usqrt(i64 %indvars.iv, %struct.int_sqrt* nonnull %q) #4
  %28 = load i32, i32* %27, align 4, !tbaa !9
  %tmp = trunc i64 %indvars.iv to i32
  %call78 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.5, i64 0, i64 0), i32 %tmp, i32 %28)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond197 = icmp eq i64 %indvars.iv.next, 1001
  br i1 %exitcond197, label %for.end81, label %for.body77, !llvm.loop !7

for.end81:                                        ; preds = %for.body77
  %29 = bitcast %struct.int_sqrt* %q to i32*
  call void @usqrt(i64 1072497001, %struct.int_sqrt* nonnull %q) #4
  %30 = load i32, i32* %29, align 4, !tbaa !9
  %call83 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.6, i64 0, i64 0), i64 1072497001, i32 %30)
  %puts177 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @str.12, i64 0, i64 0)) #4
  br label %for.body88

for.body88:                                       ; preds = %for.body88, %for.end81
  %lsr.iv = phi i32 [ %lsr.iv.next, %for.body88 ], [ 361, %for.end81 ]
  %IV.S. = phi double [ 0.000000e+00, %for.end81 ], [ %IV.S.next., %for.body88 ]
  %mul90 = fmul double %IV.S., 0x400921FB54442D18
  %div = fdiv double %mul90, 1.800000e+02
  %call91 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.8, i64 0, i64 0), double %IV.S., double %div)
  %IV.S.next. = fadd double %IV.S., 1.000000e+00
  %lsr.iv.next = add nsw i32 %lsr.iv, -1
  %exitcond = icmp eq i32 %lsr.iv.next, 0
  br i1 %exitcond, label %for.end94, label %for.body88

for.end94:                                        ; preds = %for.body88
  %call95 = call i32 (i8*, ...) bitcast (i32 (...)* @puts to i32 (i8*, ...)*)(i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.9, i64 0, i64 0)) #4
  br label %for.body103

for.body103:                                      ; preds = %for.body103, %for.end94
  %X.1179 = phi double [ 0.000000e+00, %for.end94 ], [ %add113, %for.body103 ]
  %mul104 = fmul double %X.1179, 1.800000e+02
  %div107 = fdiv double %mul104, 0x400921FB54442D18
  %call108 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.10, i64 0, i64 0), double %X.1179, double %div107)
  %add113 = fadd double %X.1179, 0x3F91DF46A2529D39
  %cmp101 = fcmp ugt double %add113, 0x401921FB97600B9B
  br i1 %cmp101, label %for.end114, label %for.body103

for.end114:                                       ; preds = %for.body103
  %31 = bitcast %struct.int_sqrt* %q to i8*
  %32 = bitcast i32* %solutions to i8*
  %33 = bitcast [3 x double]* %x to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %31) #4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %32) #4
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %33) #4
  ret i32 0
}
*** IR Dump After Safe Stack instrumentation pass ***
; Function Attrs: nounwind uwtable
define i32 @main() #0 {
entry:
  %x = alloca [3 x double], align 16
  %solutions = alloca i32, align 4
  %q = alloca %struct.int_sqrt, align 4
  %0 = bitcast [3 x double]* %x to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %0) #4
  %1 = bitcast i32* %solutions to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #4
  %2 = bitcast %struct.int_sqrt* %q to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #4
  %puts = tail call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* getelementptr inbounds ([38 x i8], [38 x i8]* @str, i64 0, i64 0)) #4
  %arraydecay7 = bitcast [3 x double]* %x to double*
  call void @SolveCubic(double 1.000000e+00, double -1.050000e+01, double 3.200000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %arraydecay7) #4
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %3 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp194 = icmp sgt i32 %3, 0
  br i1 %cmp194, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body, %for.body.preheader
  %indvars.iv213 = phi i64 [ %indvars.iv.next214, %for.body ], [ 0, %for.body.preheader ]
  %scevgep6 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv213
  %4 = load double, double* %scevgep6, align 8, !tbaa !5
  %call2 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %4)
  %indvars.iv.next214 = add nuw nsw i64 %indvars.iv213, 1
  %5 = load i32, i32* %solutions, align 4, !tbaa !1
  %6 = sext i32 %5 to i64
  %cmp = icmp slt i64 %indvars.iv.next214, %6
  br i1 %cmp, label %for.body, label %for.end

for.end:                                          ; preds = %for.body, %entry
  %7 = bitcast [3 x double]* %x to double*
  %putchar = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -4.500000e+00, double 1.700000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %7) #4
  %call5 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %8 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp7192 = icmp sgt i32 %8, 0
  br i1 %cmp7192, label %for.body8.preheader, label %for.end14

for.body8.preheader:                              ; preds = %for.end
  br label %for.body8

for.body8:                                        ; preds = %for.body8, %for.body8.preheader
  %indvars.iv211 = phi i64 [ %indvars.iv.next212, %for.body8 ], [ 0, %for.body8.preheader ]
  %scevgep5 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv211
  %9 = load double, double* %scevgep5, align 8, !tbaa !5
  %call11 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %9)
  %indvars.iv.next212 = add nuw nsw i64 %indvars.iv211, 1
  %10 = load i32, i32* %solutions, align 4, !tbaa !1
  %11 = sext i32 %10 to i64
  %cmp7 = icmp slt i64 %indvars.iv.next212, %11
  br i1 %cmp7, label %for.body8, label %for.end14

for.end14:                                        ; preds = %for.body8, %for.end
  %12 = bitcast [3 x double]* %x to double*
  %putchar173 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -3.500000e+00, double 2.200000e+01, double -3.100000e+01, i32* nonnull %solutions, double* %12) #4
  %call17 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %13 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp19190 = icmp sgt i32 %13, 0
  br i1 %cmp19190, label %for.body20.preheader, label %for.end26

for.body20.preheader:                             ; preds = %for.end14
  br label %for.body20

for.body20:                                       ; preds = %for.body20, %for.body20.preheader
  %indvars.iv209 = phi i64 [ %indvars.iv.next210, %for.body20 ], [ 0, %for.body20.preheader ]
  %scevgep4 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv209
  %14 = load double, double* %scevgep4, align 8, !tbaa !5
  %call23 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %14)
  %indvars.iv.next210 = add nuw nsw i64 %indvars.iv209, 1
  %15 = load i32, i32* %solutions, align 4, !tbaa !1
  %16 = sext i32 %15 to i64
  %cmp19 = icmp slt i64 %indvars.iv.next210, %16
  br i1 %cmp19, label %for.body20, label %for.end26

for.end26:                                        ; preds = %for.body20, %for.end14
  %17 = bitcast [3 x double]* %x to double*
  %putchar174 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -1.370000e+01, double 1.000000e+00, double -3.500000e+01, i32* nonnull %solutions, double* %17) #4
  %call29 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %18 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp31188 = icmp sgt i32 %18, 0
  br i1 %cmp31188, label %for.body32.preheader, label %for.end38

for.body32.preheader:                             ; preds = %for.end26
  br label %for.body32

for.body32:                                       ; preds = %for.body32, %for.body32.preheader
  %indvars.iv207 = phi i64 [ %indvars.iv.next208, %for.body32 ], [ 0, %for.body32.preheader ]
  %scevgep3 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv207
  %19 = load double, double* %scevgep3, align 8, !tbaa !5
  %call35 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %19)
  %indvars.iv.next208 = add nuw nsw i64 %indvars.iv207, 1
  %20 = load i32, i32* %solutions, align 4, !tbaa !1
  %21 = sext i32 %20 to i64
  %cmp31 = icmp slt i64 %indvars.iv.next208, %21
  br i1 %cmp31, label %for.body32, label %for.end38

for.end38:                                        ; preds = %for.body32, %for.end26
  %putchar175 = call i32 @putchar(i32 10) #4
  br label %for.cond43.preheader

for.cond43.preheader:                             ; preds = %for.inc71, %for.end38
  %IV.S.1 = phi double [ 1.000000e+00, %for.end38 ], [ %IV.S.next.2, %for.inc71 ]
  %a1.0187.int = phi i32 [ 1, %for.end38 ], [ %inc72.int, %for.inc71 ]
  br label %for.cond46.preheader

for.cond46.preheader:                             ; preds = %for.inc68, %for.cond43.preheader
  %b1.0186.int = phi i32 [ 10, %for.cond43.preheader ], [ %dec69.int, %for.inc68 ]
  %indvar.conv203 = sitofp i32 %b1.0186.int to double
  br label %for.cond49.preheader

for.cond49.preheader:                             ; preds = %for.inc66, %for.cond46.preheader
  %c1.0185 = phi double [ 5.000000e+00, %for.cond46.preheader ], [ %add, %for.inc66 ]
  br label %for.body51

for.body51:                                       ; preds = %for.end62, %for.cond49.preheader
  %d1.0184.int = phi i32 [ -1, %for.cond49.preheader ], [ %dec.int, %for.end62 ]
  %22 = bitcast [3 x double]* %x to double*
  %indvar.conv201 = sitofp i32 %d1.0184.int to double
  call void @SolveCubic(double %IV.S.1, double %indvar.conv203, double %c1.0185, double %indvar.conv201, i32* nonnull %solutions, double* %22) #4
  %call53 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %23 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp55182 = icmp sgt i32 %23, 0
  br i1 %cmp55182, label %for.body56.preheader, label %for.end62

for.body56.preheader:                             ; preds = %for.body51
  br label %for.body56

for.body56:                                       ; preds = %for.body56, %for.body56.preheader
  %indvars.iv198 = phi i64 [ %indvars.iv.next199, %for.body56 ], [ 0, %for.body56.preheader ]
  %scevgep = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv198
  %24 = load double, double* %scevgep, align 8, !tbaa !5
  %call59 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %24)
  %indvars.iv.next199 = add nuw nsw i64 %indvars.iv198, 1
  %25 = load i32, i32* %solutions, align 4, !tbaa !1
  %26 = sext i32 %25 to i64
  %cmp55 = icmp slt i64 %indvars.iv.next199, %26
  br i1 %cmp55, label %for.body56, label %for.end62

for.end62:                                        ; preds = %for.body56, %for.body51
  %putchar178 = call i32 @putchar(i32 10) #4
  %dec.int = add nsw i32 %d1.0184.int, -1
  %cmp50 = icmp sgt i32 %dec.int, -11
  br i1 %cmp50, label %for.body51, label %for.inc66, !llvm.loop !7

for.inc66:                                        ; preds = %for.end62
  %add = fadd double %c1.0185, 5.000000e-01
  %cmp47 = fcmp olt double %add, 1.500000e+01
  br i1 %cmp47, label %for.cond49.preheader, label %for.inc68

for.inc68:                                        ; preds = %for.inc66
  %dec69.int = add nsw i32 %b1.0186.int, -1
  %cmp44 = icmp sgt i32 %b1.0186.int, 1
  br i1 %cmp44, label %for.cond46.preheader, label %for.inc71, !llvm.loop !7

for.inc71:                                        ; preds = %for.inc68
  %IV.S.next.2 = fadd double %IV.S.1, 1.000000e+00
  %inc72.int = add nuw nsw i32 %a1.0187.int, 1
  %exitcond206 = icmp eq i32 %inc72.int, 10
  br i1 %exitcond206, label %for.end73, label %for.cond43.preheader, !llvm.loop !7

for.end73:                                        ; preds = %for.inc71
  %puts176 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([40 x i8], [40 x i8]* @str.11, i64 0, i64 0)) #4
  br label %for.body77

for.body77:                                       ; preds = %for.body77, %for.end73
  %indvars.iv = phi i64 [ 0, %for.end73 ], [ %indvars.iv.next, %for.body77 ]
  %27 = bitcast %struct.int_sqrt* %q to i32*
  call void @usqrt(i64 %indvars.iv, %struct.int_sqrt* nonnull %q) #4
  %28 = load i32, i32* %27, align 4, !tbaa !9
  %tmp = trunc i64 %indvars.iv to i32
  %call78 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.5, i64 0, i64 0), i32 %tmp, i32 %28)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond197 = icmp eq i64 %indvars.iv.next, 1001
  br i1 %exitcond197, label %for.end81, label %for.body77, !llvm.loop !7

for.end81:                                        ; preds = %for.body77
  %29 = bitcast %struct.int_sqrt* %q to i32*
  call void @usqrt(i64 1072497001, %struct.int_sqrt* nonnull %q) #4
  %30 = load i32, i32* %29, align 4, !tbaa !9
  %call83 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.6, i64 0, i64 0), i64 1072497001, i32 %30)
  %puts177 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @str.12, i64 0, i64 0)) #4
  br label %for.body88

for.body88:                                       ; preds = %for.body88, %for.end81
  %lsr.iv = phi i32 [ %lsr.iv.next, %for.body88 ], [ 361, %for.end81 ]
  %IV.S. = phi double [ 0.000000e+00, %for.end81 ], [ %IV.S.next., %for.body88 ]
  %mul90 = fmul double %IV.S., 0x400921FB54442D18
  %div = fdiv double %mul90, 1.800000e+02
  %call91 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.8, i64 0, i64 0), double %IV.S., double %div)
  %IV.S.next. = fadd double %IV.S., 1.000000e+00
  %lsr.iv.next = add nsw i32 %lsr.iv, -1
  %exitcond = icmp eq i32 %lsr.iv.next, 0
  br i1 %exitcond, label %for.end94, label %for.body88

for.end94:                                        ; preds = %for.body88
  %call95 = call i32 (i8*, ...) bitcast (i32 (...)* @puts to i32 (i8*, ...)*)(i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.9, i64 0, i64 0)) #4
  br label %for.body103

for.body103:                                      ; preds = %for.body103, %for.end94
  %X.1179 = phi double [ 0.000000e+00, %for.end94 ], [ %add113, %for.body103 ]
  %mul104 = fmul double %X.1179, 1.800000e+02
  %div107 = fdiv double %mul104, 0x400921FB54442D18
  %call108 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.10, i64 0, i64 0), double %X.1179, double %div107)
  %add113 = fadd double %X.1179, 0x3F91DF46A2529D39
  %cmp101 = fcmp ugt double %add113, 0x401921FB97600B9B
  br i1 %cmp101, label %for.end114, label %for.body103

for.end114:                                       ; preds = %for.body103
  %31 = bitcast %struct.int_sqrt* %q to i8*
  %32 = bitcast i32* %solutions to i8*
  %33 = bitcast [3 x double]* %x to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %31) #4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %32) #4
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %33) #4
  ret i32 0
}
*** IR Dump After Module Verifier ***
; Function Attrs: nounwind uwtable
define i32 @main() #0 {
entry:
  %x = alloca [3 x double], align 16
  %solutions = alloca i32, align 4
  %q = alloca %struct.int_sqrt, align 4
  %0 = bitcast [3 x double]* %x to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %0) #4
  %1 = bitcast i32* %solutions to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #4
  %2 = bitcast %struct.int_sqrt* %q to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #4
  %puts = tail call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* getelementptr inbounds ([38 x i8], [38 x i8]* @str, i64 0, i64 0)) #4
  %arraydecay7 = bitcast [3 x double]* %x to double*
  call void @SolveCubic(double 1.000000e+00, double -1.050000e+01, double 3.200000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %arraydecay7) #4
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %3 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp194 = icmp sgt i32 %3, 0
  br i1 %cmp194, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body, %for.body.preheader
  %indvars.iv213 = phi i64 [ %indvars.iv.next214, %for.body ], [ 0, %for.body.preheader ]
  %scevgep6 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv213
  %4 = load double, double* %scevgep6, align 8, !tbaa !5
  %call2 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %4)
  %indvars.iv.next214 = add nuw nsw i64 %indvars.iv213, 1
  %5 = load i32, i32* %solutions, align 4, !tbaa !1
  %6 = sext i32 %5 to i64
  %cmp = icmp slt i64 %indvars.iv.next214, %6
  br i1 %cmp, label %for.body, label %for.end

for.end:                                          ; preds = %for.body, %entry
  %7 = bitcast [3 x double]* %x to double*
  %putchar = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -4.500000e+00, double 1.700000e+01, double -3.000000e+01, i32* nonnull %solutions, double* %7) #4
  %call5 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %8 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp7192 = icmp sgt i32 %8, 0
  br i1 %cmp7192, label %for.body8.preheader, label %for.end14

for.body8.preheader:                              ; preds = %for.end
  br label %for.body8

for.body8:                                        ; preds = %for.body8, %for.body8.preheader
  %indvars.iv211 = phi i64 [ %indvars.iv.next212, %for.body8 ], [ 0, %for.body8.preheader ]
  %scevgep5 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv211
  %9 = load double, double* %scevgep5, align 8, !tbaa !5
  %call11 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %9)
  %indvars.iv.next212 = add nuw nsw i64 %indvars.iv211, 1
  %10 = load i32, i32* %solutions, align 4, !tbaa !1
  %11 = sext i32 %10 to i64
  %cmp7 = icmp slt i64 %indvars.iv.next212, %11
  br i1 %cmp7, label %for.body8, label %for.end14

for.end14:                                        ; preds = %for.body8, %for.end
  %12 = bitcast [3 x double]* %x to double*
  %putchar173 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -3.500000e+00, double 2.200000e+01, double -3.100000e+01, i32* nonnull %solutions, double* %12) #4
  %call17 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %13 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp19190 = icmp sgt i32 %13, 0
  br i1 %cmp19190, label %for.body20.preheader, label %for.end26

for.body20.preheader:                             ; preds = %for.end14
  br label %for.body20

for.body20:                                       ; preds = %for.body20, %for.body20.preheader
  %indvars.iv209 = phi i64 [ %indvars.iv.next210, %for.body20 ], [ 0, %for.body20.preheader ]
  %scevgep4 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv209
  %14 = load double, double* %scevgep4, align 8, !tbaa !5
  %call23 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %14)
  %indvars.iv.next210 = add nuw nsw i64 %indvars.iv209, 1
  %15 = load i32, i32* %solutions, align 4, !tbaa !1
  %16 = sext i32 %15 to i64
  %cmp19 = icmp slt i64 %indvars.iv.next210, %16
  br i1 %cmp19, label %for.body20, label %for.end26

for.end26:                                        ; preds = %for.body20, %for.end14
  %17 = bitcast [3 x double]* %x to double*
  %putchar174 = call i32 @putchar(i32 10) #4
  call void @SolveCubic(double 1.000000e+00, double -1.370000e+01, double 1.000000e+00, double -3.500000e+01, i32* nonnull %solutions, double* %17) #4
  %call29 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %18 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp31188 = icmp sgt i32 %18, 0
  br i1 %cmp31188, label %for.body32.preheader, label %for.end38

for.body32.preheader:                             ; preds = %for.end26
  br label %for.body32

for.body32:                                       ; preds = %for.body32, %for.body32.preheader
  %indvars.iv207 = phi i64 [ %indvars.iv.next208, %for.body32 ], [ 0, %for.body32.preheader ]
  %scevgep3 = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv207
  %19 = load double, double* %scevgep3, align 8, !tbaa !5
  %call35 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %19)
  %indvars.iv.next208 = add nuw nsw i64 %indvars.iv207, 1
  %20 = load i32, i32* %solutions, align 4, !tbaa !1
  %21 = sext i32 %20 to i64
  %cmp31 = icmp slt i64 %indvars.iv.next208, %21
  br i1 %cmp31, label %for.body32, label %for.end38

for.end38:                                        ; preds = %for.body32, %for.end26
  %putchar175 = call i32 @putchar(i32 10) #4
  br label %for.cond43.preheader

for.cond43.preheader:                             ; preds = %for.inc71, %for.end38
  %IV.S.1 = phi double [ 1.000000e+00, %for.end38 ], [ %IV.S.next.2, %for.inc71 ]
  %a1.0187.int = phi i32 [ 1, %for.end38 ], [ %inc72.int, %for.inc71 ]
  br label %for.cond46.preheader

for.cond46.preheader:                             ; preds = %for.inc68, %for.cond43.preheader
  %b1.0186.int = phi i32 [ 10, %for.cond43.preheader ], [ %dec69.int, %for.inc68 ]
  %indvar.conv203 = sitofp i32 %b1.0186.int to double
  br label %for.cond49.preheader

for.cond49.preheader:                             ; preds = %for.inc66, %for.cond46.preheader
  %c1.0185 = phi double [ 5.000000e+00, %for.cond46.preheader ], [ %add, %for.inc66 ]
  br label %for.body51

for.body51:                                       ; preds = %for.end62, %for.cond49.preheader
  %d1.0184.int = phi i32 [ -1, %for.cond49.preheader ], [ %dec.int, %for.end62 ]
  %22 = bitcast [3 x double]* %x to double*
  %indvar.conv201 = sitofp i32 %d1.0184.int to double
  call void @SolveCubic(double %IV.S.1, double %indvar.conv203, double %c1.0185, double %indvar.conv201, i32* nonnull %solutions, double* %22) #4
  %call53 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i64 0, i64 0))
  %23 = load i32, i32* %solutions, align 4, !tbaa !1
  %cmp55182 = icmp sgt i32 %23, 0
  br i1 %cmp55182, label %for.body56.preheader, label %for.end62

for.body56.preheader:                             ; preds = %for.body51
  br label %for.body56

for.body56:                                       ; preds = %for.body56, %for.body56.preheader
  %indvars.iv198 = phi i64 [ %indvars.iv.next199, %for.body56 ], [ 0, %for.body56.preheader ]
  %scevgep = getelementptr [3 x double], [3 x double]* %x, i64 0, i64 %indvars.iv198
  %24 = load double, double* %scevgep, align 8, !tbaa !5
  %call59 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), double %24)
  %indvars.iv.next199 = add nuw nsw i64 %indvars.iv198, 1
  %25 = load i32, i32* %solutions, align 4, !tbaa !1
  %26 = sext i32 %25 to i64
  %cmp55 = icmp slt i64 %indvars.iv.next199, %26
  br i1 %cmp55, label %for.body56, label %for.end62

for.end62:                                        ; preds = %for.body56, %for.body51
  %putchar178 = call i32 @putchar(i32 10) #4
  %dec.int = add nsw i32 %d1.0184.int, -1
  %cmp50 = icmp sgt i32 %dec.int, -11
  br i1 %cmp50, label %for.body51, label %for.inc66, !llvm.loop !7

for.inc66:                                        ; preds = %for.end62
  %add = fadd double %c1.0185, 5.000000e-01
  %cmp47 = fcmp olt double %add, 1.500000e+01
  br i1 %cmp47, label %for.cond49.preheader, label %for.inc68

for.inc68:                                        ; preds = %for.inc66
  %dec69.int = add nsw i32 %b1.0186.int, -1
  %cmp44 = icmp sgt i32 %b1.0186.int, 1
  br i1 %cmp44, label %for.cond46.preheader, label %for.inc71, !llvm.loop !7

for.inc71:                                        ; preds = %for.inc68
  %IV.S.next.2 = fadd double %IV.S.1, 1.000000e+00
  %inc72.int = add nuw nsw i32 %a1.0187.int, 1
  %exitcond206 = icmp eq i32 %inc72.int, 10
  br i1 %exitcond206, label %for.end73, label %for.cond43.preheader, !llvm.loop !7

for.end73:                                        ; preds = %for.inc71
  %puts176 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([40 x i8], [40 x i8]* @str.11, i64 0, i64 0)) #4
  br label %for.body77

for.body77:                                       ; preds = %for.body77, %for.end73
  %indvars.iv = phi i64 [ 0, %for.end73 ], [ %indvars.iv.next, %for.body77 ]
  %27 = bitcast %struct.int_sqrt* %q to i32*
  call void @usqrt(i64 %indvars.iv, %struct.int_sqrt* nonnull %q) #4
  %28 = load i32, i32* %27, align 4, !tbaa !9
  %tmp = trunc i64 %indvars.iv to i32
  %call78 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.5, i64 0, i64 0), i32 %tmp, i32 %28)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond197 = icmp eq i64 %indvars.iv.next, 1001
  br i1 %exitcond197, label %for.end81, label %for.body77, !llvm.loop !7

for.end81:                                        ; preds = %for.body77
  %29 = bitcast %struct.int_sqrt* %q to i32*
  call void @usqrt(i64 1072497001, %struct.int_sqrt* nonnull %q) #4
  %30 = load i32, i32* %29, align 4, !tbaa !9
  %call83 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.6, i64 0, i64 0), i64 1072497001, i32 %30)
  %puts177 = call i32 bitcast (i32 (...)* @puts to i32 (i8*)*)(i8* nonnull getelementptr inbounds ([39 x i8], [39 x i8]* @str.12, i64 0, i64 0)) #4
  br label %for.body88

for.body88:                                       ; preds = %for.body88, %for.end81
  %lsr.iv = phi i32 [ %lsr.iv.next, %for.body88 ], [ 361, %for.end81 ]
  %IV.S. = phi double [ 0.000000e+00, %for.end81 ], [ %IV.S.next., %for.body88 ]
  %mul90 = fmul double %IV.S., 0x400921FB54442D18
  %div = fdiv double %mul90, 1.800000e+02
  %call91 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.8, i64 0, i64 0), double %IV.S., double %div)
  %IV.S.next. = fadd double %IV.S., 1.000000e+00
  %lsr.iv.next = add nsw i32 %lsr.iv, -1
  %exitcond = icmp eq i32 %lsr.iv.next, 0
  br i1 %exitcond, label %for.end94, label %for.body88

for.end94:                                        ; preds = %for.body88
  %call95 = call i32 (i8*, ...) bitcast (i32 (...)* @puts to i32 (i8*, ...)*)(i8* nonnull getelementptr inbounds ([1 x i8], [1 x i8]* @.str.9, i64 0, i64 0)) #4
  br label %for.body103

for.body103:                                      ; preds = %for.body103, %for.end94
  %X.1179 = phi double [ 0.000000e+00, %for.end94 ], [ %add113, %for.body103 ]
  %mul104 = fmul double %X.1179, 1.800000e+02
  %div107 = fdiv double %mul104, 0x400921FB54442D18
  %call108 = call i32 (i8*, ...) @printf(i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.10, i64 0, i64 0), double %X.1179, double %div107)
  %add113 = fadd double %X.1179, 0x3F91DF46A2529D39
  %cmp101 = fcmp ugt double %add113, 0x401921FB97600B9B
  br i1 %cmp101, label %for.end114, label %for.body103

for.end114:                                       ; preds = %for.body103
  %31 = bitcast %struct.int_sqrt* %q to i8*
  %32 = bitcast i32* %solutions to i8*
  %33 = bitcast [3 x double]* %x to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %31) #4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %32) #4
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %33) #4
  ret i32 0
}
# *** IR Dump After X86 DAG->DAG Instruction Selection ***:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=24, align=16, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
Constant Pool:
  cp#0: 1.000000e+00, align=8
  cp#1: -1.050000e+01, align=8
  cp#2: 3.200000e+01, align=8
  cp#3: -3.000000e+01, align=8
  cp#4: -4.500000e+00, align=8
  cp#5: 1.700000e+01, align=8
  cp#6: -3.500000e+00, align=8
  cp#7: 2.200000e+01, align=8
  cp#8: -3.100000e+01, align=8
  cp#9: -1.370000e+01, align=8
  cp#10: -3.500000e+01, align=8
  cp#11: 5.000000e+00, align=8
  cp#12: 5.000000e-01, align=8
  cp#13: 1.500000e+01, align=8
  cp#14: 0x400921FB54442D18, align=8
  cp#15: 1.800000e+02, align=8
  cp#16: 0x3F91DF46A2529D39, align=8
  cp#17: 0x401921FB97600B9B, align=8

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.3(0x30000000); %bb.1(62.50%), %bb.3(37.50%)

  LIFETIME_START %stack.0.x
  LIFETIME_START %stack.1.solutions
  LIFETIME_START %stack.2.q
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %29:gr64 = MOV32ri64 @str
  $rdi = COPY %29:gr64
  CALL64pcrel32 @puts, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %30:gr32 = COPY $eax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %31:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %32:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
  %33:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
  %34:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
  %35:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %36:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %31:fr64
  $xmm1 = COPY %32:fr64
  $xmm2 = COPY %33:fr64
  $xmm3 = COPY %34:fr64
  $rdi = COPY %35:gr64
  $rsi = COPY %36:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %37:gr64 = MOV32ri64 @.str.1
  %38:gr32 = MOV32r0 implicit-def dead $eflags
  %39:gr8 = COPY %38.sub_8bit:gr32
  $rdi = COPY %37:gr64
  $al = COPY %39:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %40:gr32 = COPY $eax
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.3, 14, implicit $eflags
  JMP_1 %bb.1

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  %42:gr32 = MOV32r0 implicit-def dead $eflags
  %41:gr64 = SUBREG_TO_REG 0, killed %42:gr32, %subreg.sub_32bit

bb.2.for.body:
; predecessors: %bb.1, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  %0:gr64_nosp = PHI %41:gr64, %bb.1, %1:gr64, %bb.2
  %43:fr64 = MOVSDrm_alt %stack.0.x, 8, %0:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep6, !tbaa !5)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %44:gr64 = MOV32ri64 @.str.2
  %45:gr8 = MOV8ri 1
  $rdi = COPY %44:gr64
  $xmm0 = COPY %43:fr64
  $al = COPY %45:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %46:gr32 = COPY $eax
  %1:gr64 = nuw nsw ADD64ri8 %0:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
  %47:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  %48:gr64 = SUB64rr %1:gr64(tied-def 0), killed %47:gr64, implicit-def $eflags
  JCC_1 %bb.2, 12, implicit $eflags
  JMP_1 %bb.3

bb.3.for.end:
; predecessors: %bb.0, %bb.2
  successors: %bb.4(0x50000000), %bb.6(0x30000000); %bb.4(62.50%), %bb.6(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %49:gr32 = MOV32ri 10
  $edi = COPY %49:gr32
  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %50:gr32 = COPY $eax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %51:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %52:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.4, $noreg :: (load 8 from constant-pool)
  %53:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.5, $noreg :: (load 8 from constant-pool)
  %54:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
  %55:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %56:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %51:fr64
  $xmm1 = COPY %52:fr64
  $xmm2 = COPY %53:fr64
  $xmm3 = COPY %54:fr64
  $rdi = COPY %55:gr64
  $rsi = COPY %56:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %57:gr64 = MOV32ri64 @.str.1
  %58:gr32 = MOV32r0 implicit-def dead $eflags
  %59:gr8 = COPY %58.sub_8bit:gr32
  $rdi = COPY %57:gr64
  $al = COPY %59:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %60:gr32 = COPY $eax
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.6, 14, implicit $eflags
  JMP_1 %bb.4

bb.4.for.body8.preheader:
; predecessors: %bb.3
  successors: %bb.5(0x80000000); %bb.5(100.00%)

  %62:gr32 = MOV32r0 implicit-def dead $eflags
  %61:gr64 = SUBREG_TO_REG 0, killed %62:gr32, %subreg.sub_32bit

bb.5.for.body8:
; predecessors: %bb.4, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  %2:gr64_nosp = PHI %61:gr64, %bb.4, %3:gr64, %bb.5
  %63:fr64 = MOVSDrm_alt %stack.0.x, 8, %2:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep5, !tbaa !5)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %64:gr64 = MOV32ri64 @.str.2
  %65:gr8 = MOV8ri 1
  $rdi = COPY %64:gr64
  $xmm0 = COPY %63:fr64
  $al = COPY %65:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %66:gr32 = COPY $eax
  %3:gr64 = nuw nsw ADD64ri8 %2:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
  %67:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  %68:gr64 = SUB64rr %3:gr64(tied-def 0), killed %67:gr64, implicit-def $eflags
  JCC_1 %bb.5, 12, implicit $eflags
  JMP_1 %bb.6

bb.6.for.end14:
; predecessors: %bb.3, %bb.5
  successors: %bb.7(0x50000000), %bb.9(0x30000000); %bb.7(62.50%), %bb.9(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %69:gr32 = MOV32ri 10
  $edi = COPY %69:gr32
  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %70:gr32 = COPY $eax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %71:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %72:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.6, $noreg :: (load 8 from constant-pool)
  %73:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.7, $noreg :: (load 8 from constant-pool)
  %74:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.8, $noreg :: (load 8 from constant-pool)
  %75:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %76:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %71:fr64
  $xmm1 = COPY %72:fr64
  $xmm2 = COPY %73:fr64
  $xmm3 = COPY %74:fr64
  $rdi = COPY %75:gr64
  $rsi = COPY %76:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %77:gr64 = MOV32ri64 @.str.1
  %78:gr32 = MOV32r0 implicit-def dead $eflags
  %79:gr8 = COPY %78.sub_8bit:gr32
  $rdi = COPY %77:gr64
  $al = COPY %79:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %80:gr32 = COPY $eax
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.9, 14, implicit $eflags
  JMP_1 %bb.7

bb.7.for.body20.preheader:
; predecessors: %bb.6
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  %82:gr32 = MOV32r0 implicit-def dead $eflags
  %81:gr64 = SUBREG_TO_REG 0, killed %82:gr32, %subreg.sub_32bit

bb.8.for.body20:
; predecessors: %bb.7, %bb.8
  successors: %bb.8(0x7c000000), %bb.9(0x04000000); %bb.8(96.88%), %bb.9(3.12%)

  %4:gr64_nosp = PHI %81:gr64, %bb.7, %5:gr64, %bb.8
  %83:fr64 = MOVSDrm_alt %stack.0.x, 8, %4:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep4, !tbaa !5)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %84:gr64 = MOV32ri64 @.str.2
  %85:gr8 = MOV8ri 1
  $rdi = COPY %84:gr64
  $xmm0 = COPY %83:fr64
  $al = COPY %85:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %86:gr32 = COPY $eax
  %5:gr64 = nuw nsw ADD64ri8 %4:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
  %87:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  %88:gr64 = SUB64rr %5:gr64(tied-def 0), killed %87:gr64, implicit-def $eflags
  JCC_1 %bb.8, 12, implicit $eflags
  JMP_1 %bb.9

bb.9.for.end26:
; predecessors: %bb.6, %bb.8
  successors: %bb.10(0x50000000), %bb.12(0x30000000); %bb.10(62.50%), %bb.12(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %89:gr32 = MOV32ri 10
  $edi = COPY %89:gr32
  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %90:gr32 = COPY $eax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %91:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.9, $noreg :: (load 8 from constant-pool)
  %92:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %93:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.10, $noreg :: (load 8 from constant-pool)
  %94:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %95:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %92:fr64
  $xmm1 = COPY %91:fr64
  $xmm2 = COPY %92:fr64
  $xmm3 = COPY %93:fr64
  $rdi = COPY %94:gr64
  $rsi = COPY %95:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %96:gr64 = MOV32ri64 @.str.1
  %97:gr32 = MOV32r0 implicit-def dead $eflags
  %98:gr8 = COPY %97.sub_8bit:gr32
  $rdi = COPY %96:gr64
  $al = COPY %98:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %99:gr32 = COPY $eax
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.12, 14, implicit $eflags
  JMP_1 %bb.10

bb.10.for.body32.preheader:
; predecessors: %bb.9
  successors: %bb.11(0x80000000); %bb.11(100.00%)

  %101:gr32 = MOV32r0 implicit-def dead $eflags
  %100:gr64 = SUBREG_TO_REG 0, killed %101:gr32, %subreg.sub_32bit

bb.11.for.body32:
; predecessors: %bb.10, %bb.11
  successors: %bb.11(0x7c000000), %bb.12(0x04000000); %bb.11(96.88%), %bb.12(3.12%)

  %6:gr64_nosp = PHI %100:gr64, %bb.10, %7:gr64, %bb.11
  %102:fr64 = MOVSDrm_alt %stack.0.x, 8, %6:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep3, !tbaa !5)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %103:gr64 = MOV32ri64 @.str.2
  %104:gr8 = MOV8ri 1
  $rdi = COPY %103:gr64
  $xmm0 = COPY %102:fr64
  $al = COPY %104:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %105:gr32 = COPY $eax
  %7:gr64 = nuw nsw ADD64ri8 %6:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
  %106:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  %107:gr64 = SUB64rr %7:gr64(tied-def 0), killed %106:gr64, implicit-def $eflags
  JCC_1 %bb.11, 12, implicit $eflags
  JMP_1 %bb.12

bb.12.for.end38:
; predecessors: %bb.9, %bb.11
  successors: %bb.13(0x80000000); %bb.13(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %110:gr32 = MOV32ri 10
  $edi = COPY %110:gr32
  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %111:gr32 = COPY $eax
  %109:gr32 = MOV32ri 1
  %108:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)

bb.13.for.cond43.preheader:
; predecessors: %bb.12, %bb.22
  successors: %bb.14(0x80000000); %bb.14(100.00%)

  %8:fr64 = PHI %108:fr64, %bb.12, %19:fr64, %bb.22
  %9:gr32 = PHI %109:gr32, %bb.12, %20:gr32, %bb.22
  %112:gr32 = MOV32ri 10

bb.14.for.cond46.preheader:
; predecessors: %bb.13, %bb.21
  successors: %bb.15(0x80000000); %bb.15(100.00%)

  %10:gr32 = PHI %112:gr32, %bb.13, %18:gr32, %bb.21
  %11:fr64 = CVTSI2SDrr %10:gr32
  %113:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.11, $noreg :: (load 8 from constant-pool)

bb.15.for.cond49.preheader:
; predecessors: %bb.14, %bb.20
  successors: %bb.16(0x80000000); %bb.16(100.00%)

  %12:fr64 = PHI %113:fr64, %bb.14, %17:fr64, %bb.20
  %114:gr32 = MOV32ri -1

bb.16.for.body51:
; predecessors: %bb.15, %bb.19
  successors: %bb.17(0x50000000), %bb.19(0x30000000); %bb.17(62.50%), %bb.19(37.50%)

  %13:gr32 = PHI %114:gr32, %bb.15, %16:gr32, %bb.19
  %115:fr64 = CVTSI2SDrr %13:gr32
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %116:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %117:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %8:fr64
  $xmm1 = COPY %11:fr64
  $xmm2 = COPY %12:fr64
  $xmm3 = COPY %115:fr64
  $rdi = COPY %116:gr64
  $rsi = COPY %117:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %118:gr64 = MOV32ri64 @.str.1
  %119:gr32 = MOV32r0 implicit-def dead $eflags
  %120:gr8 = COPY %119.sub_8bit:gr32
  $rdi = COPY %118:gr64
  $al = COPY %120:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %121:gr32 = COPY $eax
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.19, 14, implicit $eflags
  JMP_1 %bb.17

bb.17.for.body56.preheader:
; predecessors: %bb.16
  successors: %bb.18(0x80000000); %bb.18(100.00%)

  %123:gr32 = MOV32r0 implicit-def dead $eflags
  %122:gr64 = SUBREG_TO_REG 0, killed %123:gr32, %subreg.sub_32bit

bb.18.for.body56:
; predecessors: %bb.17, %bb.18
  successors: %bb.18(0x7c000000), %bb.19(0x04000000); %bb.18(96.88%), %bb.19(3.12%)

  %14:gr64_nosp = PHI %122:gr64, %bb.17, %15:gr64, %bb.18
  %124:fr64 = MOVSDrm_alt %stack.0.x, 8, %14:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep, !tbaa !5)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %125:gr64 = MOV32ri64 @.str.2
  %126:gr8 = MOV8ri 1
  $rdi = COPY %125:gr64
  $xmm0 = COPY %124:fr64
  $al = COPY %126:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %127:gr32 = COPY $eax
  %15:gr64 = nuw nsw ADD64ri8 %14:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
  %128:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  %129:gr64 = SUB64rr %15:gr64(tied-def 0), killed %128:gr64, implicit-def $eflags
  JCC_1 %bb.18, 12, implicit $eflags
  JMP_1 %bb.19

bb.19.for.end62:
; predecessors: %bb.16, %bb.18
  successors: %bb.16(0x7c000000), %bb.20(0x04000000); %bb.16(96.88%), %bb.20(3.12%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %130:gr32 = MOV32ri 10
  $edi = COPY %130:gr32
  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %131:gr32 = COPY $eax
  %16:gr32 = nsw ADD32ri8 %13:gr32(tied-def 0), -1, implicit-def dead $eflags
  %132:gr32 = SUB32ri8 %16:gr32(tied-def 0), -11, implicit-def $eflags
  JCC_1 %bb.16, 15, implicit $eflags
  JMP_1 %bb.20

bb.20.for.inc66:
; predecessors: %bb.19
  successors: %bb.15(0x7c000000), %bb.21(0x04000000); %bb.15(96.88%), %bb.21(3.12%)

  %17:fr64 = nofpexcept ADDSDrm %12:fr64(tied-def 0), $rip, 1, $noreg, %const.12, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %133:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.13, $noreg :: (load 8 from constant-pool)
  nofpexcept UCOMISDrr killed %133:fr64, %17:fr64, implicit-def $eflags, implicit $mxcsr
  JCC_1 %bb.15, 7, implicit $eflags
  JMP_1 %bb.21

bb.21.for.inc68:
; predecessors: %bb.20
  successors: %bb.14(0x7c000000), %bb.22(0x04000000); %bb.14(96.88%), %bb.22(3.12%)

  %18:gr32 = nsw ADD32ri8 %10:gr32(tied-def 0), -1, implicit-def dead $eflags
  %134:gr32 = SUB32ri8 %10:gr32(tied-def 0), 1, implicit-def $eflags
  JCC_1 %bb.14, 15, implicit $eflags
  JMP_1 %bb.22

bb.22.for.inc71:
; predecessors: %bb.21
  successors: %bb.23(0x04000000), %bb.13(0x7c000000); %bb.23(3.12%), %bb.13(96.88%)

  %19:fr64 = nofpexcept ADDSDrm %8:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %20:gr32 = nuw nsw ADD32ri8 %9:gr32(tied-def 0), 1, implicit-def dead $eflags
  %135:gr32 = SUB32ri8 %20:gr32(tied-def 0), 10, implicit-def $eflags
  JCC_1 %bb.13, 5, implicit $eflags
  JMP_1 %bb.23

bb.23.for.end73:
; predecessors: %bb.22
  successors: %bb.24(0x80000000); %bb.24(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %137:gr64 = MOV32ri64 @str.11
  $rdi = COPY %137:gr64
  CALL64pcrel32 @puts, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %138:gr32 = COPY $eax
  %139:gr32 = MOV32r0 implicit-def dead $eflags
  %136:gr64 = SUBREG_TO_REG 0, killed %139:gr32, %subreg.sub_32bit

bb.24.for.body77:
; predecessors: %bb.23, %bb.24
  successors: %bb.25(0x04000000), %bb.24(0x7c000000); %bb.25(3.12%), %bb.24(96.88%)

  %21:gr64 = PHI %136:gr64, %bb.23, %22:gr64, %bb.24
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %140:gr64 = LEA64r %stack.2.q, 1, $noreg, 0, $noreg
  $rdi = COPY %21:gr64
  $rsi = COPY %140:gr64
  CALL64pcrel32 @usqrt, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %141:gr32 = MOV32rm %stack.2.q, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.27, align 8, !tbaa !9)
  %142:gr32 = COPY %21.sub_32bit:gr64
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %143:gr64 = MOV32ri64 @.str.5
  %144:gr32 = MOV32r0 implicit-def dead $eflags
  %145:gr8 = COPY %144.sub_8bit:gr32
  $rdi = COPY %143:gr64
  $esi = COPY %142:gr32
  $edx = COPY %141:gr32
  $al = COPY %145:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit $edx, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %146:gr32 = COPY $eax
  %22:gr64 = nuw nsw ADD64ri8 %21:gr64(tied-def 0), 1, implicit-def dead $eflags
  %147:gr64 = SUB64ri32 %22:gr64(tied-def 0), 1001, implicit-def $eflags
  JCC_1 %bb.24, 5, implicit $eflags
  JMP_1 %bb.25

bb.25.for.end81:
; predecessors: %bb.24
  successors: %bb.26(0x80000000); %bb.26(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %150:gr64 = MOV32ri64 1072497001
  %151:gr64 = LEA64r %stack.2.q, 1, $noreg, 0, $noreg
  $rdi = COPY %150:gr64
  $rsi = COPY %151:gr64
  CALL64pcrel32 @usqrt, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %152:gr32 = MOV32rm %stack.2.q, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.29, align 8, !tbaa !9)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %153:gr64 = MOV32ri64 @.str.6
  %154:gr32 = MOV32r0 implicit-def dead $eflags
  %155:gr8 = COPY %154.sub_8bit:gr32
  $rdi = COPY %153:gr64
  $rsi = COPY %150:gr64
  $edx = COPY %152:gr32
  $al = COPY %155:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $edx, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %156:gr32 = COPY $eax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %157:gr64 = MOV32ri64 @str.12
  $rdi = COPY %157:gr64
  CALL64pcrel32 @puts, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %158:gr32 = COPY $eax
  %149:fr64 = FsFLD0SD
  %148:gr32 = MOV32ri 361

bb.26.for.body88:
; predecessors: %bb.25, %bb.26
  successors: %bb.27(0x04000000), %bb.26(0x7c000000); %bb.27(3.12%), %bb.26(96.88%)

  %23:gr32 = PHI %148:gr32, %bb.25, %26:gr32, %bb.26
  %24:fr64 = PHI %149:fr64, %bb.25, %25:fr64, %bb.26
  %159:fr64 = nofpexcept MULSDrm %24:fr64(tied-def 0), $rip, 1, $noreg, %const.14, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %160:fr64 = nofpexcept DIVSDrm %159:fr64(tied-def 0), $rip, 1, $noreg, %const.15, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %161:gr64 = MOV32ri64 @.str.8
  %162:gr8 = MOV8ri 2
  $rdi = COPY %161:gr64
  $xmm0 = COPY %24:fr64
  $xmm1 = COPY %160:fr64
  $al = COPY %162:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $xmm1, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %163:gr32 = COPY $eax
  %25:fr64 = nofpexcept ADDSDrm %24:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %26:gr32 = ADD32ri8 %23:gr32(tied-def 0), -1, implicit-def $eflags
  JCC_1 %bb.26, 5, implicit $eflags
  JMP_1 %bb.27

bb.27.for.end94:
; predecessors: %bb.26
  successors: %bb.28(0x80000000); %bb.28(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %165:gr64 = MOV32ri64 @.str.9
  %166:gr32 = MOV32r0 implicit-def dead $eflags
  %167:gr8 = COPY %166.sub_8bit:gr32
  $rdi = COPY %165:gr64
  $al = COPY %167:gr8
  CALL64pcrel32 @puts, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %168:gr32 = COPY $eax
  %164:fr64 = FsFLD0SD

bb.28.for.body103:
; predecessors: %bb.27, %bb.28
  successors: %bb.29(0x04000000), %bb.28(0x7c000000); %bb.29(3.12%), %bb.28(96.88%)

  %27:fr64 = PHI %164:fr64, %bb.27, %28:fr64, %bb.28
  %169:fr64 = nofpexcept MULSDrm %27:fr64(tied-def 0), $rip, 1, $noreg, %const.15, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %170:fr64 = nofpexcept DIVSDrm %169:fr64(tied-def 0), $rip, 1, $noreg, %const.14, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %171:gr64 = MOV32ri64 @.str.10
  %172:gr8 = MOV8ri 2
  $rdi = COPY %171:gr64
  $xmm0 = COPY %27:fr64
  $xmm1 = COPY %170:fr64
  $al = COPY %172:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $xmm1, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %173:gr32 = COPY $eax
  %28:fr64 = nofpexcept ADDSDrm %27:fr64(tied-def 0), $rip, 1, $noreg, %const.16, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %174:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.17, $noreg :: (load 8 from constant-pool)
  nofpexcept UCOMISDrr killed %174:fr64, %28:fr64, implicit-def $eflags, implicit $mxcsr
  JCC_1 %bb.28, 3, implicit $eflags
  JMP_1 %bb.29

bb.29.for.end114:
; predecessors: %bb.28

  LIFETIME_END %stack.2.q
  LIFETIME_END %stack.1.solutions
  LIFETIME_END %stack.0.x
  %175:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY %175:gr32
  RET 0, $eax

# End machine code for function main.

# *** IR Dump After Finalize ISel and expand pseudo-instructions ***:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=24, align=16, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
Constant Pool:
  cp#0: 1.000000e+00, align=8
  cp#1: -1.050000e+01, align=8
  cp#2: 3.200000e+01, align=8
  cp#3: -3.000000e+01, align=8
  cp#4: -4.500000e+00, align=8
  cp#5: 1.700000e+01, align=8
  cp#6: -3.500000e+00, align=8
  cp#7: 2.200000e+01, align=8
  cp#8: -3.100000e+01, align=8
  cp#9: -1.370000e+01, align=8
  cp#10: -3.500000e+01, align=8
  cp#11: 5.000000e+00, align=8
  cp#12: 5.000000e-01, align=8
  cp#13: 1.500000e+01, align=8
  cp#14: 0x400921FB54442D18, align=8
  cp#15: 1.800000e+02, align=8
  cp#16: 0x3F91DF46A2529D39, align=8
  cp#17: 0x401921FB97600B9B, align=8

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.3(0x30000000); %bb.1(62.50%), %bb.3(37.50%)

  LIFETIME_START %stack.0.x
  LIFETIME_START %stack.1.solutions
  LIFETIME_START %stack.2.q
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %29:gr64 = MOV32ri64 @str
  $rdi = COPY %29:gr64
  CALL64pcrel32 @puts, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %30:gr32 = COPY $eax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %31:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %32:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
  %33:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
  %34:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
  %35:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %36:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %31:fr64
  $xmm1 = COPY %32:fr64
  $xmm2 = COPY %33:fr64
  $xmm3 = COPY %34:fr64
  $rdi = COPY %35:gr64
  $rsi = COPY %36:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %37:gr64 = MOV32ri64 @.str.1
  %38:gr32 = MOV32r0 implicit-def dead $eflags
  %39:gr8 = COPY %38.sub_8bit:gr32
  $rdi = COPY %37:gr64
  $al = COPY %39:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %40:gr32 = COPY $eax
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.3, 14, implicit $eflags
  JMP_1 %bb.1

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  %42:gr32 = MOV32r0 implicit-def dead $eflags
  %41:gr64 = SUBREG_TO_REG 0, killed %42:gr32, %subreg.sub_32bit

bb.2.for.body:
; predecessors: %bb.1, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  %0:gr64_nosp = PHI %41:gr64, %bb.1, %1:gr64, %bb.2
  %43:fr64 = MOVSDrm_alt %stack.0.x, 8, %0:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep6, !tbaa !5)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %44:gr64 = MOV32ri64 @.str.2
  %45:gr8 = MOV8ri 1
  $rdi = COPY %44:gr64
  $xmm0 = COPY %43:fr64
  $al = COPY %45:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %46:gr32 = COPY $eax
  %1:gr64 = nuw nsw ADD64ri8 %0:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
  %47:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  %48:gr64 = SUB64rr %1:gr64(tied-def 0), killed %47:gr64, implicit-def $eflags
  JCC_1 %bb.2, 12, implicit $eflags
  JMP_1 %bb.3

bb.3.for.end:
; predecessors: %bb.0, %bb.2
  successors: %bb.4(0x50000000), %bb.6(0x30000000); %bb.4(62.50%), %bb.6(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %49:gr32 = MOV32ri 10
  $edi = COPY %49:gr32
  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %50:gr32 = COPY $eax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %51:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %52:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.4, $noreg :: (load 8 from constant-pool)
  %53:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.5, $noreg :: (load 8 from constant-pool)
  %54:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
  %55:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %56:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %51:fr64
  $xmm1 = COPY %52:fr64
  $xmm2 = COPY %53:fr64
  $xmm3 = COPY %54:fr64
  $rdi = COPY %55:gr64
  $rsi = COPY %56:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %57:gr64 = MOV32ri64 @.str.1
  %58:gr32 = MOV32r0 implicit-def dead $eflags
  %59:gr8 = COPY %58.sub_8bit:gr32
  $rdi = COPY %57:gr64
  $al = COPY %59:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %60:gr32 = COPY $eax
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.6, 14, implicit $eflags
  JMP_1 %bb.4

bb.4.for.body8.preheader:
; predecessors: %bb.3
  successors: %bb.5(0x80000000); %bb.5(100.00%)

  %62:gr32 = MOV32r0 implicit-def dead $eflags
  %61:gr64 = SUBREG_TO_REG 0, killed %62:gr32, %subreg.sub_32bit

bb.5.for.body8:
; predecessors: %bb.4, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  %2:gr64_nosp = PHI %61:gr64, %bb.4, %3:gr64, %bb.5
  %63:fr64 = MOVSDrm_alt %stack.0.x, 8, %2:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep5, !tbaa !5)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %64:gr64 = MOV32ri64 @.str.2
  %65:gr8 = MOV8ri 1
  $rdi = COPY %64:gr64
  $xmm0 = COPY %63:fr64
  $al = COPY %65:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %66:gr32 = COPY $eax
  %3:gr64 = nuw nsw ADD64ri8 %2:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
  %67:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  %68:gr64 = SUB64rr %3:gr64(tied-def 0), killed %67:gr64, implicit-def $eflags
  JCC_1 %bb.5, 12, implicit $eflags
  JMP_1 %bb.6

bb.6.for.end14:
; predecessors: %bb.3, %bb.5
  successors: %bb.7(0x50000000), %bb.9(0x30000000); %bb.7(62.50%), %bb.9(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %69:gr32 = MOV32ri 10
  $edi = COPY %69:gr32
  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %70:gr32 = COPY $eax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %71:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %72:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.6, $noreg :: (load 8 from constant-pool)
  %73:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.7, $noreg :: (load 8 from constant-pool)
  %74:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.8, $noreg :: (load 8 from constant-pool)
  %75:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %76:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %71:fr64
  $xmm1 = COPY %72:fr64
  $xmm2 = COPY %73:fr64
  $xmm3 = COPY %74:fr64
  $rdi = COPY %75:gr64
  $rsi = COPY %76:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %77:gr64 = MOV32ri64 @.str.1
  %78:gr32 = MOV32r0 implicit-def dead $eflags
  %79:gr8 = COPY %78.sub_8bit:gr32
  $rdi = COPY %77:gr64
  $al = COPY %79:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %80:gr32 = COPY $eax
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.9, 14, implicit $eflags
  JMP_1 %bb.7

bb.7.for.body20.preheader:
; predecessors: %bb.6
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  %82:gr32 = MOV32r0 implicit-def dead $eflags
  %81:gr64 = SUBREG_TO_REG 0, killed %82:gr32, %subreg.sub_32bit

bb.8.for.body20:
; predecessors: %bb.7, %bb.8
  successors: %bb.8(0x7c000000), %bb.9(0x04000000); %bb.8(96.88%), %bb.9(3.12%)

  %4:gr64_nosp = PHI %81:gr64, %bb.7, %5:gr64, %bb.8
  %83:fr64 = MOVSDrm_alt %stack.0.x, 8, %4:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep4, !tbaa !5)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %84:gr64 = MOV32ri64 @.str.2
  %85:gr8 = MOV8ri 1
  $rdi = COPY %84:gr64
  $xmm0 = COPY %83:fr64
  $al = COPY %85:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %86:gr32 = COPY $eax
  %5:gr64 = nuw nsw ADD64ri8 %4:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
  %87:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  %88:gr64 = SUB64rr %5:gr64(tied-def 0), killed %87:gr64, implicit-def $eflags
  JCC_1 %bb.8, 12, implicit $eflags
  JMP_1 %bb.9

bb.9.for.end26:
; predecessors: %bb.6, %bb.8
  successors: %bb.10(0x50000000), %bb.12(0x30000000); %bb.10(62.50%), %bb.12(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %89:gr32 = MOV32ri 10
  $edi = COPY %89:gr32
  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %90:gr32 = COPY $eax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %91:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.9, $noreg :: (load 8 from constant-pool)
  %92:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %93:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.10, $noreg :: (load 8 from constant-pool)
  %94:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %95:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %92:fr64
  $xmm1 = COPY %91:fr64
  $xmm2 = COPY %92:fr64
  $xmm3 = COPY %93:fr64
  $rdi = COPY %94:gr64
  $rsi = COPY %95:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %96:gr64 = MOV32ri64 @.str.1
  %97:gr32 = MOV32r0 implicit-def dead $eflags
  %98:gr8 = COPY %97.sub_8bit:gr32
  $rdi = COPY %96:gr64
  $al = COPY %98:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %99:gr32 = COPY $eax
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.12, 14, implicit $eflags
  JMP_1 %bb.10

bb.10.for.body32.preheader:
; predecessors: %bb.9
  successors: %bb.11(0x80000000); %bb.11(100.00%)

  %101:gr32 = MOV32r0 implicit-def dead $eflags
  %100:gr64 = SUBREG_TO_REG 0, killed %101:gr32, %subreg.sub_32bit

bb.11.for.body32:
; predecessors: %bb.10, %bb.11
  successors: %bb.11(0x7c000000), %bb.12(0x04000000); %bb.11(96.88%), %bb.12(3.12%)

  %6:gr64_nosp = PHI %100:gr64, %bb.10, %7:gr64, %bb.11
  %102:fr64 = MOVSDrm_alt %stack.0.x, 8, %6:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep3, !tbaa !5)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %103:gr64 = MOV32ri64 @.str.2
  %104:gr8 = MOV8ri 1
  $rdi = COPY %103:gr64
  $xmm0 = COPY %102:fr64
  $al = COPY %104:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %105:gr32 = COPY $eax
  %7:gr64 = nuw nsw ADD64ri8 %6:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
  %106:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  %107:gr64 = SUB64rr %7:gr64(tied-def 0), killed %106:gr64, implicit-def $eflags
  JCC_1 %bb.11, 12, implicit $eflags
  JMP_1 %bb.12

bb.12.for.end38:
; predecessors: %bb.9, %bb.11
  successors: %bb.13(0x80000000); %bb.13(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %110:gr32 = MOV32ri 10
  $edi = COPY %110:gr32
  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %111:gr32 = COPY $eax
  %109:gr32 = MOV32ri 1
  %108:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)

bb.13.for.cond43.preheader:
; predecessors: %bb.12, %bb.22
  successors: %bb.14(0x80000000); %bb.14(100.00%)

  %8:fr64 = PHI %108:fr64, %bb.12, %19:fr64, %bb.22
  %9:gr32 = PHI %109:gr32, %bb.12, %20:gr32, %bb.22
  %112:gr32 = MOV32ri 10

bb.14.for.cond46.preheader:
; predecessors: %bb.13, %bb.21
  successors: %bb.15(0x80000000); %bb.15(100.00%)

  %10:gr32 = PHI %112:gr32, %bb.13, %18:gr32, %bb.21
  %11:fr64 = CVTSI2SDrr %10:gr32
  %113:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.11, $noreg :: (load 8 from constant-pool)

bb.15.for.cond49.preheader:
; predecessors: %bb.14, %bb.20
  successors: %bb.16(0x80000000); %bb.16(100.00%)

  %12:fr64 = PHI %113:fr64, %bb.14, %17:fr64, %bb.20
  %114:gr32 = MOV32ri -1

bb.16.for.body51:
; predecessors: %bb.15, %bb.19
  successors: %bb.17(0x50000000), %bb.19(0x30000000); %bb.17(62.50%), %bb.19(37.50%)

  %13:gr32 = PHI %114:gr32, %bb.15, %16:gr32, %bb.19
  %115:fr64 = CVTSI2SDrr %13:gr32
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %116:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %117:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %8:fr64
  $xmm1 = COPY %11:fr64
  $xmm2 = COPY %12:fr64
  $xmm3 = COPY %115:fr64
  $rdi = COPY %116:gr64
  $rsi = COPY %117:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %118:gr64 = MOV32ri64 @.str.1
  %119:gr32 = MOV32r0 implicit-def dead $eflags
  %120:gr8 = COPY %119.sub_8bit:gr32
  $rdi = COPY %118:gr64
  $al = COPY %120:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %121:gr32 = COPY $eax
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.19, 14, implicit $eflags
  JMP_1 %bb.17

bb.17.for.body56.preheader:
; predecessors: %bb.16
  successors: %bb.18(0x80000000); %bb.18(100.00%)

  %123:gr32 = MOV32r0 implicit-def dead $eflags
  %122:gr64 = SUBREG_TO_REG 0, killed %123:gr32, %subreg.sub_32bit

bb.18.for.body56:
; predecessors: %bb.17, %bb.18
  successors: %bb.18(0x7c000000), %bb.19(0x04000000); %bb.18(96.88%), %bb.19(3.12%)

  %14:gr64_nosp = PHI %122:gr64, %bb.17, %15:gr64, %bb.18
  %124:fr64 = MOVSDrm_alt %stack.0.x, 8, %14:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep, !tbaa !5)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %125:gr64 = MOV32ri64 @.str.2
  %126:gr8 = MOV8ri 1
  $rdi = COPY %125:gr64
  $xmm0 = COPY %124:fr64
  $al = COPY %126:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %127:gr32 = COPY $eax
  %15:gr64 = nuw nsw ADD64ri8 %14:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
  %128:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  %129:gr64 = SUB64rr %15:gr64(tied-def 0), killed %128:gr64, implicit-def $eflags
  JCC_1 %bb.18, 12, implicit $eflags
  JMP_1 %bb.19

bb.19.for.end62:
; predecessors: %bb.16, %bb.18
  successors: %bb.16(0x7c000000), %bb.20(0x04000000); %bb.16(96.88%), %bb.20(3.12%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %130:gr32 = MOV32ri 10
  $edi = COPY %130:gr32
  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %131:gr32 = COPY $eax
  %16:gr32 = nsw ADD32ri8 %13:gr32(tied-def 0), -1, implicit-def dead $eflags
  %132:gr32 = SUB32ri8 %16:gr32(tied-def 0), -11, implicit-def $eflags
  JCC_1 %bb.16, 15, implicit $eflags
  JMP_1 %bb.20

bb.20.for.inc66:
; predecessors: %bb.19
  successors: %bb.15(0x7c000000), %bb.21(0x04000000); %bb.15(96.88%), %bb.21(3.12%)

  %17:fr64 = nofpexcept ADDSDrm %12:fr64(tied-def 0), $rip, 1, $noreg, %const.12, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %133:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.13, $noreg :: (load 8 from constant-pool)
  nofpexcept UCOMISDrr killed %133:fr64, %17:fr64, implicit-def $eflags, implicit $mxcsr
  JCC_1 %bb.15, 7, implicit $eflags
  JMP_1 %bb.21

bb.21.for.inc68:
; predecessors: %bb.20
  successors: %bb.14(0x7c000000), %bb.22(0x04000000); %bb.14(96.88%), %bb.22(3.12%)

  %18:gr32 = nsw ADD32ri8 %10:gr32(tied-def 0), -1, implicit-def dead $eflags
  %134:gr32 = SUB32ri8 %10:gr32(tied-def 0), 1, implicit-def $eflags
  JCC_1 %bb.14, 15, implicit $eflags
  JMP_1 %bb.22

bb.22.for.inc71:
; predecessors: %bb.21
  successors: %bb.23(0x04000000), %bb.13(0x7c000000); %bb.23(3.12%), %bb.13(96.88%)

  %19:fr64 = nofpexcept ADDSDrm %8:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %20:gr32 = nuw nsw ADD32ri8 %9:gr32(tied-def 0), 1, implicit-def dead $eflags
  %135:gr32 = SUB32ri8 %20:gr32(tied-def 0), 10, implicit-def $eflags
  JCC_1 %bb.13, 5, implicit $eflags
  JMP_1 %bb.23

bb.23.for.end73:
; predecessors: %bb.22
  successors: %bb.24(0x80000000); %bb.24(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %137:gr64 = MOV32ri64 @str.11
  $rdi = COPY %137:gr64
  CALL64pcrel32 @puts, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %138:gr32 = COPY $eax
  %139:gr32 = MOV32r0 implicit-def dead $eflags
  %136:gr64 = SUBREG_TO_REG 0, killed %139:gr32, %subreg.sub_32bit

bb.24.for.body77:
; predecessors: %bb.23, %bb.24
  successors: %bb.25(0x04000000), %bb.24(0x7c000000); %bb.25(3.12%), %bb.24(96.88%)

  %21:gr64 = PHI %136:gr64, %bb.23, %22:gr64, %bb.24
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %140:gr64 = LEA64r %stack.2.q, 1, $noreg, 0, $noreg
  $rdi = COPY %21:gr64
  $rsi = COPY %140:gr64
  CALL64pcrel32 @usqrt, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %141:gr32 = MOV32rm %stack.2.q, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.27, align 8, !tbaa !9)
  %142:gr32 = COPY %21.sub_32bit:gr64
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %143:gr64 = MOV32ri64 @.str.5
  %144:gr32 = MOV32r0 implicit-def dead $eflags
  %145:gr8 = COPY %144.sub_8bit:gr32
  $rdi = COPY %143:gr64
  $esi = COPY %142:gr32
  $edx = COPY %141:gr32
  $al = COPY %145:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit $edx, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %146:gr32 = COPY $eax
  %22:gr64 = nuw nsw ADD64ri8 %21:gr64(tied-def 0), 1, implicit-def dead $eflags
  %147:gr64 = SUB64ri32 %22:gr64(tied-def 0), 1001, implicit-def $eflags
  JCC_1 %bb.24, 5, implicit $eflags
  JMP_1 %bb.25

bb.25.for.end81:
; predecessors: %bb.24
  successors: %bb.26(0x80000000); %bb.26(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %150:gr64 = MOV32ri64 1072497001
  %151:gr64 = LEA64r %stack.2.q, 1, $noreg, 0, $noreg
  $rdi = COPY %150:gr64
  $rsi = COPY %151:gr64
  CALL64pcrel32 @usqrt, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %152:gr32 = MOV32rm %stack.2.q, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.29, align 8, !tbaa !9)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %153:gr64 = MOV32ri64 @.str.6
  %154:gr32 = MOV32r0 implicit-def dead $eflags
  %155:gr8 = COPY %154.sub_8bit:gr32
  $rdi = COPY %153:gr64
  $rsi = COPY %150:gr64
  $edx = COPY %152:gr32
  $al = COPY %155:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $edx, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %156:gr32 = COPY $eax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %157:gr64 = MOV32ri64 @str.12
  $rdi = COPY %157:gr64
  CALL64pcrel32 @puts, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %158:gr32 = COPY $eax
  %149:fr64 = FsFLD0SD
  %148:gr32 = MOV32ri 361

bb.26.for.body88:
; predecessors: %bb.25, %bb.26
  successors: %bb.27(0x04000000), %bb.26(0x7c000000); %bb.27(3.12%), %bb.26(96.88%)

  %23:gr32 = PHI %148:gr32, %bb.25, %26:gr32, %bb.26
  %24:fr64 = PHI %149:fr64, %bb.25, %25:fr64, %bb.26
  %159:fr64 = nofpexcept MULSDrm %24:fr64(tied-def 0), $rip, 1, $noreg, %const.14, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %160:fr64 = nofpexcept DIVSDrm %159:fr64(tied-def 0), $rip, 1, $noreg, %const.15, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %161:gr64 = MOV32ri64 @.str.8
  %162:gr8 = MOV8ri 2
  $rdi = COPY %161:gr64
  $xmm0 = COPY %24:fr64
  $xmm1 = COPY %160:fr64
  $al = COPY %162:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $xmm1, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %163:gr32 = COPY $eax
  %25:fr64 = nofpexcept ADDSDrm %24:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %26:gr32 = ADD32ri8 %23:gr32(tied-def 0), -1, implicit-def $eflags
  JCC_1 %bb.26, 5, implicit $eflags
  JMP_1 %bb.27

bb.27.for.end94:
; predecessors: %bb.26
  successors: %bb.28(0x80000000); %bb.28(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %165:gr64 = MOV32ri64 @.str.9
  %166:gr32 = MOV32r0 implicit-def dead $eflags
  %167:gr8 = COPY %166.sub_8bit:gr32
  $rdi = COPY %165:gr64
  $al = COPY %167:gr8
  CALL64pcrel32 @puts, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %168:gr32 = COPY $eax
  %164:fr64 = FsFLD0SD

bb.28.for.body103:
; predecessors: %bb.27, %bb.28
  successors: %bb.29(0x04000000), %bb.28(0x7c000000); %bb.29(3.12%), %bb.28(96.88%)

  %27:fr64 = PHI %164:fr64, %bb.27, %28:fr64, %bb.28
  %169:fr64 = nofpexcept MULSDrm %27:fr64(tied-def 0), $rip, 1, $noreg, %const.15, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %170:fr64 = nofpexcept DIVSDrm %169:fr64(tied-def 0), $rip, 1, $noreg, %const.14, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %171:gr64 = MOV32ri64 @.str.10
  %172:gr8 = MOV8ri 2
  $rdi = COPY %171:gr64
  $xmm0 = COPY %27:fr64
  $xmm1 = COPY %170:fr64
  $al = COPY %172:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $xmm1, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %173:gr32 = COPY $eax
  %28:fr64 = nofpexcept ADDSDrm %27:fr64(tied-def 0), $rip, 1, $noreg, %const.16, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %174:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.17, $noreg :: (load 8 from constant-pool)
  nofpexcept UCOMISDrr killed %174:fr64, %28:fr64, implicit-def $eflags, implicit $mxcsr
  JCC_1 %bb.28, 3, implicit $eflags
  JMP_1 %bb.29

bb.29.for.end114:
; predecessors: %bb.28

  LIFETIME_END %stack.2.q
  LIFETIME_END %stack.1.solutions
  LIFETIME_END %stack.0.x
  %175:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY %175:gr32
  RET 0, $eax

# End machine code for function main.

# *** IR Dump After X86 Domain Reassignment Pass ***:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=24, align=16, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
Constant Pool:
  cp#0: 1.000000e+00, align=8
  cp#1: -1.050000e+01, align=8
  cp#2: 3.200000e+01, align=8
  cp#3: -3.000000e+01, align=8
  cp#4: -4.500000e+00, align=8
  cp#5: 1.700000e+01, align=8
  cp#6: -3.500000e+00, align=8
  cp#7: 2.200000e+01, align=8
  cp#8: -3.100000e+01, align=8
  cp#9: -1.370000e+01, align=8
  cp#10: -3.500000e+01, align=8
  cp#11: 5.000000e+00, align=8
  cp#12: 5.000000e-01, align=8
  cp#13: 1.500000e+01, align=8
  cp#14: 0x400921FB54442D18, align=8
  cp#15: 1.800000e+02, align=8
  cp#16: 0x3F91DF46A2529D39, align=8
  cp#17: 0x401921FB97600B9B, align=8

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.3(0x30000000); %bb.1(62.50%), %bb.3(37.50%)

  LIFETIME_START %stack.0.x
  LIFETIME_START %stack.1.solutions
  LIFETIME_START %stack.2.q
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %29:gr64 = MOV32ri64 @str
  $rdi = COPY %29:gr64
  CALL64pcrel32 @puts, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %30:gr32 = COPY $eax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %31:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %32:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
  %33:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
  %34:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
  %35:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %36:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %31:fr64
  $xmm1 = COPY %32:fr64
  $xmm2 = COPY %33:fr64
  $xmm3 = COPY %34:fr64
  $rdi = COPY %35:gr64
  $rsi = COPY %36:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %37:gr64 = MOV32ri64 @.str.1
  %38:gr32 = MOV32r0 implicit-def dead $eflags
  %39:gr8 = COPY %38.sub_8bit:gr32
  $rdi = COPY %37:gr64
  $al = COPY %39:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %40:gr32 = COPY $eax
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.3, 14, implicit $eflags
  JMP_1 %bb.1

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  %42:gr32 = MOV32r0 implicit-def dead $eflags
  %41:gr64 = SUBREG_TO_REG 0, killed %42:gr32, %subreg.sub_32bit

bb.2.for.body:
; predecessors: %bb.1, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  %0:gr64_nosp = PHI %41:gr64, %bb.1, %1:gr64, %bb.2
  %43:fr64 = MOVSDrm_alt %stack.0.x, 8, %0:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep6, !tbaa !5)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %44:gr64 = MOV32ri64 @.str.2
  %45:gr8 = MOV8ri 1
  $rdi = COPY %44:gr64
  $xmm0 = COPY %43:fr64
  $al = COPY %45:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %46:gr32 = COPY $eax
  %1:gr64 = nuw nsw ADD64ri8 %0:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
  %47:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  %48:gr64 = SUB64rr %1:gr64(tied-def 0), killed %47:gr64, implicit-def $eflags
  JCC_1 %bb.2, 12, implicit $eflags
  JMP_1 %bb.3

bb.3.for.end:
; predecessors: %bb.0, %bb.2
  successors: %bb.4(0x50000000), %bb.6(0x30000000); %bb.4(62.50%), %bb.6(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %49:gr32 = MOV32ri 10
  $edi = COPY %49:gr32
  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %50:gr32 = COPY $eax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %51:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %52:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.4, $noreg :: (load 8 from constant-pool)
  %53:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.5, $noreg :: (load 8 from constant-pool)
  %54:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
  %55:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %56:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %51:fr64
  $xmm1 = COPY %52:fr64
  $xmm2 = COPY %53:fr64
  $xmm3 = COPY %54:fr64
  $rdi = COPY %55:gr64
  $rsi = COPY %56:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %57:gr64 = MOV32ri64 @.str.1
  %58:gr32 = MOV32r0 implicit-def dead $eflags
  %59:gr8 = COPY %58.sub_8bit:gr32
  $rdi = COPY %57:gr64
  $al = COPY %59:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %60:gr32 = COPY $eax
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.6, 14, implicit $eflags
  JMP_1 %bb.4

bb.4.for.body8.preheader:
; predecessors: %bb.3
  successors: %bb.5(0x80000000); %bb.5(100.00%)

  %62:gr32 = MOV32r0 implicit-def dead $eflags
  %61:gr64 = SUBREG_TO_REG 0, killed %62:gr32, %subreg.sub_32bit

bb.5.for.body8:
; predecessors: %bb.4, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  %2:gr64_nosp = PHI %61:gr64, %bb.4, %3:gr64, %bb.5
  %63:fr64 = MOVSDrm_alt %stack.0.x, 8, %2:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep5, !tbaa !5)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %64:gr64 = MOV32ri64 @.str.2
  %65:gr8 = MOV8ri 1
  $rdi = COPY %64:gr64
  $xmm0 = COPY %63:fr64
  $al = COPY %65:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %66:gr32 = COPY $eax
  %3:gr64 = nuw nsw ADD64ri8 %2:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
  %67:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  %68:gr64 = SUB64rr %3:gr64(tied-def 0), killed %67:gr64, implicit-def $eflags
  JCC_1 %bb.5, 12, implicit $eflags
  JMP_1 %bb.6

bb.6.for.end14:
; predecessors: %bb.3, %bb.5
  successors: %bb.7(0x50000000), %bb.9(0x30000000); %bb.7(62.50%), %bb.9(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %69:gr32 = MOV32ri 10
  $edi = COPY %69:gr32
  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %70:gr32 = COPY $eax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %71:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %72:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.6, $noreg :: (load 8 from constant-pool)
  %73:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.7, $noreg :: (load 8 from constant-pool)
  %74:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.8, $noreg :: (load 8 from constant-pool)
  %75:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %76:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %71:fr64
  $xmm1 = COPY %72:fr64
  $xmm2 = COPY %73:fr64
  $xmm3 = COPY %74:fr64
  $rdi = COPY %75:gr64
  $rsi = COPY %76:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %77:gr64 = MOV32ri64 @.str.1
  %78:gr32 = MOV32r0 implicit-def dead $eflags
  %79:gr8 = COPY %78.sub_8bit:gr32
  $rdi = COPY %77:gr64
  $al = COPY %79:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %80:gr32 = COPY $eax
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.9, 14, implicit $eflags
  JMP_1 %bb.7

bb.7.for.body20.preheader:
; predecessors: %bb.6
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  %82:gr32 = MOV32r0 implicit-def dead $eflags
  %81:gr64 = SUBREG_TO_REG 0, killed %82:gr32, %subreg.sub_32bit

bb.8.for.body20:
; predecessors: %bb.7, %bb.8
  successors: %bb.8(0x7c000000), %bb.9(0x04000000); %bb.8(96.88%), %bb.9(3.12%)

  %4:gr64_nosp = PHI %81:gr64, %bb.7, %5:gr64, %bb.8
  %83:fr64 = MOVSDrm_alt %stack.0.x, 8, %4:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep4, !tbaa !5)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %84:gr64 = MOV32ri64 @.str.2
  %85:gr8 = MOV8ri 1
  $rdi = COPY %84:gr64
  $xmm0 = COPY %83:fr64
  $al = COPY %85:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %86:gr32 = COPY $eax
  %5:gr64 = nuw nsw ADD64ri8 %4:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
  %87:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  %88:gr64 = SUB64rr %5:gr64(tied-def 0), killed %87:gr64, implicit-def $eflags
  JCC_1 %bb.8, 12, implicit $eflags
  JMP_1 %bb.9

bb.9.for.end26:
; predecessors: %bb.6, %bb.8
  successors: %bb.10(0x50000000), %bb.12(0x30000000); %bb.10(62.50%), %bb.12(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %89:gr32 = MOV32ri 10
  $edi = COPY %89:gr32
  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %90:gr32 = COPY $eax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %91:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.9, $noreg :: (load 8 from constant-pool)
  %92:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %93:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.10, $noreg :: (load 8 from constant-pool)
  %94:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %95:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %92:fr64
  $xmm1 = COPY %91:fr64
  $xmm2 = COPY %92:fr64
  $xmm3 = COPY %93:fr64
  $rdi = COPY %94:gr64
  $rsi = COPY %95:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %96:gr64 = MOV32ri64 @.str.1
  %97:gr32 = MOV32r0 implicit-def dead $eflags
  %98:gr8 = COPY %97.sub_8bit:gr32
  $rdi = COPY %96:gr64
  $al = COPY %98:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %99:gr32 = COPY $eax
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.12, 14, implicit $eflags
  JMP_1 %bb.10

bb.10.for.body32.preheader:
; predecessors: %bb.9
  successors: %bb.11(0x80000000); %bb.11(100.00%)

  %101:gr32 = MOV32r0 implicit-def dead $eflags
  %100:gr64 = SUBREG_TO_REG 0, killed %101:gr32, %subreg.sub_32bit

bb.11.for.body32:
; predecessors: %bb.10, %bb.11
  successors: %bb.11(0x7c000000), %bb.12(0x04000000); %bb.11(96.88%), %bb.12(3.12%)

  %6:gr64_nosp = PHI %100:gr64, %bb.10, %7:gr64, %bb.11
  %102:fr64 = MOVSDrm_alt %stack.0.x, 8, %6:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep3, !tbaa !5)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %103:gr64 = MOV32ri64 @.str.2
  %104:gr8 = MOV8ri 1
  $rdi = COPY %103:gr64
  $xmm0 = COPY %102:fr64
  $al = COPY %104:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %105:gr32 = COPY $eax
  %7:gr64 = nuw nsw ADD64ri8 %6:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
  %106:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  %107:gr64 = SUB64rr %7:gr64(tied-def 0), killed %106:gr64, implicit-def $eflags
  JCC_1 %bb.11, 12, implicit $eflags
  JMP_1 %bb.12

bb.12.for.end38:
; predecessors: %bb.9, %bb.11
  successors: %bb.13(0x80000000); %bb.13(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %110:gr32 = MOV32ri 10
  $edi = COPY %110:gr32
  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %111:gr32 = COPY $eax
  %109:gr32 = MOV32ri 1
  %108:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)

bb.13.for.cond43.preheader:
; predecessors: %bb.12, %bb.22
  successors: %bb.14(0x80000000); %bb.14(100.00%)

  %8:fr64 = PHI %108:fr64, %bb.12, %19:fr64, %bb.22
  %9:gr32 = PHI %109:gr32, %bb.12, %20:gr32, %bb.22
  %112:gr32 = MOV32ri 10

bb.14.for.cond46.preheader:
; predecessors: %bb.13, %bb.21
  successors: %bb.15(0x80000000); %bb.15(100.00%)

  %10:gr32 = PHI %112:gr32, %bb.13, %18:gr32, %bb.21
  %11:fr64 = CVTSI2SDrr %10:gr32
  %113:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.11, $noreg :: (load 8 from constant-pool)

bb.15.for.cond49.preheader:
; predecessors: %bb.14, %bb.20
  successors: %bb.16(0x80000000); %bb.16(100.00%)

  %12:fr64 = PHI %113:fr64, %bb.14, %17:fr64, %bb.20
  %114:gr32 = MOV32ri -1

bb.16.for.body51:
; predecessors: %bb.15, %bb.19
  successors: %bb.17(0x50000000), %bb.19(0x30000000); %bb.17(62.50%), %bb.19(37.50%)

  %13:gr32 = PHI %114:gr32, %bb.15, %16:gr32, %bb.19
  %115:fr64 = CVTSI2SDrr %13:gr32
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %116:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %117:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %8:fr64
  $xmm1 = COPY %11:fr64
  $xmm2 = COPY %12:fr64
  $xmm3 = COPY %115:fr64
  $rdi = COPY %116:gr64
  $rsi = COPY %117:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %118:gr64 = MOV32ri64 @.str.1
  %119:gr32 = MOV32r0 implicit-def dead $eflags
  %120:gr8 = COPY %119.sub_8bit:gr32
  $rdi = COPY %118:gr64
  $al = COPY %120:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %121:gr32 = COPY $eax
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.19, 14, implicit $eflags
  JMP_1 %bb.17

bb.17.for.body56.preheader:
; predecessors: %bb.16
  successors: %bb.18(0x80000000); %bb.18(100.00%)

  %123:gr32 = MOV32r0 implicit-def dead $eflags
  %122:gr64 = SUBREG_TO_REG 0, killed %123:gr32, %subreg.sub_32bit

bb.18.for.body56:
; predecessors: %bb.17, %bb.18
  successors: %bb.18(0x7c000000), %bb.19(0x04000000); %bb.18(96.88%), %bb.19(3.12%)

  %14:gr64_nosp = PHI %122:gr64, %bb.17, %15:gr64, %bb.18
  %124:fr64 = MOVSDrm_alt %stack.0.x, 8, %14:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep, !tbaa !5)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %125:gr64 = MOV32ri64 @.str.2
  %126:gr8 = MOV8ri 1
  $rdi = COPY %125:gr64
  $xmm0 = COPY %124:fr64
  $al = COPY %126:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %127:gr32 = COPY $eax
  %15:gr64 = nuw nsw ADD64ri8 %14:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
  %128:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  %129:gr64 = SUB64rr %15:gr64(tied-def 0), killed %128:gr64, implicit-def $eflags
  JCC_1 %bb.18, 12, implicit $eflags
  JMP_1 %bb.19

bb.19.for.end62:
; predecessors: %bb.16, %bb.18
  successors: %bb.16(0x7c000000), %bb.20(0x04000000); %bb.16(96.88%), %bb.20(3.12%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %130:gr32 = MOV32ri 10
  $edi = COPY %130:gr32
  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %131:gr32 = COPY $eax
  %16:gr32 = nsw ADD32ri8 %13:gr32(tied-def 0), -1, implicit-def dead $eflags
  %132:gr32 = SUB32ri8 %16:gr32(tied-def 0), -11, implicit-def $eflags
  JCC_1 %bb.16, 15, implicit $eflags
  JMP_1 %bb.20

bb.20.for.inc66:
; predecessors: %bb.19
  successors: %bb.15(0x7c000000), %bb.21(0x04000000); %bb.15(96.88%), %bb.21(3.12%)

  %17:fr64 = nofpexcept ADDSDrm %12:fr64(tied-def 0), $rip, 1, $noreg, %const.12, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %133:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.13, $noreg :: (load 8 from constant-pool)
  nofpexcept UCOMISDrr killed %133:fr64, %17:fr64, implicit-def $eflags, implicit $mxcsr
  JCC_1 %bb.15, 7, implicit $eflags
  JMP_1 %bb.21

bb.21.for.inc68:
; predecessors: %bb.20
  successors: %bb.14(0x7c000000), %bb.22(0x04000000); %bb.14(96.88%), %bb.22(3.12%)

  %18:gr32 = nsw ADD32ri8 %10:gr32(tied-def 0), -1, implicit-def dead $eflags
  %134:gr32 = SUB32ri8 %10:gr32(tied-def 0), 1, implicit-def $eflags
  JCC_1 %bb.14, 15, implicit $eflags
  JMP_1 %bb.22

bb.22.for.inc71:
; predecessors: %bb.21
  successors: %bb.23(0x04000000), %bb.13(0x7c000000); %bb.23(3.12%), %bb.13(96.88%)

  %19:fr64 = nofpexcept ADDSDrm %8:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %20:gr32 = nuw nsw ADD32ri8 %9:gr32(tied-def 0), 1, implicit-def dead $eflags
  %135:gr32 = SUB32ri8 %20:gr32(tied-def 0), 10, implicit-def $eflags
  JCC_1 %bb.13, 5, implicit $eflags
  JMP_1 %bb.23

bb.23.for.end73:
; predecessors: %bb.22
  successors: %bb.24(0x80000000); %bb.24(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %137:gr64 = MOV32ri64 @str.11
  $rdi = COPY %137:gr64
  CALL64pcrel32 @puts, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %138:gr32 = COPY $eax
  %139:gr32 = MOV32r0 implicit-def dead $eflags
  %136:gr64 = SUBREG_TO_REG 0, killed %139:gr32, %subreg.sub_32bit

bb.24.for.body77:
; predecessors: %bb.23, %bb.24
  successors: %bb.25(0x04000000), %bb.24(0x7c000000); %bb.25(3.12%), %bb.24(96.88%)

  %21:gr64 = PHI %136:gr64, %bb.23, %22:gr64, %bb.24
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %140:gr64 = LEA64r %stack.2.q, 1, $noreg, 0, $noreg
  $rdi = COPY %21:gr64
  $rsi = COPY %140:gr64
  CALL64pcrel32 @usqrt, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %141:gr32 = MOV32rm %stack.2.q, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.27, align 8, !tbaa !9)
  %142:gr32 = COPY %21.sub_32bit:gr64
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %143:gr64 = MOV32ri64 @.str.5
  %144:gr32 = MOV32r0 implicit-def dead $eflags
  %145:gr8 = COPY %144.sub_8bit:gr32
  $rdi = COPY %143:gr64
  $esi = COPY %142:gr32
  $edx = COPY %141:gr32
  $al = COPY %145:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit $edx, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %146:gr32 = COPY $eax
  %22:gr64 = nuw nsw ADD64ri8 %21:gr64(tied-def 0), 1, implicit-def dead $eflags
  %147:gr64 = SUB64ri32 %22:gr64(tied-def 0), 1001, implicit-def $eflags
  JCC_1 %bb.24, 5, implicit $eflags
  JMP_1 %bb.25

bb.25.for.end81:
; predecessors: %bb.24
  successors: %bb.26(0x80000000); %bb.26(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %150:gr64 = MOV32ri64 1072497001
  %151:gr64 = LEA64r %stack.2.q, 1, $noreg, 0, $noreg
  $rdi = COPY %150:gr64
  $rsi = COPY %151:gr64
  CALL64pcrel32 @usqrt, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %152:gr32 = MOV32rm %stack.2.q, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.29, align 8, !tbaa !9)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %153:gr64 = MOV32ri64 @.str.6
  %154:gr32 = MOV32r0 implicit-def dead $eflags
  %155:gr8 = COPY %154.sub_8bit:gr32
  $rdi = COPY %153:gr64
  $rsi = COPY %150:gr64
  $edx = COPY %152:gr32
  $al = COPY %155:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $edx, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %156:gr32 = COPY $eax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %157:gr64 = MOV32ri64 @str.12
  $rdi = COPY %157:gr64
  CALL64pcrel32 @puts, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %158:gr32 = COPY $eax
  %149:fr64 = FsFLD0SD
  %148:gr32 = MOV32ri 361

bb.26.for.body88:
; predecessors: %bb.25, %bb.26
  successors: %bb.27(0x04000000), %bb.26(0x7c000000); %bb.27(3.12%), %bb.26(96.88%)

  %23:gr32 = PHI %148:gr32, %bb.25, %26:gr32, %bb.26
  %24:fr64 = PHI %149:fr64, %bb.25, %25:fr64, %bb.26
  %159:fr64 = nofpexcept MULSDrm %24:fr64(tied-def 0), $rip, 1, $noreg, %const.14, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %160:fr64 = nofpexcept DIVSDrm %159:fr64(tied-def 0), $rip, 1, $noreg, %const.15, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %161:gr64 = MOV32ri64 @.str.8
  %162:gr8 = MOV8ri 2
  $rdi = COPY %161:gr64
  $xmm0 = COPY %24:fr64
  $xmm1 = COPY %160:fr64
  $al = COPY %162:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $xmm1, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %163:gr32 = COPY $eax
  %25:fr64 = nofpexcept ADDSDrm %24:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %26:gr32 = ADD32ri8 %23:gr32(tied-def 0), -1, implicit-def $eflags
  JCC_1 %bb.26, 5, implicit $eflags
  JMP_1 %bb.27

bb.27.for.end94:
; predecessors: %bb.26
  successors: %bb.28(0x80000000); %bb.28(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %165:gr64 = MOV32ri64 @.str.9
  %166:gr32 = MOV32r0 implicit-def dead $eflags
  %167:gr8 = COPY %166.sub_8bit:gr32
  $rdi = COPY %165:gr64
  $al = COPY %167:gr8
  CALL64pcrel32 @puts, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %168:gr32 = COPY $eax
  %164:fr64 = FsFLD0SD

bb.28.for.body103:
; predecessors: %bb.27, %bb.28
  successors: %bb.29(0x04000000), %bb.28(0x7c000000); %bb.29(3.12%), %bb.28(96.88%)

  %27:fr64 = PHI %164:fr64, %bb.27, %28:fr64, %bb.28
  %169:fr64 = nofpexcept MULSDrm %27:fr64(tied-def 0), $rip, 1, $noreg, %const.15, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %170:fr64 = nofpexcept DIVSDrm %169:fr64(tied-def 0), $rip, 1, $noreg, %const.14, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %171:gr64 = MOV32ri64 @.str.10
  %172:gr8 = MOV8ri 2
  $rdi = COPY %171:gr64
  $xmm0 = COPY %27:fr64
  $xmm1 = COPY %170:fr64
  $al = COPY %172:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $xmm1, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %173:gr32 = COPY $eax
  %28:fr64 = nofpexcept ADDSDrm %27:fr64(tied-def 0), $rip, 1, $noreg, %const.16, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %174:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.17, $noreg :: (load 8 from constant-pool)
  nofpexcept UCOMISDrr killed %174:fr64, %28:fr64, implicit-def $eflags, implicit $mxcsr
  JCC_1 %bb.28, 3, implicit $eflags
  JMP_1 %bb.29

bb.29.for.end114:
; predecessors: %bb.28

  LIFETIME_END %stack.2.q
  LIFETIME_END %stack.1.solutions
  LIFETIME_END %stack.0.x
  %175:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY %175:gr32
  RET 0, $eax

# End machine code for function main.

# *** IR Dump After Early Tail Duplication ***:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=24, align=16, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
Constant Pool:
  cp#0: 1.000000e+00, align=8
  cp#1: -1.050000e+01, align=8
  cp#2: 3.200000e+01, align=8
  cp#3: -3.000000e+01, align=8
  cp#4: -4.500000e+00, align=8
  cp#5: 1.700000e+01, align=8
  cp#6: -3.500000e+00, align=8
  cp#7: 2.200000e+01, align=8
  cp#8: -3.100000e+01, align=8
  cp#9: -1.370000e+01, align=8
  cp#10: -3.500000e+01, align=8
  cp#11: 5.000000e+00, align=8
  cp#12: 5.000000e-01, align=8
  cp#13: 1.500000e+01, align=8
  cp#14: 0x400921FB54442D18, align=8
  cp#15: 1.800000e+02, align=8
  cp#16: 0x3F91DF46A2529D39, align=8
  cp#17: 0x401921FB97600B9B, align=8

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.3(0x30000000); %bb.1(62.50%), %bb.3(37.50%)

  LIFETIME_START %stack.0.x
  LIFETIME_START %stack.1.solutions
  LIFETIME_START %stack.2.q
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %29:gr64 = MOV32ri64 @str
  $rdi = COPY %29:gr64
  CALL64pcrel32 @puts, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %30:gr32 = COPY $eax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %31:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %32:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
  %33:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
  %34:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
  %35:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %36:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %31:fr64
  $xmm1 = COPY %32:fr64
  $xmm2 = COPY %33:fr64
  $xmm3 = COPY %34:fr64
  $rdi = COPY %35:gr64
  $rsi = COPY %36:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %37:gr64 = MOV32ri64 @.str.1
  %38:gr32 = MOV32r0 implicit-def dead $eflags
  %39:gr8 = COPY %38.sub_8bit:gr32
  $rdi = COPY %37:gr64
  $al = COPY %39:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %40:gr32 = COPY $eax
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.3, 14, implicit $eflags
  JMP_1 %bb.1

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  %42:gr32 = MOV32r0 implicit-def dead $eflags
  %41:gr64 = SUBREG_TO_REG 0, killed %42:gr32, %subreg.sub_32bit

bb.2.for.body:
; predecessors: %bb.1, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  %0:gr64_nosp = PHI %41:gr64, %bb.1, %1:gr64, %bb.2
  %43:fr64 = MOVSDrm_alt %stack.0.x, 8, %0:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep6, !tbaa !5)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %44:gr64 = MOV32ri64 @.str.2
  %45:gr8 = MOV8ri 1
  $rdi = COPY %44:gr64
  $xmm0 = COPY %43:fr64
  $al = COPY %45:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %46:gr32 = COPY $eax
  %1:gr64 = nuw nsw ADD64ri8 %0:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
  %47:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  %48:gr64 = SUB64rr %1:gr64(tied-def 0), killed %47:gr64, implicit-def $eflags
  JCC_1 %bb.2, 12, implicit $eflags
  JMP_1 %bb.3

bb.3.for.end:
; predecessors: %bb.0, %bb.2
  successors: %bb.4(0x50000000), %bb.6(0x30000000); %bb.4(62.50%), %bb.6(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %49:gr32 = MOV32ri 10
  $edi = COPY %49:gr32
  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %50:gr32 = COPY $eax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %51:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %52:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.4, $noreg :: (load 8 from constant-pool)
  %53:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.5, $noreg :: (load 8 from constant-pool)
  %54:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
  %55:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %56:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %51:fr64
  $xmm1 = COPY %52:fr64
  $xmm2 = COPY %53:fr64
  $xmm3 = COPY %54:fr64
  $rdi = COPY %55:gr64
  $rsi = COPY %56:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %57:gr64 = MOV32ri64 @.str.1
  %58:gr32 = MOV32r0 implicit-def dead $eflags
  %59:gr8 = COPY %58.sub_8bit:gr32
  $rdi = COPY %57:gr64
  $al = COPY %59:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %60:gr32 = COPY $eax
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.6, 14, implicit $eflags
  JMP_1 %bb.4

bb.4.for.body8.preheader:
; predecessors: %bb.3
  successors: %bb.5(0x80000000); %bb.5(100.00%)

  %62:gr32 = MOV32r0 implicit-def dead $eflags
  %61:gr64 = SUBREG_TO_REG 0, killed %62:gr32, %subreg.sub_32bit

bb.5.for.body8:
; predecessors: %bb.4, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  %2:gr64_nosp = PHI %61:gr64, %bb.4, %3:gr64, %bb.5
  %63:fr64 = MOVSDrm_alt %stack.0.x, 8, %2:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep5, !tbaa !5)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %64:gr64 = MOV32ri64 @.str.2
  %65:gr8 = MOV8ri 1
  $rdi = COPY %64:gr64
  $xmm0 = COPY %63:fr64
  $al = COPY %65:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %66:gr32 = COPY $eax
  %3:gr64 = nuw nsw ADD64ri8 %2:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
  %67:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  %68:gr64 = SUB64rr %3:gr64(tied-def 0), killed %67:gr64, implicit-def $eflags
  JCC_1 %bb.5, 12, implicit $eflags
  JMP_1 %bb.6

bb.6.for.end14:
; predecessors: %bb.3, %bb.5
  successors: %bb.7(0x50000000), %bb.9(0x30000000); %bb.7(62.50%), %bb.9(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %69:gr32 = MOV32ri 10
  $edi = COPY %69:gr32
  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %70:gr32 = COPY $eax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %71:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %72:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.6, $noreg :: (load 8 from constant-pool)
  %73:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.7, $noreg :: (load 8 from constant-pool)
  %74:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.8, $noreg :: (load 8 from constant-pool)
  %75:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %76:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %71:fr64
  $xmm1 = COPY %72:fr64
  $xmm2 = COPY %73:fr64
  $xmm3 = COPY %74:fr64
  $rdi = COPY %75:gr64
  $rsi = COPY %76:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %77:gr64 = MOV32ri64 @.str.1
  %78:gr32 = MOV32r0 implicit-def dead $eflags
  %79:gr8 = COPY %78.sub_8bit:gr32
  $rdi = COPY %77:gr64
  $al = COPY %79:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %80:gr32 = COPY $eax
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.9, 14, implicit $eflags
  JMP_1 %bb.7

bb.7.for.body20.preheader:
; predecessors: %bb.6
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  %82:gr32 = MOV32r0 implicit-def dead $eflags
  %81:gr64 = SUBREG_TO_REG 0, killed %82:gr32, %subreg.sub_32bit

bb.8.for.body20:
; predecessors: %bb.7, %bb.8
  successors: %bb.8(0x7c000000), %bb.9(0x04000000); %bb.8(96.88%), %bb.9(3.12%)

  %4:gr64_nosp = PHI %81:gr64, %bb.7, %5:gr64, %bb.8
  %83:fr64 = MOVSDrm_alt %stack.0.x, 8, %4:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep4, !tbaa !5)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %84:gr64 = MOV32ri64 @.str.2
  %85:gr8 = MOV8ri 1
  $rdi = COPY %84:gr64
  $xmm0 = COPY %83:fr64
  $al = COPY %85:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %86:gr32 = COPY $eax
  %5:gr64 = nuw nsw ADD64ri8 %4:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
  %87:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  %88:gr64 = SUB64rr %5:gr64(tied-def 0), killed %87:gr64, implicit-def $eflags
  JCC_1 %bb.8, 12, implicit $eflags
  JMP_1 %bb.9

bb.9.for.end26:
; predecessors: %bb.6, %bb.8
  successors: %bb.10(0x50000000), %bb.12(0x30000000); %bb.10(62.50%), %bb.12(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %89:gr32 = MOV32ri 10
  $edi = COPY %89:gr32
  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %90:gr32 = COPY $eax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %91:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.9, $noreg :: (load 8 from constant-pool)
  %92:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %93:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.10, $noreg :: (load 8 from constant-pool)
  %94:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %95:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %92:fr64
  $xmm1 = COPY %91:fr64
  $xmm2 = COPY %92:fr64
  $xmm3 = COPY %93:fr64
  $rdi = COPY %94:gr64
  $rsi = COPY %95:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %96:gr64 = MOV32ri64 @.str.1
  %97:gr32 = MOV32r0 implicit-def dead $eflags
  %98:gr8 = COPY %97.sub_8bit:gr32
  $rdi = COPY %96:gr64
  $al = COPY %98:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %99:gr32 = COPY $eax
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.12, 14, implicit $eflags
  JMP_1 %bb.10

bb.10.for.body32.preheader:
; predecessors: %bb.9
  successors: %bb.11(0x80000000); %bb.11(100.00%)

  %101:gr32 = MOV32r0 implicit-def dead $eflags
  %100:gr64 = SUBREG_TO_REG 0, killed %101:gr32, %subreg.sub_32bit

bb.11.for.body32:
; predecessors: %bb.10, %bb.11
  successors: %bb.11(0x7c000000), %bb.12(0x04000000); %bb.11(96.88%), %bb.12(3.12%)

  %6:gr64_nosp = PHI %100:gr64, %bb.10, %7:gr64, %bb.11
  %102:fr64 = MOVSDrm_alt %stack.0.x, 8, %6:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep3, !tbaa !5)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %103:gr64 = MOV32ri64 @.str.2
  %104:gr8 = MOV8ri 1
  $rdi = COPY %103:gr64
  $xmm0 = COPY %102:fr64
  $al = COPY %104:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %105:gr32 = COPY $eax
  %7:gr64 = nuw nsw ADD64ri8 %6:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
  %106:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  %107:gr64 = SUB64rr %7:gr64(tied-def 0), killed %106:gr64, implicit-def $eflags
  JCC_1 %bb.11, 12, implicit $eflags
  JMP_1 %bb.12

bb.12.for.end38:
; predecessors: %bb.9, %bb.11
  successors: %bb.13(0x80000000); %bb.13(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %110:gr32 = MOV32ri 10
  $edi = COPY %110:gr32
  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %111:gr32 = COPY $eax
  %109:gr32 = MOV32ri 1
  %108:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)

bb.13.for.cond43.preheader:
; predecessors: %bb.12, %bb.22
  successors: %bb.14(0x80000000); %bb.14(100.00%)

  %8:fr64 = PHI %108:fr64, %bb.12, %19:fr64, %bb.22
  %9:gr32 = PHI %109:gr32, %bb.12, %20:gr32, %bb.22
  %112:gr32 = MOV32ri 10

bb.14.for.cond46.preheader:
; predecessors: %bb.13, %bb.21
  successors: %bb.15(0x80000000); %bb.15(100.00%)

  %10:gr32 = PHI %112:gr32, %bb.13, %18:gr32, %bb.21
  %11:fr64 = CVTSI2SDrr %10:gr32
  %113:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.11, $noreg :: (load 8 from constant-pool)

bb.15.for.cond49.preheader:
; predecessors: %bb.14, %bb.20
  successors: %bb.16(0x80000000); %bb.16(100.00%)

  %12:fr64 = PHI %113:fr64, %bb.14, %17:fr64, %bb.20
  %114:gr32 = MOV32ri -1

bb.16.for.body51:
; predecessors: %bb.15, %bb.19
  successors: %bb.17(0x50000000), %bb.19(0x30000000); %bb.17(62.50%), %bb.19(37.50%)

  %13:gr32 = PHI %114:gr32, %bb.15, %16:gr32, %bb.19
  %115:fr64 = CVTSI2SDrr %13:gr32
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %116:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %117:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %8:fr64
  $xmm1 = COPY %11:fr64
  $xmm2 = COPY %12:fr64
  $xmm3 = COPY %115:fr64
  $rdi = COPY %116:gr64
  $rsi = COPY %117:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %118:gr64 = MOV32ri64 @.str.1
  %119:gr32 = MOV32r0 implicit-def dead $eflags
  %120:gr8 = COPY %119.sub_8bit:gr32
  $rdi = COPY %118:gr64
  $al = COPY %120:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %121:gr32 = COPY $eax
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.19, 14, implicit $eflags
  JMP_1 %bb.17

bb.17.for.body56.preheader:
; predecessors: %bb.16
  successors: %bb.18(0x80000000); %bb.18(100.00%)

  %123:gr32 = MOV32r0 implicit-def dead $eflags
  %122:gr64 = SUBREG_TO_REG 0, killed %123:gr32, %subreg.sub_32bit

bb.18.for.body56:
; predecessors: %bb.17, %bb.18
  successors: %bb.18(0x7c000000), %bb.19(0x04000000); %bb.18(96.88%), %bb.19(3.12%)

  %14:gr64_nosp = PHI %122:gr64, %bb.17, %15:gr64, %bb.18
  %124:fr64 = MOVSDrm_alt %stack.0.x, 8, %14:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep, !tbaa !5)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %125:gr64 = MOV32ri64 @.str.2
  %126:gr8 = MOV8ri 1
  $rdi = COPY %125:gr64
  $xmm0 = COPY %124:fr64
  $al = COPY %126:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %127:gr32 = COPY $eax
  %15:gr64 = nuw nsw ADD64ri8 %14:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
  %128:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  %129:gr64 = SUB64rr %15:gr64(tied-def 0), killed %128:gr64, implicit-def $eflags
  JCC_1 %bb.18, 12, implicit $eflags
  JMP_1 %bb.19

bb.19.for.end62:
; predecessors: %bb.16, %bb.18
  successors: %bb.16(0x7c000000), %bb.20(0x04000000); %bb.16(96.88%), %bb.20(3.12%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %130:gr32 = MOV32ri 10
  $edi = COPY %130:gr32
  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %131:gr32 = COPY $eax
  %16:gr32 = nsw ADD32ri8 %13:gr32(tied-def 0), -1, implicit-def dead $eflags
  %132:gr32 = SUB32ri8 %16:gr32(tied-def 0), -11, implicit-def $eflags
  JCC_1 %bb.16, 15, implicit $eflags
  JMP_1 %bb.20

bb.20.for.inc66:
; predecessors: %bb.19
  successors: %bb.15(0x7c000000), %bb.21(0x04000000); %bb.15(96.88%), %bb.21(3.12%)

  %17:fr64 = nofpexcept ADDSDrm %12:fr64(tied-def 0), $rip, 1, $noreg, %const.12, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %133:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.13, $noreg :: (load 8 from constant-pool)
  nofpexcept UCOMISDrr killed %133:fr64, %17:fr64, implicit-def $eflags, implicit $mxcsr
  JCC_1 %bb.15, 7, implicit $eflags
  JMP_1 %bb.21

bb.21.for.inc68:
; predecessors: %bb.20
  successors: %bb.14(0x7c000000), %bb.22(0x04000000); %bb.14(96.88%), %bb.22(3.12%)

  %18:gr32 = nsw ADD32ri8 %10:gr32(tied-def 0), -1, implicit-def dead $eflags
  %134:gr32 = SUB32ri8 %10:gr32(tied-def 0), 1, implicit-def $eflags
  JCC_1 %bb.14, 15, implicit $eflags
  JMP_1 %bb.22

bb.22.for.inc71:
; predecessors: %bb.21
  successors: %bb.23(0x04000000), %bb.13(0x7c000000); %bb.23(3.12%), %bb.13(96.88%)

  %19:fr64 = nofpexcept ADDSDrm %8:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %20:gr32 = nuw nsw ADD32ri8 %9:gr32(tied-def 0), 1, implicit-def dead $eflags
  %135:gr32 = SUB32ri8 %20:gr32(tied-def 0), 10, implicit-def $eflags
  JCC_1 %bb.13, 5, implicit $eflags
  JMP_1 %bb.23

bb.23.for.end73:
; predecessors: %bb.22
  successors: %bb.24(0x80000000); %bb.24(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %137:gr64 = MOV32ri64 @str.11
  $rdi = COPY %137:gr64
  CALL64pcrel32 @puts, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %138:gr32 = COPY $eax
  %139:gr32 = MOV32r0 implicit-def dead $eflags
  %136:gr64 = SUBREG_TO_REG 0, killed %139:gr32, %subreg.sub_32bit

bb.24.for.body77:
; predecessors: %bb.23, %bb.24
  successors: %bb.25(0x04000000), %bb.24(0x7c000000); %bb.25(3.12%), %bb.24(96.88%)

  %21:gr64 = PHI %136:gr64, %bb.23, %22:gr64, %bb.24
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %140:gr64 = LEA64r %stack.2.q, 1, $noreg, 0, $noreg
  $rdi = COPY %21:gr64
  $rsi = COPY %140:gr64
  CALL64pcrel32 @usqrt, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %141:gr32 = MOV32rm %stack.2.q, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.27, align 8, !tbaa !9)
  %142:gr32 = COPY %21.sub_32bit:gr64
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %143:gr64 = MOV32ri64 @.str.5
  %144:gr32 = MOV32r0 implicit-def dead $eflags
  %145:gr8 = COPY %144.sub_8bit:gr32
  $rdi = COPY %143:gr64
  $esi = COPY %142:gr32
  $edx = COPY %141:gr32
  $al = COPY %145:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit $edx, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %146:gr32 = COPY $eax
  %22:gr64 = nuw nsw ADD64ri8 %21:gr64(tied-def 0), 1, implicit-def dead $eflags
  %147:gr64 = SUB64ri32 %22:gr64(tied-def 0), 1001, implicit-def $eflags
  JCC_1 %bb.24, 5, implicit $eflags
  JMP_1 %bb.25

bb.25.for.end81:
; predecessors: %bb.24
  successors: %bb.26(0x80000000); %bb.26(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %150:gr64 = MOV32ri64 1072497001
  %151:gr64 = LEA64r %stack.2.q, 1, $noreg, 0, $noreg
  $rdi = COPY %150:gr64
  $rsi = COPY %151:gr64
  CALL64pcrel32 @usqrt, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %152:gr32 = MOV32rm %stack.2.q, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.29, align 8, !tbaa !9)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %153:gr64 = MOV32ri64 @.str.6
  %154:gr32 = MOV32r0 implicit-def dead $eflags
  %155:gr8 = COPY %154.sub_8bit:gr32
  $rdi = COPY %153:gr64
  $rsi = COPY %150:gr64
  $edx = COPY %152:gr32
  $al = COPY %155:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $edx, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %156:gr32 = COPY $eax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %157:gr64 = MOV32ri64 @str.12
  $rdi = COPY %157:gr64
  CALL64pcrel32 @puts, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %158:gr32 = COPY $eax
  %149:fr64 = FsFLD0SD
  %148:gr32 = MOV32ri 361

bb.26.for.body88:
; predecessors: %bb.25, %bb.26
  successors: %bb.27(0x04000000), %bb.26(0x7c000000); %bb.27(3.12%), %bb.26(96.88%)

  %23:gr32 = PHI %148:gr32, %bb.25, %26:gr32, %bb.26
  %24:fr64 = PHI %149:fr64, %bb.25, %25:fr64, %bb.26
  %159:fr64 = nofpexcept MULSDrm %24:fr64(tied-def 0), $rip, 1, $noreg, %const.14, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %160:fr64 = nofpexcept DIVSDrm %159:fr64(tied-def 0), $rip, 1, $noreg, %const.15, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %161:gr64 = MOV32ri64 @.str.8
  %162:gr8 = MOV8ri 2
  $rdi = COPY %161:gr64
  $xmm0 = COPY %24:fr64
  $xmm1 = COPY %160:fr64
  $al = COPY %162:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $xmm1, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %163:gr32 = COPY $eax
  %25:fr64 = nofpexcept ADDSDrm %24:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %26:gr32 = ADD32ri8 %23:gr32(tied-def 0), -1, implicit-def $eflags
  JCC_1 %bb.26, 5, implicit $eflags
  JMP_1 %bb.27

bb.27.for.end94:
; predecessors: %bb.26
  successors: %bb.28(0x80000000); %bb.28(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %165:gr64 = MOV32ri64 @.str.9
  %166:gr32 = MOV32r0 implicit-def dead $eflags
  %167:gr8 = COPY %166.sub_8bit:gr32
  $rdi = COPY %165:gr64
  $al = COPY %167:gr8
  CALL64pcrel32 @puts, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %168:gr32 = COPY $eax
  %164:fr64 = FsFLD0SD

bb.28.for.body103:
; predecessors: %bb.27, %bb.28
  successors: %bb.29(0x04000000), %bb.28(0x7c000000); %bb.29(3.12%), %bb.28(96.88%)

  %27:fr64 = PHI %164:fr64, %bb.27, %28:fr64, %bb.28
  %169:fr64 = nofpexcept MULSDrm %27:fr64(tied-def 0), $rip, 1, $noreg, %const.15, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %170:fr64 = nofpexcept DIVSDrm %169:fr64(tied-def 0), $rip, 1, $noreg, %const.14, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %171:gr64 = MOV32ri64 @.str.10
  %172:gr8 = MOV8ri 2
  $rdi = COPY %171:gr64
  $xmm0 = COPY %27:fr64
  $xmm1 = COPY %170:fr64
  $al = COPY %172:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $xmm1, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %173:gr32 = COPY $eax
  %28:fr64 = nofpexcept ADDSDrm %27:fr64(tied-def 0), $rip, 1, $noreg, %const.16, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %174:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.17, $noreg :: (load 8 from constant-pool)
  nofpexcept UCOMISDrr killed %174:fr64, %28:fr64, implicit-def $eflags, implicit $mxcsr
  JCC_1 %bb.28, 3, implicit $eflags
  JMP_1 %bb.29

bb.29.for.end114:
; predecessors: %bb.28

  LIFETIME_END %stack.2.q
  LIFETIME_END %stack.1.solutions
  LIFETIME_END %stack.0.x
  %175:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY %175:gr32
  RET 0, $eax

# End machine code for function main.

# *** IR Dump After Optimize machine instruction PHIs ***:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=24, align=16, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
Constant Pool:
  cp#0: 1.000000e+00, align=8
  cp#1: -1.050000e+01, align=8
  cp#2: 3.200000e+01, align=8
  cp#3: -3.000000e+01, align=8
  cp#4: -4.500000e+00, align=8
  cp#5: 1.700000e+01, align=8
  cp#6: -3.500000e+00, align=8
  cp#7: 2.200000e+01, align=8
  cp#8: -3.100000e+01, align=8
  cp#9: -1.370000e+01, align=8
  cp#10: -3.500000e+01, align=8
  cp#11: 5.000000e+00, align=8
  cp#12: 5.000000e-01, align=8
  cp#13: 1.500000e+01, align=8
  cp#14: 0x400921FB54442D18, align=8
  cp#15: 1.800000e+02, align=8
  cp#16: 0x3F91DF46A2529D39, align=8
  cp#17: 0x401921FB97600B9B, align=8

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.3(0x30000000); %bb.1(62.50%), %bb.3(37.50%)

  LIFETIME_START %stack.0.x
  LIFETIME_START %stack.1.solutions
  LIFETIME_START %stack.2.q
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %29:gr64 = MOV32ri64 @str
  $rdi = COPY %29:gr64
  CALL64pcrel32 @puts, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %30:gr32 = COPY $eax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %31:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %32:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
  %33:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
  %34:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
  %35:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %36:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %31:fr64
  $xmm1 = COPY %32:fr64
  $xmm2 = COPY %33:fr64
  $xmm3 = COPY %34:fr64
  $rdi = COPY %35:gr64
  $rsi = COPY %36:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %37:gr64 = MOV32ri64 @.str.1
  %38:gr32 = MOV32r0 implicit-def dead $eflags
  %39:gr8 = COPY %38.sub_8bit:gr32
  $rdi = COPY %37:gr64
  $al = COPY %39:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %40:gr32 = COPY $eax
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.3, 14, implicit $eflags
  JMP_1 %bb.1

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  %42:gr32 = MOV32r0 implicit-def dead $eflags
  %41:gr64 = SUBREG_TO_REG 0, killed %42:gr32, %subreg.sub_32bit

bb.2.for.body:
; predecessors: %bb.1, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  %0:gr64_nosp = PHI %41:gr64, %bb.1, %1:gr64, %bb.2
  %43:fr64 = MOVSDrm_alt %stack.0.x, 8, %0:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep6, !tbaa !5)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %44:gr64 = MOV32ri64 @.str.2
  %45:gr8 = MOV8ri 1
  $rdi = COPY %44:gr64
  $xmm0 = COPY %43:fr64
  $al = COPY %45:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %46:gr32 = COPY $eax
  %1:gr64 = nuw nsw ADD64ri8 %0:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
  %47:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  %48:gr64 = SUB64rr %1:gr64(tied-def 0), killed %47:gr64, implicit-def $eflags
  JCC_1 %bb.2, 12, implicit $eflags
  JMP_1 %bb.3

bb.3.for.end:
; predecessors: %bb.0, %bb.2
  successors: %bb.4(0x50000000), %bb.6(0x30000000); %bb.4(62.50%), %bb.6(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %49:gr32 = MOV32ri 10
  $edi = COPY %49:gr32
  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %50:gr32 = COPY $eax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %51:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %52:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.4, $noreg :: (load 8 from constant-pool)
  %53:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.5, $noreg :: (load 8 from constant-pool)
  %54:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
  %55:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %56:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %51:fr64
  $xmm1 = COPY %52:fr64
  $xmm2 = COPY %53:fr64
  $xmm3 = COPY %54:fr64
  $rdi = COPY %55:gr64
  $rsi = COPY %56:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %57:gr64 = MOV32ri64 @.str.1
  %58:gr32 = MOV32r0 implicit-def dead $eflags
  %59:gr8 = COPY %58.sub_8bit:gr32
  $rdi = COPY %57:gr64
  $al = COPY %59:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %60:gr32 = COPY $eax
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.6, 14, implicit $eflags
  JMP_1 %bb.4

bb.4.for.body8.preheader:
; predecessors: %bb.3
  successors: %bb.5(0x80000000); %bb.5(100.00%)

  %62:gr32 = MOV32r0 implicit-def dead $eflags
  %61:gr64 = SUBREG_TO_REG 0, killed %62:gr32, %subreg.sub_32bit

bb.5.for.body8:
; predecessors: %bb.4, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  %2:gr64_nosp = PHI %61:gr64, %bb.4, %3:gr64, %bb.5
  %63:fr64 = MOVSDrm_alt %stack.0.x, 8, %2:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep5, !tbaa !5)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %64:gr64 = MOV32ri64 @.str.2
  %65:gr8 = MOV8ri 1
  $rdi = COPY %64:gr64
  $xmm0 = COPY %63:fr64
  $al = COPY %65:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %66:gr32 = COPY $eax
  %3:gr64 = nuw nsw ADD64ri8 %2:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
  %67:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  %68:gr64 = SUB64rr %3:gr64(tied-def 0), killed %67:gr64, implicit-def $eflags
  JCC_1 %bb.5, 12, implicit $eflags
  JMP_1 %bb.6

bb.6.for.end14:
; predecessors: %bb.3, %bb.5
  successors: %bb.7(0x50000000), %bb.9(0x30000000); %bb.7(62.50%), %bb.9(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %69:gr32 = MOV32ri 10
  $edi = COPY %69:gr32
  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %70:gr32 = COPY $eax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %71:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %72:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.6, $noreg :: (load 8 from constant-pool)
  %73:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.7, $noreg :: (load 8 from constant-pool)
  %74:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.8, $noreg :: (load 8 from constant-pool)
  %75:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %76:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %71:fr64
  $xmm1 = COPY %72:fr64
  $xmm2 = COPY %73:fr64
  $xmm3 = COPY %74:fr64
  $rdi = COPY %75:gr64
  $rsi = COPY %76:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %77:gr64 = MOV32ri64 @.str.1
  %78:gr32 = MOV32r0 implicit-def dead $eflags
  %79:gr8 = COPY %78.sub_8bit:gr32
  $rdi = COPY %77:gr64
  $al = COPY %79:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %80:gr32 = COPY $eax
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.9, 14, implicit $eflags
  JMP_1 %bb.7

bb.7.for.body20.preheader:
; predecessors: %bb.6
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  %82:gr32 = MOV32r0 implicit-def dead $eflags
  %81:gr64 = SUBREG_TO_REG 0, killed %82:gr32, %subreg.sub_32bit

bb.8.for.body20:
; predecessors: %bb.7, %bb.8
  successors: %bb.8(0x7c000000), %bb.9(0x04000000); %bb.8(96.88%), %bb.9(3.12%)

  %4:gr64_nosp = PHI %81:gr64, %bb.7, %5:gr64, %bb.8
  %83:fr64 = MOVSDrm_alt %stack.0.x, 8, %4:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep4, !tbaa !5)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %84:gr64 = MOV32ri64 @.str.2
  %85:gr8 = MOV8ri 1
  $rdi = COPY %84:gr64
  $xmm0 = COPY %83:fr64
  $al = COPY %85:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %86:gr32 = COPY $eax
  %5:gr64 = nuw nsw ADD64ri8 %4:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
  %87:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  %88:gr64 = SUB64rr %5:gr64(tied-def 0), killed %87:gr64, implicit-def $eflags
  JCC_1 %bb.8, 12, implicit $eflags
  JMP_1 %bb.9

bb.9.for.end26:
; predecessors: %bb.6, %bb.8
  successors: %bb.10(0x50000000), %bb.12(0x30000000); %bb.10(62.50%), %bb.12(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %89:gr32 = MOV32ri 10
  $edi = COPY %89:gr32
  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %90:gr32 = COPY $eax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %91:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.9, $noreg :: (load 8 from constant-pool)
  %92:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %93:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.10, $noreg :: (load 8 from constant-pool)
  %94:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %95:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %92:fr64
  $xmm1 = COPY %91:fr64
  $xmm2 = COPY %92:fr64
  $xmm3 = COPY %93:fr64
  $rdi = COPY %94:gr64
  $rsi = COPY %95:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %96:gr64 = MOV32ri64 @.str.1
  %97:gr32 = MOV32r0 implicit-def dead $eflags
  %98:gr8 = COPY %97.sub_8bit:gr32
  $rdi = COPY %96:gr64
  $al = COPY %98:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %99:gr32 = COPY $eax
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.12, 14, implicit $eflags
  JMP_1 %bb.10

bb.10.for.body32.preheader:
; predecessors: %bb.9
  successors: %bb.11(0x80000000); %bb.11(100.00%)

  %101:gr32 = MOV32r0 implicit-def dead $eflags
  %100:gr64 = SUBREG_TO_REG 0, killed %101:gr32, %subreg.sub_32bit

bb.11.for.body32:
; predecessors: %bb.10, %bb.11
  successors: %bb.11(0x7c000000), %bb.12(0x04000000); %bb.11(96.88%), %bb.12(3.12%)

  %6:gr64_nosp = PHI %100:gr64, %bb.10, %7:gr64, %bb.11
  %102:fr64 = MOVSDrm_alt %stack.0.x, 8, %6:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep3, !tbaa !5)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %103:gr64 = MOV32ri64 @.str.2
  %104:gr8 = MOV8ri 1
  $rdi = COPY %103:gr64
  $xmm0 = COPY %102:fr64
  $al = COPY %104:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %105:gr32 = COPY $eax
  %7:gr64 = nuw nsw ADD64ri8 %6:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
  %106:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  %107:gr64 = SUB64rr %7:gr64(tied-def 0), killed %106:gr64, implicit-def $eflags
  JCC_1 %bb.11, 12, implicit $eflags
  JMP_1 %bb.12

bb.12.for.end38:
; predecessors: %bb.9, %bb.11
  successors: %bb.13(0x80000000); %bb.13(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %110:gr32 = MOV32ri 10
  $edi = COPY %110:gr32
  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %111:gr32 = COPY $eax
  %109:gr32 = MOV32ri 1
  %108:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)

bb.13.for.cond43.preheader:
; predecessors: %bb.12, %bb.22
  successors: %bb.14(0x80000000); %bb.14(100.00%)

  %8:fr64 = PHI %108:fr64, %bb.12, %19:fr64, %bb.22
  %9:gr32 = PHI %109:gr32, %bb.12, %20:gr32, %bb.22
  %112:gr32 = MOV32ri 10

bb.14.for.cond46.preheader:
; predecessors: %bb.13, %bb.21
  successors: %bb.15(0x80000000); %bb.15(100.00%)

  %10:gr32 = PHI %112:gr32, %bb.13, %18:gr32, %bb.21
  %11:fr64 = CVTSI2SDrr %10:gr32
  %113:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.11, $noreg :: (load 8 from constant-pool)

bb.15.for.cond49.preheader:
; predecessors: %bb.14, %bb.20
  successors: %bb.16(0x80000000); %bb.16(100.00%)

  %12:fr64 = PHI %113:fr64, %bb.14, %17:fr64, %bb.20
  %114:gr32 = MOV32ri -1

bb.16.for.body51:
; predecessors: %bb.15, %bb.19
  successors: %bb.17(0x50000000), %bb.19(0x30000000); %bb.17(62.50%), %bb.19(37.50%)

  %13:gr32 = PHI %114:gr32, %bb.15, %16:gr32, %bb.19
  %115:fr64 = CVTSI2SDrr %13:gr32
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %116:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %117:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %8:fr64
  $xmm1 = COPY %11:fr64
  $xmm2 = COPY %12:fr64
  $xmm3 = COPY %115:fr64
  $rdi = COPY %116:gr64
  $rsi = COPY %117:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %118:gr64 = MOV32ri64 @.str.1
  %119:gr32 = MOV32r0 implicit-def dead $eflags
  %120:gr8 = COPY %119.sub_8bit:gr32
  $rdi = COPY %118:gr64
  $al = COPY %120:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %121:gr32 = COPY $eax
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.19, 14, implicit $eflags
  JMP_1 %bb.17

bb.17.for.body56.preheader:
; predecessors: %bb.16
  successors: %bb.18(0x80000000); %bb.18(100.00%)

  %123:gr32 = MOV32r0 implicit-def dead $eflags
  %122:gr64 = SUBREG_TO_REG 0, killed %123:gr32, %subreg.sub_32bit

bb.18.for.body56:
; predecessors: %bb.17, %bb.18
  successors: %bb.18(0x7c000000), %bb.19(0x04000000); %bb.18(96.88%), %bb.19(3.12%)

  %14:gr64_nosp = PHI %122:gr64, %bb.17, %15:gr64, %bb.18
  %124:fr64 = MOVSDrm_alt %stack.0.x, 8, %14:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep, !tbaa !5)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %125:gr64 = MOV32ri64 @.str.2
  %126:gr8 = MOV8ri 1
  $rdi = COPY %125:gr64
  $xmm0 = COPY %124:fr64
  $al = COPY %126:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %127:gr32 = COPY $eax
  %15:gr64 = nuw nsw ADD64ri8 %14:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
  %128:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  %129:gr64 = SUB64rr %15:gr64(tied-def 0), killed %128:gr64, implicit-def $eflags
  JCC_1 %bb.18, 12, implicit $eflags
  JMP_1 %bb.19

bb.19.for.end62:
; predecessors: %bb.16, %bb.18
  successors: %bb.16(0x7c000000), %bb.20(0x04000000); %bb.16(96.88%), %bb.20(3.12%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %130:gr32 = MOV32ri 10
  $edi = COPY %130:gr32
  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %131:gr32 = COPY $eax
  %16:gr32 = nsw ADD32ri8 %13:gr32(tied-def 0), -1, implicit-def dead $eflags
  %132:gr32 = SUB32ri8 %16:gr32(tied-def 0), -11, implicit-def $eflags
  JCC_1 %bb.16, 15, implicit $eflags
  JMP_1 %bb.20

bb.20.for.inc66:
; predecessors: %bb.19
  successors: %bb.15(0x7c000000), %bb.21(0x04000000); %bb.15(96.88%), %bb.21(3.12%)

  %17:fr64 = nofpexcept ADDSDrm %12:fr64(tied-def 0), $rip, 1, $noreg, %const.12, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %133:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.13, $noreg :: (load 8 from constant-pool)
  nofpexcept UCOMISDrr killed %133:fr64, %17:fr64, implicit-def $eflags, implicit $mxcsr
  JCC_1 %bb.15, 7, implicit $eflags
  JMP_1 %bb.21

bb.21.for.inc68:
; predecessors: %bb.20
  successors: %bb.14(0x7c000000), %bb.22(0x04000000); %bb.14(96.88%), %bb.22(3.12%)

  %18:gr32 = nsw ADD32ri8 %10:gr32(tied-def 0), -1, implicit-def dead $eflags
  %134:gr32 = SUB32ri8 %10:gr32(tied-def 0), 1, implicit-def $eflags
  JCC_1 %bb.14, 15, implicit $eflags
  JMP_1 %bb.22

bb.22.for.inc71:
; predecessors: %bb.21
  successors: %bb.23(0x04000000), %bb.13(0x7c000000); %bb.23(3.12%), %bb.13(96.88%)

  %19:fr64 = nofpexcept ADDSDrm %8:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %20:gr32 = nuw nsw ADD32ri8 %9:gr32(tied-def 0), 1, implicit-def dead $eflags
  %135:gr32 = SUB32ri8 %20:gr32(tied-def 0), 10, implicit-def $eflags
  JCC_1 %bb.13, 5, implicit $eflags
  JMP_1 %bb.23

bb.23.for.end73:
; predecessors: %bb.22
  successors: %bb.24(0x80000000); %bb.24(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %137:gr64 = MOV32ri64 @str.11
  $rdi = COPY %137:gr64
  CALL64pcrel32 @puts, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %138:gr32 = COPY $eax
  %139:gr32 = MOV32r0 implicit-def dead $eflags
  %136:gr64 = SUBREG_TO_REG 0, killed %139:gr32, %subreg.sub_32bit

bb.24.for.body77:
; predecessors: %bb.23, %bb.24
  successors: %bb.25(0x04000000), %bb.24(0x7c000000); %bb.25(3.12%), %bb.24(96.88%)

  %21:gr64 = PHI %136:gr64, %bb.23, %22:gr64, %bb.24
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %140:gr64 = LEA64r %stack.2.q, 1, $noreg, 0, $noreg
  $rdi = COPY %21:gr64
  $rsi = COPY %140:gr64
  CALL64pcrel32 @usqrt, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %141:gr32 = MOV32rm %stack.2.q, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.27, align 8, !tbaa !9)
  %142:gr32 = COPY %21.sub_32bit:gr64
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %143:gr64 = MOV32ri64 @.str.5
  %144:gr32 = MOV32r0 implicit-def dead $eflags
  %145:gr8 = COPY %144.sub_8bit:gr32
  $rdi = COPY %143:gr64
  $esi = COPY %142:gr32
  $edx = COPY %141:gr32
  $al = COPY %145:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit $edx, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %146:gr32 = COPY $eax
  %22:gr64 = nuw nsw ADD64ri8 %21:gr64(tied-def 0), 1, implicit-def dead $eflags
  %147:gr64 = SUB64ri32 %22:gr64(tied-def 0), 1001, implicit-def $eflags
  JCC_1 %bb.24, 5, implicit $eflags
  JMP_1 %bb.25

bb.25.for.end81:
; predecessors: %bb.24
  successors: %bb.26(0x80000000); %bb.26(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %150:gr64 = MOV32ri64 1072497001
  %151:gr64 = LEA64r %stack.2.q, 1, $noreg, 0, $noreg
  $rdi = COPY %150:gr64
  $rsi = COPY %151:gr64
  CALL64pcrel32 @usqrt, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %152:gr32 = MOV32rm %stack.2.q, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.29, align 8, !tbaa !9)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %153:gr64 = MOV32ri64 @.str.6
  %154:gr32 = MOV32r0 implicit-def dead $eflags
  %155:gr8 = COPY %154.sub_8bit:gr32
  $rdi = COPY %153:gr64
  $rsi = COPY %150:gr64
  $edx = COPY %152:gr32
  $al = COPY %155:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $edx, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %156:gr32 = COPY $eax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %157:gr64 = MOV32ri64 @str.12
  $rdi = COPY %157:gr64
  CALL64pcrel32 @puts, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %158:gr32 = COPY $eax
  %149:fr64 = FsFLD0SD
  %148:gr32 = MOV32ri 361

bb.26.for.body88:
; predecessors: %bb.25, %bb.26
  successors: %bb.27(0x04000000), %bb.26(0x7c000000); %bb.27(3.12%), %bb.26(96.88%)

  %23:gr32 = PHI %148:gr32, %bb.25, %26:gr32, %bb.26
  %24:fr64 = PHI %149:fr64, %bb.25, %25:fr64, %bb.26
  %159:fr64 = nofpexcept MULSDrm %24:fr64(tied-def 0), $rip, 1, $noreg, %const.14, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %160:fr64 = nofpexcept DIVSDrm %159:fr64(tied-def 0), $rip, 1, $noreg, %const.15, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %161:gr64 = MOV32ri64 @.str.8
  %162:gr8 = MOV8ri 2
  $rdi = COPY %161:gr64
  $xmm0 = COPY %24:fr64
  $xmm1 = COPY %160:fr64
  $al = COPY %162:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $xmm1, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %163:gr32 = COPY $eax
  %25:fr64 = nofpexcept ADDSDrm %24:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %26:gr32 = ADD32ri8 %23:gr32(tied-def 0), -1, implicit-def $eflags
  JCC_1 %bb.26, 5, implicit $eflags
  JMP_1 %bb.27

bb.27.for.end94:
; predecessors: %bb.26
  successors: %bb.28(0x80000000); %bb.28(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %165:gr64 = MOV32ri64 @.str.9
  %166:gr32 = MOV32r0 implicit-def dead $eflags
  %167:gr8 = COPY %166.sub_8bit:gr32
  $rdi = COPY %165:gr64
  $al = COPY %167:gr8
  CALL64pcrel32 @puts, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %168:gr32 = COPY $eax
  %164:fr64 = FsFLD0SD

bb.28.for.body103:
; predecessors: %bb.27, %bb.28
  successors: %bb.29(0x04000000), %bb.28(0x7c000000); %bb.29(3.12%), %bb.28(96.88%)

  %27:fr64 = PHI %164:fr64, %bb.27, %28:fr64, %bb.28
  %169:fr64 = nofpexcept MULSDrm %27:fr64(tied-def 0), $rip, 1, $noreg, %const.15, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %170:fr64 = nofpexcept DIVSDrm %169:fr64(tied-def 0), $rip, 1, $noreg, %const.14, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %171:gr64 = MOV32ri64 @.str.10
  %172:gr8 = MOV8ri 2
  $rdi = COPY %171:gr64
  $xmm0 = COPY %27:fr64
  $xmm1 = COPY %170:fr64
  $al = COPY %172:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $xmm1, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %173:gr32 = COPY $eax
  %28:fr64 = nofpexcept ADDSDrm %27:fr64(tied-def 0), $rip, 1, $noreg, %const.16, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %174:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.17, $noreg :: (load 8 from constant-pool)
  nofpexcept UCOMISDrr killed %174:fr64, %28:fr64, implicit-def $eflags, implicit $mxcsr
  JCC_1 %bb.28, 3, implicit $eflags
  JMP_1 %bb.29

bb.29.for.end114:
; predecessors: %bb.28

  LIFETIME_END %stack.2.q
  LIFETIME_END %stack.1.solutions
  LIFETIME_END %stack.0.x
  %175:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY %175:gr32
  RET 0, $eax

# End machine code for function main.

# *** IR Dump After Slot index numbering ***:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=24, align=16, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
Constant Pool:
  cp#0: 1.000000e+00, align=8
  cp#1: -1.050000e+01, align=8
  cp#2: 3.200000e+01, align=8
  cp#3: -3.000000e+01, align=8
  cp#4: -4.500000e+00, align=8
  cp#5: 1.700000e+01, align=8
  cp#6: -3.500000e+00, align=8
  cp#7: 2.200000e+01, align=8
  cp#8: -3.100000e+01, align=8
  cp#9: -1.370000e+01, align=8
  cp#10: -3.500000e+01, align=8
  cp#11: 5.000000e+00, align=8
  cp#12: 5.000000e-01, align=8
  cp#13: 1.500000e+01, align=8
  cp#14: 0x400921FB54442D18, align=8
  cp#15: 1.800000e+02, align=8
  cp#16: 0x3F91DF46A2529D39, align=8
  cp#17: 0x401921FB97600B9B, align=8

0B	bb.0.entry:
	  successors: %bb.1(0x50000000), %bb.3(0x30000000); %bb.1(62.50%), %bb.3(37.50%)

16B	  LIFETIME_START %stack.0.x
32B	  LIFETIME_START %stack.1.solutions
48B	  LIFETIME_START %stack.2.q
64B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
80B	  %29:gr64 = MOV32ri64 @str
96B	  $rdi = COPY %29:gr64
112B	  CALL64pcrel32 @puts, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
128B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
144B	  %30:gr32 = COPY $eax
160B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
176B	  %31:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
192B	  %32:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
208B	  %33:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
224B	  %34:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
240B	  %35:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
256B	  %36:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
272B	  $xmm0 = COPY %31:fr64
288B	  $xmm1 = COPY %32:fr64
304B	  $xmm2 = COPY %33:fr64
320B	  $xmm3 = COPY %34:fr64
336B	  $rdi = COPY %35:gr64
352B	  $rsi = COPY %36:gr64
368B	  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
384B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
400B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
416B	  %37:gr64 = MOV32ri64 @.str.1
432B	  %38:gr32 = MOV32r0 implicit-def dead $eflags
448B	  %39:gr8 = COPY %38.sub_8bit:gr32
464B	  $rdi = COPY %37:gr64
480B	  $al = COPY %39:gr8
496B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
512B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
528B	  %40:gr32 = COPY $eax
544B	  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
560B	  JCC_1 %bb.3, 14, implicit $eflags
576B	  JMP_1 %bb.1

592B	bb.1.for.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.2(0x80000000); %bb.2(100.00%)

608B	  %42:gr32 = MOV32r0 implicit-def dead $eflags
624B	  %41:gr64 = SUBREG_TO_REG 0, killed %42:gr32, %subreg.sub_32bit

640B	bb.2.for.body:
	; predecessors: %bb.1, %bb.2
	  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

656B	  %0:gr64_nosp = PHI %41:gr64, %bb.1, %1:gr64, %bb.2
672B	  %43:fr64 = MOVSDrm_alt %stack.0.x, 8, %0:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep6, !tbaa !5)
688B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
704B	  %44:gr64 = MOV32ri64 @.str.2
720B	  %45:gr8 = MOV8ri 1
736B	  $rdi = COPY %44:gr64
752B	  $xmm0 = COPY %43:fr64
768B	  $al = COPY %45:gr8
784B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
800B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
816B	  %46:gr32 = COPY $eax
832B	  %1:gr64 = nuw nsw ADD64ri8 %0:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
848B	  %47:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
864B	  %48:gr64 = SUB64rr %1:gr64(tied-def 0), killed %47:gr64, implicit-def $eflags
880B	  JCC_1 %bb.2, 12, implicit $eflags
896B	  JMP_1 %bb.3

912B	bb.3.for.end:
	; predecessors: %bb.0, %bb.2
	  successors: %bb.4(0x50000000), %bb.6(0x30000000); %bb.4(62.50%), %bb.6(37.50%)

928B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
944B	  %49:gr32 = MOV32ri 10
960B	  $edi = COPY %49:gr32
976B	  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
992B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1008B	  %50:gr32 = COPY $eax
1024B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1040B	  %51:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
1056B	  %52:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.4, $noreg :: (load 8 from constant-pool)
1072B	  %53:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.5, $noreg :: (load 8 from constant-pool)
1088B	  %54:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
1104B	  %55:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
1120B	  %56:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
1136B	  $xmm0 = COPY %51:fr64
1152B	  $xmm1 = COPY %52:fr64
1168B	  $xmm2 = COPY %53:fr64
1184B	  $xmm3 = COPY %54:fr64
1200B	  $rdi = COPY %55:gr64
1216B	  $rsi = COPY %56:gr64
1232B	  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
1248B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1264B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1280B	  %57:gr64 = MOV32ri64 @.str.1
1296B	  %58:gr32 = MOV32r0 implicit-def dead $eflags
1312B	  %59:gr8 = COPY %58.sub_8bit:gr32
1328B	  $rdi = COPY %57:gr64
1344B	  $al = COPY %59:gr8
1360B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
1376B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1392B	  %60:gr32 = COPY $eax
1408B	  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
1424B	  JCC_1 %bb.6, 14, implicit $eflags
1440B	  JMP_1 %bb.4

1456B	bb.4.for.body8.preheader:
	; predecessors: %bb.3
	  successors: %bb.5(0x80000000); %bb.5(100.00%)

1472B	  %62:gr32 = MOV32r0 implicit-def dead $eflags
1488B	  %61:gr64 = SUBREG_TO_REG 0, killed %62:gr32, %subreg.sub_32bit

1504B	bb.5.for.body8:
	; predecessors: %bb.4, %bb.5
	  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

1520B	  %2:gr64_nosp = PHI %61:gr64, %bb.4, %3:gr64, %bb.5
1536B	  %63:fr64 = MOVSDrm_alt %stack.0.x, 8, %2:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep5, !tbaa !5)
1552B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1568B	  %64:gr64 = MOV32ri64 @.str.2
1584B	  %65:gr8 = MOV8ri 1
1600B	  $rdi = COPY %64:gr64
1616B	  $xmm0 = COPY %63:fr64
1632B	  $al = COPY %65:gr8
1648B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
1664B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1680B	  %66:gr32 = COPY $eax
1696B	  %3:gr64 = nuw nsw ADD64ri8 %2:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
1712B	  %67:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
1728B	  %68:gr64 = SUB64rr %3:gr64(tied-def 0), killed %67:gr64, implicit-def $eflags
1744B	  JCC_1 %bb.5, 12, implicit $eflags
1760B	  JMP_1 %bb.6

1776B	bb.6.for.end14:
	; predecessors: %bb.3, %bb.5
	  successors: %bb.7(0x50000000), %bb.9(0x30000000); %bb.7(62.50%), %bb.9(37.50%)

1792B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1808B	  %69:gr32 = MOV32ri 10
1824B	  $edi = COPY %69:gr32
1840B	  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
1856B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1872B	  %70:gr32 = COPY $eax
1888B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1904B	  %71:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
1920B	  %72:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.6, $noreg :: (load 8 from constant-pool)
1936B	  %73:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.7, $noreg :: (load 8 from constant-pool)
1952B	  %74:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.8, $noreg :: (load 8 from constant-pool)
1968B	  %75:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
1984B	  %76:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
2000B	  $xmm0 = COPY %71:fr64
2016B	  $xmm1 = COPY %72:fr64
2032B	  $xmm2 = COPY %73:fr64
2048B	  $xmm3 = COPY %74:fr64
2064B	  $rdi = COPY %75:gr64
2080B	  $rsi = COPY %76:gr64
2096B	  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
2112B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2128B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2144B	  %77:gr64 = MOV32ri64 @.str.1
2160B	  %78:gr32 = MOV32r0 implicit-def dead $eflags
2176B	  %79:gr8 = COPY %78.sub_8bit:gr32
2192B	  $rdi = COPY %77:gr64
2208B	  $al = COPY %79:gr8
2224B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
2240B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2256B	  %80:gr32 = COPY $eax
2272B	  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
2288B	  JCC_1 %bb.9, 14, implicit $eflags
2304B	  JMP_1 %bb.7

2320B	bb.7.for.body20.preheader:
	; predecessors: %bb.6
	  successors: %bb.8(0x80000000); %bb.8(100.00%)

2336B	  %82:gr32 = MOV32r0 implicit-def dead $eflags
2352B	  %81:gr64 = SUBREG_TO_REG 0, killed %82:gr32, %subreg.sub_32bit

2368B	bb.8.for.body20:
	; predecessors: %bb.7, %bb.8
	  successors: %bb.8(0x7c000000), %bb.9(0x04000000); %bb.8(96.88%), %bb.9(3.12%)

2384B	  %4:gr64_nosp = PHI %81:gr64, %bb.7, %5:gr64, %bb.8
2400B	  %83:fr64 = MOVSDrm_alt %stack.0.x, 8, %4:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep4, !tbaa !5)
2416B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2432B	  %84:gr64 = MOV32ri64 @.str.2
2448B	  %85:gr8 = MOV8ri 1
2464B	  $rdi = COPY %84:gr64
2480B	  $xmm0 = COPY %83:fr64
2496B	  $al = COPY %85:gr8
2512B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
2528B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2544B	  %86:gr32 = COPY $eax
2560B	  %5:gr64 = nuw nsw ADD64ri8 %4:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
2576B	  %87:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
2592B	  %88:gr64 = SUB64rr %5:gr64(tied-def 0), killed %87:gr64, implicit-def $eflags
2608B	  JCC_1 %bb.8, 12, implicit $eflags
2624B	  JMP_1 %bb.9

2640B	bb.9.for.end26:
	; predecessors: %bb.6, %bb.8
	  successors: %bb.10(0x50000000), %bb.12(0x30000000); %bb.10(62.50%), %bb.12(37.50%)

2656B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2672B	  %89:gr32 = MOV32ri 10
2688B	  $edi = COPY %89:gr32
2704B	  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
2720B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2736B	  %90:gr32 = COPY $eax
2752B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2768B	  %91:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.9, $noreg :: (load 8 from constant-pool)
2784B	  %92:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
2800B	  %93:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.10, $noreg :: (load 8 from constant-pool)
2816B	  %94:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
2832B	  %95:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
2848B	  $xmm0 = COPY %92:fr64
2864B	  $xmm1 = COPY %91:fr64
2880B	  $xmm2 = COPY %92:fr64
2896B	  $xmm3 = COPY %93:fr64
2912B	  $rdi = COPY %94:gr64
2928B	  $rsi = COPY %95:gr64
2944B	  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
2960B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2976B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2992B	  %96:gr64 = MOV32ri64 @.str.1
3008B	  %97:gr32 = MOV32r0 implicit-def dead $eflags
3024B	  %98:gr8 = COPY %97.sub_8bit:gr32
3040B	  $rdi = COPY %96:gr64
3056B	  $al = COPY %98:gr8
3072B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
3088B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3104B	  %99:gr32 = COPY $eax
3120B	  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
3136B	  JCC_1 %bb.12, 14, implicit $eflags
3152B	  JMP_1 %bb.10

3168B	bb.10.for.body32.preheader:
	; predecessors: %bb.9
	  successors: %bb.11(0x80000000); %bb.11(100.00%)

3184B	  %101:gr32 = MOV32r0 implicit-def dead $eflags
3200B	  %100:gr64 = SUBREG_TO_REG 0, killed %101:gr32, %subreg.sub_32bit

3216B	bb.11.for.body32:
	; predecessors: %bb.10, %bb.11
	  successors: %bb.11(0x7c000000), %bb.12(0x04000000); %bb.11(96.88%), %bb.12(3.12%)

3232B	  %6:gr64_nosp = PHI %100:gr64, %bb.10, %7:gr64, %bb.11
3248B	  %102:fr64 = MOVSDrm_alt %stack.0.x, 8, %6:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep3, !tbaa !5)
3264B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3280B	  %103:gr64 = MOV32ri64 @.str.2
3296B	  %104:gr8 = MOV8ri 1
3312B	  $rdi = COPY %103:gr64
3328B	  $xmm0 = COPY %102:fr64
3344B	  $al = COPY %104:gr8
3360B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
3376B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3392B	  %105:gr32 = COPY $eax
3408B	  %7:gr64 = nuw nsw ADD64ri8 %6:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
3424B	  %106:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
3440B	  %107:gr64 = SUB64rr %7:gr64(tied-def 0), killed %106:gr64, implicit-def $eflags
3456B	  JCC_1 %bb.11, 12, implicit $eflags
3472B	  JMP_1 %bb.12

3488B	bb.12.for.end38:
	; predecessors: %bb.9, %bb.11
	  successors: %bb.13(0x80000000); %bb.13(100.00%)

3504B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3520B	  %110:gr32 = MOV32ri 10
3536B	  $edi = COPY %110:gr32
3552B	  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
3568B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3584B	  %111:gr32 = COPY $eax
3600B	  %109:gr32 = MOV32ri 1
3616B	  %108:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)

3632B	bb.13.for.cond43.preheader:
	; predecessors: %bb.12, %bb.22
	  successors: %bb.14(0x80000000); %bb.14(100.00%)

3648B	  %8:fr64 = PHI %108:fr64, %bb.12, %19:fr64, %bb.22
3664B	  %9:gr32 = PHI %109:gr32, %bb.12, %20:gr32, %bb.22
3680B	  %112:gr32 = MOV32ri 10

3696B	bb.14.for.cond46.preheader:
	; predecessors: %bb.13, %bb.21
	  successors: %bb.15(0x80000000); %bb.15(100.00%)

3712B	  %10:gr32 = PHI %112:gr32, %bb.13, %18:gr32, %bb.21
3728B	  %11:fr64 = CVTSI2SDrr %10:gr32
3744B	  %113:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.11, $noreg :: (load 8 from constant-pool)

3760B	bb.15.for.cond49.preheader:
	; predecessors: %bb.14, %bb.20
	  successors: %bb.16(0x80000000); %bb.16(100.00%)

3776B	  %12:fr64 = PHI %113:fr64, %bb.14, %17:fr64, %bb.20
3792B	  %114:gr32 = MOV32ri -1

3808B	bb.16.for.body51:
	; predecessors: %bb.15, %bb.19
	  successors: %bb.17(0x50000000), %bb.19(0x30000000); %bb.17(62.50%), %bb.19(37.50%)

3824B	  %13:gr32 = PHI %114:gr32, %bb.15, %16:gr32, %bb.19
3840B	  %115:fr64 = CVTSI2SDrr %13:gr32
3856B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
3872B	  %116:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
3888B	  %117:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
3904B	  $xmm0 = COPY %8:fr64
3920B	  $xmm1 = COPY %11:fr64
3936B	  $xmm2 = COPY %12:fr64
3952B	  $xmm3 = COPY %115:fr64
3968B	  $rdi = COPY %116:gr64
3984B	  $rsi = COPY %117:gr64
4000B	  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
4016B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4032B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4048B	  %118:gr64 = MOV32ri64 @.str.1
4064B	  %119:gr32 = MOV32r0 implicit-def dead $eflags
4080B	  %120:gr8 = COPY %119.sub_8bit:gr32
4096B	  $rdi = COPY %118:gr64
4112B	  $al = COPY %120:gr8
4128B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
4144B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4160B	  %121:gr32 = COPY $eax
4176B	  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
4192B	  JCC_1 %bb.19, 14, implicit $eflags
4208B	  JMP_1 %bb.17

4224B	bb.17.for.body56.preheader:
	; predecessors: %bb.16
	  successors: %bb.18(0x80000000); %bb.18(100.00%)

4240B	  %123:gr32 = MOV32r0 implicit-def dead $eflags
4256B	  %122:gr64 = SUBREG_TO_REG 0, killed %123:gr32, %subreg.sub_32bit

4272B	bb.18.for.body56:
	; predecessors: %bb.17, %bb.18
	  successors: %bb.18(0x7c000000), %bb.19(0x04000000); %bb.18(96.88%), %bb.19(3.12%)

4288B	  %14:gr64_nosp = PHI %122:gr64, %bb.17, %15:gr64, %bb.18
4304B	  %124:fr64 = MOVSDrm_alt %stack.0.x, 8, %14:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep, !tbaa !5)
4320B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4336B	  %125:gr64 = MOV32ri64 @.str.2
4352B	  %126:gr8 = MOV8ri 1
4368B	  $rdi = COPY %125:gr64
4384B	  $xmm0 = COPY %124:fr64
4400B	  $al = COPY %126:gr8
4416B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
4432B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4448B	  %127:gr32 = COPY $eax
4464B	  %15:gr64 = nuw nsw ADD64ri8 %14:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
4480B	  %128:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
4496B	  %129:gr64 = SUB64rr %15:gr64(tied-def 0), killed %128:gr64, implicit-def $eflags
4512B	  JCC_1 %bb.18, 12, implicit $eflags
4528B	  JMP_1 %bb.19

4544B	bb.19.for.end62:
	; predecessors: %bb.16, %bb.18
	  successors: %bb.16(0x7c000000), %bb.20(0x04000000); %bb.16(96.88%), %bb.20(3.12%)

4560B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4576B	  %130:gr32 = MOV32ri 10
4592B	  $edi = COPY %130:gr32
4608B	  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
4624B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
4640B	  %131:gr32 = COPY $eax
4656B	  %16:gr32 = nsw ADD32ri8 %13:gr32(tied-def 0), -1, implicit-def dead $eflags
4672B	  %132:gr32 = SUB32ri8 %16:gr32(tied-def 0), -11, implicit-def $eflags
4688B	  JCC_1 %bb.16, 15, implicit $eflags
4704B	  JMP_1 %bb.20

4720B	bb.20.for.inc66:
	; predecessors: %bb.19
	  successors: %bb.15(0x7c000000), %bb.21(0x04000000); %bb.15(96.88%), %bb.21(3.12%)

4736B	  %17:fr64 = nofpexcept ADDSDrm %12:fr64(tied-def 0), $rip, 1, $noreg, %const.12, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
4752B	  %133:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.13, $noreg :: (load 8 from constant-pool)
4768B	  nofpexcept UCOMISDrr killed %133:fr64, %17:fr64, implicit-def $eflags, implicit $mxcsr
4784B	  JCC_1 %bb.15, 7, implicit $eflags
4800B	  JMP_1 %bb.21

4816B	bb.21.for.inc68:
	; predecessors: %bb.20
	  successors: %bb.14(0x7c000000), %bb.22(0x04000000); %bb.14(96.88%), %bb.22(3.12%)

4832B	  %18:gr32 = nsw ADD32ri8 %10:gr32(tied-def 0), -1, implicit-def dead $eflags
4848B	  %134:gr32 = SUB32ri8 %10:gr32(tied-def 0), 1, implicit-def $eflags
4864B	  JCC_1 %bb.14, 15, implicit $eflags
4880B	  JMP_1 %bb.22

4896B	bb.22.for.inc71:
	; predecessors: %bb.21
	  successors: %bb.23(0x04000000), %bb.13(0x7c000000); %bb.23(3.12%), %bb.13(96.88%)

4912B	  %19:fr64 = nofpexcept ADDSDrm %8:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
4928B	  %20:gr32 = nuw nsw ADD32ri8 %9:gr32(tied-def 0), 1, implicit-def dead $eflags
4944B	  %135:gr32 = SUB32ri8 %20:gr32(tied-def 0), 10, implicit-def $eflags
4960B	  JCC_1 %bb.13, 5, implicit $eflags
4976B	  JMP_1 %bb.23

4992B	bb.23.for.end73:
	; predecessors: %bb.22
	  successors: %bb.24(0x80000000); %bb.24(100.00%)

5008B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5024B	  %137:gr64 = MOV32ri64 @str.11
5040B	  $rdi = COPY %137:gr64
5056B	  CALL64pcrel32 @puts, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
5072B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5088B	  %138:gr32 = COPY $eax
5104B	  %139:gr32 = MOV32r0 implicit-def dead $eflags
5120B	  %136:gr64 = SUBREG_TO_REG 0, killed %139:gr32, %subreg.sub_32bit

5136B	bb.24.for.body77:
	; predecessors: %bb.23, %bb.24
	  successors: %bb.25(0x04000000), %bb.24(0x7c000000); %bb.25(3.12%), %bb.24(96.88%)

5152B	  %21:gr64 = PHI %136:gr64, %bb.23, %22:gr64, %bb.24
5168B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5184B	  %140:gr64 = LEA64r %stack.2.q, 1, $noreg, 0, $noreg
5200B	  $rdi = COPY %21:gr64
5216B	  $rsi = COPY %140:gr64
5232B	  CALL64pcrel32 @usqrt, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
5248B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5264B	  %141:gr32 = MOV32rm %stack.2.q, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.27, align 8, !tbaa !9)
5280B	  %142:gr32 = COPY %21.sub_32bit:gr64
5296B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5312B	  %143:gr64 = MOV32ri64 @.str.5
5328B	  %144:gr32 = MOV32r0 implicit-def dead $eflags
5344B	  %145:gr8 = COPY %144.sub_8bit:gr32
5360B	  $rdi = COPY %143:gr64
5376B	  $esi = COPY %142:gr32
5392B	  $edx = COPY %141:gr32
5408B	  $al = COPY %145:gr8
5424B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit $edx, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
5440B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5456B	  %146:gr32 = COPY $eax
5472B	  %22:gr64 = nuw nsw ADD64ri8 %21:gr64(tied-def 0), 1, implicit-def dead $eflags
5488B	  %147:gr64 = SUB64ri32 %22:gr64(tied-def 0), 1001, implicit-def $eflags
5504B	  JCC_1 %bb.24, 5, implicit $eflags
5520B	  JMP_1 %bb.25

5536B	bb.25.for.end81:
	; predecessors: %bb.24
	  successors: %bb.26(0x80000000); %bb.26(100.00%)

5552B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5568B	  %150:gr64 = MOV32ri64 1072497001
5584B	  %151:gr64 = LEA64r %stack.2.q, 1, $noreg, 0, $noreg
5600B	  $rdi = COPY %150:gr64
5616B	  $rsi = COPY %151:gr64
5632B	  CALL64pcrel32 @usqrt, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
5648B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5664B	  %152:gr32 = MOV32rm %stack.2.q, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.29, align 8, !tbaa !9)
5680B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5696B	  %153:gr64 = MOV32ri64 @.str.6
5712B	  %154:gr32 = MOV32r0 implicit-def dead $eflags
5728B	  %155:gr8 = COPY %154.sub_8bit:gr32
5744B	  $rdi = COPY %153:gr64
5760B	  $rsi = COPY %150:gr64
5776B	  $edx = COPY %152:gr32
5792B	  $al = COPY %155:gr8
5808B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $edx, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
5824B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5840B	  %156:gr32 = COPY $eax
5856B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5872B	  %157:gr64 = MOV32ri64 @str.12
5888B	  $rdi = COPY %157:gr64
5904B	  CALL64pcrel32 @puts, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
5920B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
5936B	  %158:gr32 = COPY $eax
5952B	  %149:fr64 = FsFLD0SD
5968B	  %148:gr32 = MOV32ri 361

5984B	bb.26.for.body88:
	; predecessors: %bb.25, %bb.26
	  successors: %bb.27(0x04000000), %bb.26(0x7c000000); %bb.27(3.12%), %bb.26(96.88%)

6000B	  %23:gr32 = PHI %148:gr32, %bb.25, %26:gr32, %bb.26
6016B	  %24:fr64 = PHI %149:fr64, %bb.25, %25:fr64, %bb.26
6032B	  %159:fr64 = nofpexcept MULSDrm %24:fr64(tied-def 0), $rip, 1, $noreg, %const.14, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
6048B	  %160:fr64 = nofpexcept DIVSDrm %159:fr64(tied-def 0), $rip, 1, $noreg, %const.15, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
6064B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
6080B	  %161:gr64 = MOV32ri64 @.str.8
6096B	  %162:gr8 = MOV8ri 2
6112B	  $rdi = COPY %161:gr64
6128B	  $xmm0 = COPY %24:fr64
6144B	  $xmm1 = COPY %160:fr64
6160B	  $al = COPY %162:gr8
6176B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $xmm1, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
6192B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
6208B	  %163:gr32 = COPY $eax
6224B	  %25:fr64 = nofpexcept ADDSDrm %24:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
6240B	  %26:gr32 = ADD32ri8 %23:gr32(tied-def 0), -1, implicit-def $eflags
6256B	  JCC_1 %bb.26, 5, implicit $eflags
6272B	  JMP_1 %bb.27

6288B	bb.27.for.end94:
	; predecessors: %bb.26
	  successors: %bb.28(0x80000000); %bb.28(100.00%)

6304B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
6320B	  %165:gr64 = MOV32ri64 @.str.9
6336B	  %166:gr32 = MOV32r0 implicit-def dead $eflags
6352B	  %167:gr8 = COPY %166.sub_8bit:gr32
6368B	  $rdi = COPY %165:gr64
6384B	  $al = COPY %167:gr8
6400B	  CALL64pcrel32 @puts, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
6416B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
6432B	  %168:gr32 = COPY $eax
6448B	  %164:fr64 = FsFLD0SD

6464B	bb.28.for.body103:
	; predecessors: %bb.27, %bb.28
	  successors: %bb.29(0x04000000), %bb.28(0x7c000000); %bb.29(3.12%), %bb.28(96.88%)

6480B	  %27:fr64 = PHI %164:fr64, %bb.27, %28:fr64, %bb.28
6496B	  %169:fr64 = nofpexcept MULSDrm %27:fr64(tied-def 0), $rip, 1, $noreg, %const.15, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
6512B	  %170:fr64 = nofpexcept DIVSDrm %169:fr64(tied-def 0), $rip, 1, $noreg, %const.14, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
6528B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
6544B	  %171:gr64 = MOV32ri64 @.str.10
6560B	  %172:gr8 = MOV8ri 2
6576B	  $rdi = COPY %171:gr64
6592B	  $xmm0 = COPY %27:fr64
6608B	  $xmm1 = COPY %170:fr64
6624B	  $al = COPY %172:gr8
6640B	  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $xmm1, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
6656B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
6672B	  %173:gr32 = COPY $eax
6688B	  %28:fr64 = nofpexcept ADDSDrm %27:fr64(tied-def 0), $rip, 1, $noreg, %const.16, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
6704B	  %174:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.17, $noreg :: (load 8 from constant-pool)
6720B	  nofpexcept UCOMISDrr killed %174:fr64, %28:fr64, implicit-def $eflags, implicit $mxcsr
6736B	  JCC_1 %bb.28, 3, implicit $eflags
6752B	  JMP_1 %bb.29

6768B	bb.29.for.end114:
	; predecessors: %bb.28

6784B	  LIFETIME_END %stack.2.q
6800B	  LIFETIME_END %stack.1.solutions
6816B	  LIFETIME_END %stack.0.x
6832B	  %175:gr32 = MOV32r0 implicit-def dead $eflags
6848B	  $eax = COPY %175:gr32
6864B	  RET 0, $eax

# End machine code for function main.

# *** IR Dump After Merge disjoint stack slots ***:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=24, align=16, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
Constant Pool:
  cp#0: 1.000000e+00, align=8
  cp#1: -1.050000e+01, align=8
  cp#2: 3.200000e+01, align=8
  cp#3: -3.000000e+01, align=8
  cp#4: -4.500000e+00, align=8
  cp#5: 1.700000e+01, align=8
  cp#6: -3.500000e+00, align=8
  cp#7: 2.200000e+01, align=8
  cp#8: -3.100000e+01, align=8
  cp#9: -1.370000e+01, align=8
  cp#10: -3.500000e+01, align=8
  cp#11: 5.000000e+00, align=8
  cp#12: 5.000000e-01, align=8
  cp#13: 1.500000e+01, align=8
  cp#14: 0x400921FB54442D18, align=8
  cp#15: 1.800000e+02, align=8
  cp#16: 0x3F91DF46A2529D39, align=8
  cp#17: 0x401921FB97600B9B, align=8

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.3(0x30000000); %bb.1(62.50%), %bb.3(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %29:gr64 = MOV32ri64 @str
  $rdi = COPY %29:gr64
  CALL64pcrel32 @puts, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %30:gr32 = COPY $eax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %31:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %32:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
  %33:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
  %34:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
  %35:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %36:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %31:fr64
  $xmm1 = COPY %32:fr64
  $xmm2 = COPY %33:fr64
  $xmm3 = COPY %34:fr64
  $rdi = COPY %35:gr64
  $rsi = COPY %36:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %37:gr64 = MOV32ri64 @.str.1
  %38:gr32 = MOV32r0 implicit-def dead $eflags
  %39:gr8 = COPY %38.sub_8bit:gr32
  $rdi = COPY %37:gr64
  $al = COPY %39:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %40:gr32 = COPY $eax
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.3, 14, implicit $eflags
  JMP_1 %bb.1

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  %42:gr32 = MOV32r0 implicit-def dead $eflags
  %41:gr64 = SUBREG_TO_REG 0, killed %42:gr32, %subreg.sub_32bit

bb.2.for.body:
; predecessors: %bb.1, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  %0:gr64_nosp = PHI %41:gr64, %bb.1, %1:gr64, %bb.2
  %43:fr64 = MOVSDrm_alt %stack.0.x, 8, %0:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep6, !tbaa !5)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %44:gr64 = MOV32ri64 @.str.2
  %45:gr8 = MOV8ri 1
  $rdi = COPY %44:gr64
  $xmm0 = COPY %43:fr64
  $al = COPY %45:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %46:gr32 = COPY $eax
  %1:gr64 = nuw nsw ADD64ri8 %0:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
  %47:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  %48:gr64 = SUB64rr %1:gr64(tied-def 0), killed %47:gr64, implicit-def $eflags
  JCC_1 %bb.2, 12, implicit $eflags
  JMP_1 %bb.3

bb.3.for.end:
; predecessors: %bb.0, %bb.2
  successors: %bb.4(0x50000000), %bb.6(0x30000000); %bb.4(62.50%), %bb.6(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %49:gr32 = MOV32ri 10
  $edi = COPY %49:gr32
  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %50:gr32 = COPY $eax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %51:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %52:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.4, $noreg :: (load 8 from constant-pool)
  %53:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.5, $noreg :: (load 8 from constant-pool)
  %54:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
  %55:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %56:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %51:fr64
  $xmm1 = COPY %52:fr64
  $xmm2 = COPY %53:fr64
  $xmm3 = COPY %54:fr64
  $rdi = COPY %55:gr64
  $rsi = COPY %56:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %57:gr64 = MOV32ri64 @.str.1
  %58:gr32 = MOV32r0 implicit-def dead $eflags
  %59:gr8 = COPY %58.sub_8bit:gr32
  $rdi = COPY %57:gr64
  $al = COPY %59:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %60:gr32 = COPY $eax
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.6, 14, implicit $eflags
  JMP_1 %bb.4

bb.4.for.body8.preheader:
; predecessors: %bb.3
  successors: %bb.5(0x80000000); %bb.5(100.00%)

  %62:gr32 = MOV32r0 implicit-def dead $eflags
  %61:gr64 = SUBREG_TO_REG 0, killed %62:gr32, %subreg.sub_32bit

bb.5.for.body8:
; predecessors: %bb.4, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  %2:gr64_nosp = PHI %61:gr64, %bb.4, %3:gr64, %bb.5
  %63:fr64 = MOVSDrm_alt %stack.0.x, 8, %2:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep5, !tbaa !5)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %64:gr64 = MOV32ri64 @.str.2
  %65:gr8 = MOV8ri 1
  $rdi = COPY %64:gr64
  $xmm0 = COPY %63:fr64
  $al = COPY %65:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %66:gr32 = COPY $eax
  %3:gr64 = nuw nsw ADD64ri8 %2:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
  %67:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  %68:gr64 = SUB64rr %3:gr64(tied-def 0), killed %67:gr64, implicit-def $eflags
  JCC_1 %bb.5, 12, implicit $eflags
  JMP_1 %bb.6

bb.6.for.end14:
; predecessors: %bb.3, %bb.5
  successors: %bb.7(0x50000000), %bb.9(0x30000000); %bb.7(62.50%), %bb.9(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %69:gr32 = MOV32ri 10
  $edi = COPY %69:gr32
  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %70:gr32 = COPY $eax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %71:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %72:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.6, $noreg :: (load 8 from constant-pool)
  %73:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.7, $noreg :: (load 8 from constant-pool)
  %74:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.8, $noreg :: (load 8 from constant-pool)
  %75:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %76:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %71:fr64
  $xmm1 = COPY %72:fr64
  $xmm2 = COPY %73:fr64
  $xmm3 = COPY %74:fr64
  $rdi = COPY %75:gr64
  $rsi = COPY %76:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %77:gr64 = MOV32ri64 @.str.1
  %78:gr32 = MOV32r0 implicit-def dead $eflags
  %79:gr8 = COPY %78.sub_8bit:gr32
  $rdi = COPY %77:gr64
  $al = COPY %79:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %80:gr32 = COPY $eax
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.9, 14, implicit $eflags
  JMP_1 %bb.7

bb.7.for.body20.preheader:
; predecessors: %bb.6
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  %82:gr32 = MOV32r0 implicit-def dead $eflags
  %81:gr64 = SUBREG_TO_REG 0, killed %82:gr32, %subreg.sub_32bit

bb.8.for.body20:
; predecessors: %bb.7, %bb.8
  successors: %bb.8(0x7c000000), %bb.9(0x04000000); %bb.8(96.88%), %bb.9(3.12%)

  %4:gr64_nosp = PHI %81:gr64, %bb.7, %5:gr64, %bb.8
  %83:fr64 = MOVSDrm_alt %stack.0.x, 8, %4:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep4, !tbaa !5)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %84:gr64 = MOV32ri64 @.str.2
  %85:gr8 = MOV8ri 1
  $rdi = COPY %84:gr64
  $xmm0 = COPY %83:fr64
  $al = COPY %85:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %86:gr32 = COPY $eax
  %5:gr64 = nuw nsw ADD64ri8 %4:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
  %87:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  %88:gr64 = SUB64rr %5:gr64(tied-def 0), killed %87:gr64, implicit-def $eflags
  JCC_1 %bb.8, 12, implicit $eflags
  JMP_1 %bb.9

bb.9.for.end26:
; predecessors: %bb.6, %bb.8
  successors: %bb.10(0x50000000), %bb.12(0x30000000); %bb.10(62.50%), %bb.12(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %89:gr32 = MOV32ri 10
  $edi = COPY %89:gr32
  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %90:gr32 = COPY $eax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %91:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.9, $noreg :: (load 8 from constant-pool)
  %92:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %93:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.10, $noreg :: (load 8 from constant-pool)
  %94:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %95:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %92:fr64
  $xmm1 = COPY %91:fr64
  $xmm2 = COPY %92:fr64
  $xmm3 = COPY %93:fr64
  $rdi = COPY %94:gr64
  $rsi = COPY %95:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %96:gr64 = MOV32ri64 @.str.1
  %97:gr32 = MOV32r0 implicit-def dead $eflags
  %98:gr8 = COPY %97.sub_8bit:gr32
  $rdi = COPY %96:gr64
  $al = COPY %98:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %99:gr32 = COPY $eax
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.12, 14, implicit $eflags
  JMP_1 %bb.10

bb.10.for.body32.preheader:
; predecessors: %bb.9
  successors: %bb.11(0x80000000); %bb.11(100.00%)

  %101:gr32 = MOV32r0 implicit-def dead $eflags
  %100:gr64 = SUBREG_TO_REG 0, killed %101:gr32, %subreg.sub_32bit

bb.11.for.body32:
; predecessors: %bb.10, %bb.11
  successors: %bb.11(0x7c000000), %bb.12(0x04000000); %bb.11(96.88%), %bb.12(3.12%)

  %6:gr64_nosp = PHI %100:gr64, %bb.10, %7:gr64, %bb.11
  %102:fr64 = MOVSDrm_alt %stack.0.x, 8, %6:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep3, !tbaa !5)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %103:gr64 = MOV32ri64 @.str.2
  %104:gr8 = MOV8ri 1
  $rdi = COPY %103:gr64
  $xmm0 = COPY %102:fr64
  $al = COPY %104:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %105:gr32 = COPY $eax
  %7:gr64 = nuw nsw ADD64ri8 %6:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
  %106:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  %107:gr64 = SUB64rr %7:gr64(tied-def 0), killed %106:gr64, implicit-def $eflags
  JCC_1 %bb.11, 12, implicit $eflags
  JMP_1 %bb.12

bb.12.for.end38:
; predecessors: %bb.9, %bb.11
  successors: %bb.13(0x80000000); %bb.13(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %110:gr32 = MOV32ri 10
  $edi = COPY %110:gr32
  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %111:gr32 = COPY $eax
  %109:gr32 = MOV32ri 1
  %108:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)

bb.13.for.cond43.preheader:
; predecessors: %bb.12, %bb.22
  successors: %bb.14(0x80000000); %bb.14(100.00%)

  %8:fr64 = PHI %108:fr64, %bb.12, %19:fr64, %bb.22
  %9:gr32 = PHI %109:gr32, %bb.12, %20:gr32, %bb.22
  %112:gr32 = MOV32ri 10

bb.14.for.cond46.preheader:
; predecessors: %bb.13, %bb.21
  successors: %bb.15(0x80000000); %bb.15(100.00%)

  %10:gr32 = PHI %112:gr32, %bb.13, %18:gr32, %bb.21
  %11:fr64 = CVTSI2SDrr %10:gr32
  %113:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.11, $noreg :: (load 8 from constant-pool)

bb.15.for.cond49.preheader:
; predecessors: %bb.14, %bb.20
  successors: %bb.16(0x80000000); %bb.16(100.00%)

  %12:fr64 = PHI %113:fr64, %bb.14, %17:fr64, %bb.20
  %114:gr32 = MOV32ri -1

bb.16.for.body51:
; predecessors: %bb.15, %bb.19
  successors: %bb.17(0x50000000), %bb.19(0x30000000); %bb.17(62.50%), %bb.19(37.50%)

  %13:gr32 = PHI %114:gr32, %bb.15, %16:gr32, %bb.19
  %115:fr64 = CVTSI2SDrr %13:gr32
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %116:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %117:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %8:fr64
  $xmm1 = COPY %11:fr64
  $xmm2 = COPY %12:fr64
  $xmm3 = COPY %115:fr64
  $rdi = COPY %116:gr64
  $rsi = COPY %117:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %118:gr64 = MOV32ri64 @.str.1
  %119:gr32 = MOV32r0 implicit-def dead $eflags
  %120:gr8 = COPY %119.sub_8bit:gr32
  $rdi = COPY %118:gr64
  $al = COPY %120:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %121:gr32 = COPY $eax
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.19, 14, implicit $eflags
  JMP_1 %bb.17

bb.17.for.body56.preheader:
; predecessors: %bb.16
  successors: %bb.18(0x80000000); %bb.18(100.00%)

  %123:gr32 = MOV32r0 implicit-def dead $eflags
  %122:gr64 = SUBREG_TO_REG 0, killed %123:gr32, %subreg.sub_32bit

bb.18.for.body56:
; predecessors: %bb.17, %bb.18
  successors: %bb.18(0x7c000000), %bb.19(0x04000000); %bb.18(96.88%), %bb.19(3.12%)

  %14:gr64_nosp = PHI %122:gr64, %bb.17, %15:gr64, %bb.18
  %124:fr64 = MOVSDrm_alt %stack.0.x, 8, %14:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep, !tbaa !5)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %125:gr64 = MOV32ri64 @.str.2
  %126:gr8 = MOV8ri 1
  $rdi = COPY %125:gr64
  $xmm0 = COPY %124:fr64
  $al = COPY %126:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %127:gr32 = COPY $eax
  %15:gr64 = nuw nsw ADD64ri8 %14:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
  %128:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  %129:gr64 = SUB64rr %15:gr64(tied-def 0), killed %128:gr64, implicit-def $eflags
  JCC_1 %bb.18, 12, implicit $eflags
  JMP_1 %bb.19

bb.19.for.end62:
; predecessors: %bb.16, %bb.18
  successors: %bb.16(0x7c000000), %bb.20(0x04000000); %bb.16(96.88%), %bb.20(3.12%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %130:gr32 = MOV32ri 10
  $edi = COPY %130:gr32
  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %131:gr32 = COPY $eax
  %16:gr32 = nsw ADD32ri8 %13:gr32(tied-def 0), -1, implicit-def dead $eflags
  %132:gr32 = SUB32ri8 %16:gr32(tied-def 0), -11, implicit-def $eflags
  JCC_1 %bb.16, 15, implicit $eflags
  JMP_1 %bb.20

bb.20.for.inc66:
; predecessors: %bb.19
  successors: %bb.15(0x7c000000), %bb.21(0x04000000); %bb.15(96.88%), %bb.21(3.12%)

  %17:fr64 = nofpexcept ADDSDrm %12:fr64(tied-def 0), $rip, 1, $noreg, %const.12, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %133:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.13, $noreg :: (load 8 from constant-pool)
  nofpexcept UCOMISDrr killed %133:fr64, %17:fr64, implicit-def $eflags, implicit $mxcsr
  JCC_1 %bb.15, 7, implicit $eflags
  JMP_1 %bb.21

bb.21.for.inc68:
; predecessors: %bb.20
  successors: %bb.14(0x7c000000), %bb.22(0x04000000); %bb.14(96.88%), %bb.22(3.12%)

  %18:gr32 = nsw ADD32ri8 %10:gr32(tied-def 0), -1, implicit-def dead $eflags
  %134:gr32 = SUB32ri8 %10:gr32(tied-def 0), 1, implicit-def $eflags
  JCC_1 %bb.14, 15, implicit $eflags
  JMP_1 %bb.22

bb.22.for.inc71:
; predecessors: %bb.21
  successors: %bb.23(0x04000000), %bb.13(0x7c000000); %bb.23(3.12%), %bb.13(96.88%)

  %19:fr64 = nofpexcept ADDSDrm %8:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %20:gr32 = nuw nsw ADD32ri8 %9:gr32(tied-def 0), 1, implicit-def dead $eflags
  %135:gr32 = SUB32ri8 %20:gr32(tied-def 0), 10, implicit-def $eflags
  JCC_1 %bb.13, 5, implicit $eflags
  JMP_1 %bb.23

bb.23.for.end73:
; predecessors: %bb.22
  successors: %bb.24(0x80000000); %bb.24(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %137:gr64 = MOV32ri64 @str.11
  $rdi = COPY %137:gr64
  CALL64pcrel32 @puts, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %138:gr32 = COPY $eax
  %139:gr32 = MOV32r0 implicit-def dead $eflags
  %136:gr64 = SUBREG_TO_REG 0, killed %139:gr32, %subreg.sub_32bit

bb.24.for.body77:
; predecessors: %bb.23, %bb.24
  successors: %bb.25(0x04000000), %bb.24(0x7c000000); %bb.25(3.12%), %bb.24(96.88%)

  %21:gr64 = PHI %136:gr64, %bb.23, %22:gr64, %bb.24
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %140:gr64 = LEA64r %stack.2.q, 1, $noreg, 0, $noreg
  $rdi = COPY %21:gr64
  $rsi = COPY %140:gr64
  CALL64pcrel32 @usqrt, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %141:gr32 = MOV32rm %stack.2.q, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.27, align 8, !tbaa !9)
  %142:gr32 = COPY %21.sub_32bit:gr64
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %143:gr64 = MOV32ri64 @.str.5
  %144:gr32 = MOV32r0 implicit-def dead $eflags
  %145:gr8 = COPY %144.sub_8bit:gr32
  $rdi = COPY %143:gr64
  $esi = COPY %142:gr32
  $edx = COPY %141:gr32
  $al = COPY %145:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit $edx, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %146:gr32 = COPY $eax
  %22:gr64 = nuw nsw ADD64ri8 %21:gr64(tied-def 0), 1, implicit-def dead $eflags
  %147:gr64 = SUB64ri32 %22:gr64(tied-def 0), 1001, implicit-def $eflags
  JCC_1 %bb.24, 5, implicit $eflags
  JMP_1 %bb.25

bb.25.for.end81:
; predecessors: %bb.24
  successors: %bb.26(0x80000000); %bb.26(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %150:gr64 = MOV32ri64 1072497001
  %151:gr64 = LEA64r %stack.2.q, 1, $noreg, 0, $noreg
  $rdi = COPY %150:gr64
  $rsi = COPY %151:gr64
  CALL64pcrel32 @usqrt, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %152:gr32 = MOV32rm %stack.2.q, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.29, align 8, !tbaa !9)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %153:gr64 = MOV32ri64 @.str.6
  %154:gr32 = MOV32r0 implicit-def dead $eflags
  %155:gr8 = COPY %154.sub_8bit:gr32
  $rdi = COPY %153:gr64
  $rsi = COPY %150:gr64
  $edx = COPY %152:gr32
  $al = COPY %155:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $edx, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %156:gr32 = COPY $eax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %157:gr64 = MOV32ri64 @str.12
  $rdi = COPY %157:gr64
  CALL64pcrel32 @puts, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %158:gr32 = COPY $eax
  %149:fr64 = FsFLD0SD
  %148:gr32 = MOV32ri 361

bb.26.for.body88:
; predecessors: %bb.25, %bb.26
  successors: %bb.27(0x04000000), %bb.26(0x7c000000); %bb.27(3.12%), %bb.26(96.88%)

  %23:gr32 = PHI %148:gr32, %bb.25, %26:gr32, %bb.26
  %24:fr64 = PHI %149:fr64, %bb.25, %25:fr64, %bb.26
  %159:fr64 = nofpexcept MULSDrm %24:fr64(tied-def 0), $rip, 1, $noreg, %const.14, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %160:fr64 = nofpexcept DIVSDrm %159:fr64(tied-def 0), $rip, 1, $noreg, %const.15, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %161:gr64 = MOV32ri64 @.str.8
  %162:gr8 = MOV8ri 2
  $rdi = COPY %161:gr64
  $xmm0 = COPY %24:fr64
  $xmm1 = COPY %160:fr64
  $al = COPY %162:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $xmm1, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %163:gr32 = COPY $eax
  %25:fr64 = nofpexcept ADDSDrm %24:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %26:gr32 = ADD32ri8 %23:gr32(tied-def 0), -1, implicit-def $eflags
  JCC_1 %bb.26, 5, implicit $eflags
  JMP_1 %bb.27

bb.27.for.end94:
; predecessors: %bb.26
  successors: %bb.28(0x80000000); %bb.28(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %165:gr64 = MOV32ri64 @.str.9
  %166:gr32 = MOV32r0 implicit-def dead $eflags
  %167:gr8 = COPY %166.sub_8bit:gr32
  $rdi = COPY %165:gr64
  $al = COPY %167:gr8
  CALL64pcrel32 @puts, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %168:gr32 = COPY $eax
  %164:fr64 = FsFLD0SD

bb.28.for.body103:
; predecessors: %bb.27, %bb.28
  successors: %bb.29(0x04000000), %bb.28(0x7c000000); %bb.29(3.12%), %bb.28(96.88%)

  %27:fr64 = PHI %164:fr64, %bb.27, %28:fr64, %bb.28
  %169:fr64 = nofpexcept MULSDrm %27:fr64(tied-def 0), $rip, 1, $noreg, %const.15, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %170:fr64 = nofpexcept DIVSDrm %169:fr64(tied-def 0), $rip, 1, $noreg, %const.14, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %171:gr64 = MOV32ri64 @.str.10
  %172:gr8 = MOV8ri 2
  $rdi = COPY %171:gr64
  $xmm0 = COPY %27:fr64
  $xmm1 = COPY %170:fr64
  $al = COPY %172:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $xmm1, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %173:gr32 = COPY $eax
  %28:fr64 = nofpexcept ADDSDrm %27:fr64(tied-def 0), $rip, 1, $noreg, %const.16, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %174:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.17, $noreg :: (load 8 from constant-pool)
  nofpexcept UCOMISDrr killed %174:fr64, %28:fr64, implicit-def $eflags, implicit $mxcsr
  JCC_1 %bb.28, 3, implicit $eflags
  JMP_1 %bb.29

bb.29.for.end114:
; predecessors: %bb.28

  %175:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY %175:gr32
  RET 0, $eax

# End machine code for function main.

# *** IR Dump After Local Stack Slot Allocation ***:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=24, align=16, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
Constant Pool:
  cp#0: 1.000000e+00, align=8
  cp#1: -1.050000e+01, align=8
  cp#2: 3.200000e+01, align=8
  cp#3: -3.000000e+01, align=8
  cp#4: -4.500000e+00, align=8
  cp#5: 1.700000e+01, align=8
  cp#6: -3.500000e+00, align=8
  cp#7: 2.200000e+01, align=8
  cp#8: -3.100000e+01, align=8
  cp#9: -1.370000e+01, align=8
  cp#10: -3.500000e+01, align=8
  cp#11: 5.000000e+00, align=8
  cp#12: 5.000000e-01, align=8
  cp#13: 1.500000e+01, align=8
  cp#14: 0x400921FB54442D18, align=8
  cp#15: 1.800000e+02, align=8
  cp#16: 0x3F91DF46A2529D39, align=8
  cp#17: 0x401921FB97600B9B, align=8

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.3(0x30000000); %bb.1(62.50%), %bb.3(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %29:gr64 = MOV32ri64 @str
  $rdi = COPY %29:gr64
  CALL64pcrel32 @puts, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %30:gr32 = COPY $eax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %31:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %32:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
  %33:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
  %34:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
  %35:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %36:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %31:fr64
  $xmm1 = COPY %32:fr64
  $xmm2 = COPY %33:fr64
  $xmm3 = COPY %34:fr64
  $rdi = COPY %35:gr64
  $rsi = COPY %36:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %37:gr64 = MOV32ri64 @.str.1
  %38:gr32 = MOV32r0 implicit-def dead $eflags
  %39:gr8 = COPY %38.sub_8bit:gr32
  $rdi = COPY %37:gr64
  $al = COPY %39:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %40:gr32 = COPY $eax
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.3, 14, implicit $eflags
  JMP_1 %bb.1

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  %42:gr32 = MOV32r0 implicit-def dead $eflags
  %41:gr64 = SUBREG_TO_REG 0, killed %42:gr32, %subreg.sub_32bit

bb.2.for.body:
; predecessors: %bb.1, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  %0:gr64_nosp = PHI %41:gr64, %bb.1, %1:gr64, %bb.2
  %43:fr64 = MOVSDrm_alt %stack.0.x, 8, %0:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep6, !tbaa !5)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %44:gr64 = MOV32ri64 @.str.2
  %45:gr8 = MOV8ri 1
  $rdi = COPY %44:gr64
  $xmm0 = COPY %43:fr64
  $al = COPY %45:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %46:gr32 = COPY $eax
  %1:gr64 = nuw nsw ADD64ri8 %0:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
  %47:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  %48:gr64 = SUB64rr %1:gr64(tied-def 0), killed %47:gr64, implicit-def $eflags
  JCC_1 %bb.2, 12, implicit $eflags
  JMP_1 %bb.3

bb.3.for.end:
; predecessors: %bb.0, %bb.2
  successors: %bb.4(0x50000000), %bb.6(0x30000000); %bb.4(62.50%), %bb.6(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %49:gr32 = MOV32ri 10
  $edi = COPY %49:gr32
  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %50:gr32 = COPY $eax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %51:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %52:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.4, $noreg :: (load 8 from constant-pool)
  %53:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.5, $noreg :: (load 8 from constant-pool)
  %54:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
  %55:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %56:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %51:fr64
  $xmm1 = COPY %52:fr64
  $xmm2 = COPY %53:fr64
  $xmm3 = COPY %54:fr64
  $rdi = COPY %55:gr64
  $rsi = COPY %56:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %57:gr64 = MOV32ri64 @.str.1
  %58:gr32 = MOV32r0 implicit-def dead $eflags
  %59:gr8 = COPY %58.sub_8bit:gr32
  $rdi = COPY %57:gr64
  $al = COPY %59:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %60:gr32 = COPY $eax
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.6, 14, implicit $eflags
  JMP_1 %bb.4

bb.4.for.body8.preheader:
; predecessors: %bb.3
  successors: %bb.5(0x80000000); %bb.5(100.00%)

  %62:gr32 = MOV32r0 implicit-def dead $eflags
  %61:gr64 = SUBREG_TO_REG 0, killed %62:gr32, %subreg.sub_32bit

bb.5.for.body8:
; predecessors: %bb.4, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  %2:gr64_nosp = PHI %61:gr64, %bb.4, %3:gr64, %bb.5
  %63:fr64 = MOVSDrm_alt %stack.0.x, 8, %2:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep5, !tbaa !5)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %64:gr64 = MOV32ri64 @.str.2
  %65:gr8 = MOV8ri 1
  $rdi = COPY %64:gr64
  $xmm0 = COPY %63:fr64
  $al = COPY %65:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %66:gr32 = COPY $eax
  %3:gr64 = nuw nsw ADD64ri8 %2:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
  %67:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  %68:gr64 = SUB64rr %3:gr64(tied-def 0), killed %67:gr64, implicit-def $eflags
  JCC_1 %bb.5, 12, implicit $eflags
  JMP_1 %bb.6

bb.6.for.end14:
; predecessors: %bb.3, %bb.5
  successors: %bb.7(0x50000000), %bb.9(0x30000000); %bb.7(62.50%), %bb.9(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %69:gr32 = MOV32ri 10
  $edi = COPY %69:gr32
  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %70:gr32 = COPY $eax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %71:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %72:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.6, $noreg :: (load 8 from constant-pool)
  %73:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.7, $noreg :: (load 8 from constant-pool)
  %74:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.8, $noreg :: (load 8 from constant-pool)
  %75:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %76:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %71:fr64
  $xmm1 = COPY %72:fr64
  $xmm2 = COPY %73:fr64
  $xmm3 = COPY %74:fr64
  $rdi = COPY %75:gr64
  $rsi = COPY %76:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %77:gr64 = MOV32ri64 @.str.1
  %78:gr32 = MOV32r0 implicit-def dead $eflags
  %79:gr8 = COPY %78.sub_8bit:gr32
  $rdi = COPY %77:gr64
  $al = COPY %79:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %80:gr32 = COPY $eax
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.9, 14, implicit $eflags
  JMP_1 %bb.7

bb.7.for.body20.preheader:
; predecessors: %bb.6
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  %82:gr32 = MOV32r0 implicit-def dead $eflags
  %81:gr64 = SUBREG_TO_REG 0, killed %82:gr32, %subreg.sub_32bit

bb.8.for.body20:
; predecessors: %bb.7, %bb.8
  successors: %bb.8(0x7c000000), %bb.9(0x04000000); %bb.8(96.88%), %bb.9(3.12%)

  %4:gr64_nosp = PHI %81:gr64, %bb.7, %5:gr64, %bb.8
  %83:fr64 = MOVSDrm_alt %stack.0.x, 8, %4:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep4, !tbaa !5)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %84:gr64 = MOV32ri64 @.str.2
  %85:gr8 = MOV8ri 1
  $rdi = COPY %84:gr64
  $xmm0 = COPY %83:fr64
  $al = COPY %85:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %86:gr32 = COPY $eax
  %5:gr64 = nuw nsw ADD64ri8 %4:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
  %87:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  %88:gr64 = SUB64rr %5:gr64(tied-def 0), killed %87:gr64, implicit-def $eflags
  JCC_1 %bb.8, 12, implicit $eflags
  JMP_1 %bb.9

bb.9.for.end26:
; predecessors: %bb.6, %bb.8
  successors: %bb.10(0x50000000), %bb.12(0x30000000); %bb.10(62.50%), %bb.12(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %89:gr32 = MOV32ri 10
  $edi = COPY %89:gr32
  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %90:gr32 = COPY $eax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %91:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.9, $noreg :: (load 8 from constant-pool)
  %92:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %93:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.10, $noreg :: (load 8 from constant-pool)
  %94:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %95:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %92:fr64
  $xmm1 = COPY %91:fr64
  $xmm2 = COPY %92:fr64
  $xmm3 = COPY %93:fr64
  $rdi = COPY %94:gr64
  $rsi = COPY %95:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %96:gr64 = MOV32ri64 @.str.1
  %97:gr32 = MOV32r0 implicit-def dead $eflags
  %98:gr8 = COPY %97.sub_8bit:gr32
  $rdi = COPY %96:gr64
  $al = COPY %98:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %99:gr32 = COPY $eax
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.12, 14, implicit $eflags
  JMP_1 %bb.10

bb.10.for.body32.preheader:
; predecessors: %bb.9
  successors: %bb.11(0x80000000); %bb.11(100.00%)

  %101:gr32 = MOV32r0 implicit-def dead $eflags
  %100:gr64 = SUBREG_TO_REG 0, killed %101:gr32, %subreg.sub_32bit

bb.11.for.body32:
; predecessors: %bb.10, %bb.11
  successors: %bb.11(0x7c000000), %bb.12(0x04000000); %bb.11(96.88%), %bb.12(3.12%)

  %6:gr64_nosp = PHI %100:gr64, %bb.10, %7:gr64, %bb.11
  %102:fr64 = MOVSDrm_alt %stack.0.x, 8, %6:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep3, !tbaa !5)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %103:gr64 = MOV32ri64 @.str.2
  %104:gr8 = MOV8ri 1
  $rdi = COPY %103:gr64
  $xmm0 = COPY %102:fr64
  $al = COPY %104:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %105:gr32 = COPY $eax
  %7:gr64 = nuw nsw ADD64ri8 %6:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
  %106:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  %107:gr64 = SUB64rr %7:gr64(tied-def 0), killed %106:gr64, implicit-def $eflags
  JCC_1 %bb.11, 12, implicit $eflags
  JMP_1 %bb.12

bb.12.for.end38:
; predecessors: %bb.9, %bb.11
  successors: %bb.13(0x80000000); %bb.13(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %110:gr32 = MOV32ri 10
  $edi = COPY %110:gr32
  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %111:gr32 = COPY $eax
  %109:gr32 = MOV32ri 1
  %108:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)

bb.13.for.cond43.preheader:
; predecessors: %bb.12, %bb.22
  successors: %bb.14(0x80000000); %bb.14(100.00%)

  %8:fr64 = PHI %108:fr64, %bb.12, %19:fr64, %bb.22
  %9:gr32 = PHI %109:gr32, %bb.12, %20:gr32, %bb.22
  %112:gr32 = MOV32ri 10

bb.14.for.cond46.preheader:
; predecessors: %bb.13, %bb.21
  successors: %bb.15(0x80000000); %bb.15(100.00%)

  %10:gr32 = PHI %112:gr32, %bb.13, %18:gr32, %bb.21
  %11:fr64 = CVTSI2SDrr %10:gr32
  %113:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.11, $noreg :: (load 8 from constant-pool)

bb.15.for.cond49.preheader:
; predecessors: %bb.14, %bb.20
  successors: %bb.16(0x80000000); %bb.16(100.00%)

  %12:fr64 = PHI %113:fr64, %bb.14, %17:fr64, %bb.20
  %114:gr32 = MOV32ri -1

bb.16.for.body51:
; predecessors: %bb.15, %bb.19
  successors: %bb.17(0x50000000), %bb.19(0x30000000); %bb.17(62.50%), %bb.19(37.50%)

  %13:gr32 = PHI %114:gr32, %bb.15, %16:gr32, %bb.19
  %115:fr64 = CVTSI2SDrr %13:gr32
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %116:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %117:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %8:fr64
  $xmm1 = COPY %11:fr64
  $xmm2 = COPY %12:fr64
  $xmm3 = COPY %115:fr64
  $rdi = COPY %116:gr64
  $rsi = COPY %117:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %118:gr64 = MOV32ri64 @.str.1
  %119:gr32 = MOV32r0 implicit-def dead $eflags
  %120:gr8 = COPY %119.sub_8bit:gr32
  $rdi = COPY %118:gr64
  $al = COPY %120:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %121:gr32 = COPY $eax
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.19, 14, implicit $eflags
  JMP_1 %bb.17

bb.17.for.body56.preheader:
; predecessors: %bb.16
  successors: %bb.18(0x80000000); %bb.18(100.00%)

  %123:gr32 = MOV32r0 implicit-def dead $eflags
  %122:gr64 = SUBREG_TO_REG 0, killed %123:gr32, %subreg.sub_32bit

bb.18.for.body56:
; predecessors: %bb.17, %bb.18
  successors: %bb.18(0x7c000000), %bb.19(0x04000000); %bb.18(96.88%), %bb.19(3.12%)

  %14:gr64_nosp = PHI %122:gr64, %bb.17, %15:gr64, %bb.18
  %124:fr64 = MOVSDrm_alt %stack.0.x, 8, %14:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep, !tbaa !5)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %125:gr64 = MOV32ri64 @.str.2
  %126:gr8 = MOV8ri 1
  $rdi = COPY %125:gr64
  $xmm0 = COPY %124:fr64
  $al = COPY %126:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %127:gr32 = COPY $eax
  %15:gr64 = nuw nsw ADD64ri8 %14:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
  %128:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  %129:gr64 = SUB64rr %15:gr64(tied-def 0), killed %128:gr64, implicit-def $eflags
  JCC_1 %bb.18, 12, implicit $eflags
  JMP_1 %bb.19

bb.19.for.end62:
; predecessors: %bb.16, %bb.18
  successors: %bb.16(0x7c000000), %bb.20(0x04000000); %bb.16(96.88%), %bb.20(3.12%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %130:gr32 = MOV32ri 10
  $edi = COPY %130:gr32
  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %131:gr32 = COPY $eax
  %16:gr32 = nsw ADD32ri8 %13:gr32(tied-def 0), -1, implicit-def dead $eflags
  %132:gr32 = SUB32ri8 %16:gr32(tied-def 0), -11, implicit-def $eflags
  JCC_1 %bb.16, 15, implicit $eflags
  JMP_1 %bb.20

bb.20.for.inc66:
; predecessors: %bb.19
  successors: %bb.15(0x7c000000), %bb.21(0x04000000); %bb.15(96.88%), %bb.21(3.12%)

  %17:fr64 = nofpexcept ADDSDrm %12:fr64(tied-def 0), $rip, 1, $noreg, %const.12, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %133:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.13, $noreg :: (load 8 from constant-pool)
  nofpexcept UCOMISDrr killed %133:fr64, %17:fr64, implicit-def $eflags, implicit $mxcsr
  JCC_1 %bb.15, 7, implicit $eflags
  JMP_1 %bb.21

bb.21.for.inc68:
; predecessors: %bb.20
  successors: %bb.14(0x7c000000), %bb.22(0x04000000); %bb.14(96.88%), %bb.22(3.12%)

  %18:gr32 = nsw ADD32ri8 %10:gr32(tied-def 0), -1, implicit-def dead $eflags
  %134:gr32 = SUB32ri8 %10:gr32(tied-def 0), 1, implicit-def $eflags
  JCC_1 %bb.14, 15, implicit $eflags
  JMP_1 %bb.22

bb.22.for.inc71:
; predecessors: %bb.21
  successors: %bb.23(0x04000000), %bb.13(0x7c000000); %bb.23(3.12%), %bb.13(96.88%)

  %19:fr64 = nofpexcept ADDSDrm %8:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %20:gr32 = nuw nsw ADD32ri8 %9:gr32(tied-def 0), 1, implicit-def dead $eflags
  %135:gr32 = SUB32ri8 %20:gr32(tied-def 0), 10, implicit-def $eflags
  JCC_1 %bb.13, 5, implicit $eflags
  JMP_1 %bb.23

bb.23.for.end73:
; predecessors: %bb.22
  successors: %bb.24(0x80000000); %bb.24(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %137:gr64 = MOV32ri64 @str.11
  $rdi = COPY %137:gr64
  CALL64pcrel32 @puts, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %138:gr32 = COPY $eax
  %139:gr32 = MOV32r0 implicit-def dead $eflags
  %136:gr64 = SUBREG_TO_REG 0, killed %139:gr32, %subreg.sub_32bit

bb.24.for.body77:
; predecessors: %bb.23, %bb.24
  successors: %bb.25(0x04000000), %bb.24(0x7c000000); %bb.25(3.12%), %bb.24(96.88%)

  %21:gr64 = PHI %136:gr64, %bb.23, %22:gr64, %bb.24
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %140:gr64 = LEA64r %stack.2.q, 1, $noreg, 0, $noreg
  $rdi = COPY %21:gr64
  $rsi = COPY %140:gr64
  CALL64pcrel32 @usqrt, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %141:gr32 = MOV32rm %stack.2.q, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.27, align 8, !tbaa !9)
  %142:gr32 = COPY %21.sub_32bit:gr64
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %143:gr64 = MOV32ri64 @.str.5
  %144:gr32 = MOV32r0 implicit-def dead $eflags
  %145:gr8 = COPY %144.sub_8bit:gr32
  $rdi = COPY %143:gr64
  $esi = COPY %142:gr32
  $edx = COPY %141:gr32
  $al = COPY %145:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit $edx, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %146:gr32 = COPY $eax
  %22:gr64 = nuw nsw ADD64ri8 %21:gr64(tied-def 0), 1, implicit-def dead $eflags
  %147:gr64 = SUB64ri32 %22:gr64(tied-def 0), 1001, implicit-def $eflags
  JCC_1 %bb.24, 5, implicit $eflags
  JMP_1 %bb.25

bb.25.for.end81:
; predecessors: %bb.24
  successors: %bb.26(0x80000000); %bb.26(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %150:gr64 = MOV32ri64 1072497001
  %151:gr64 = LEA64r %stack.2.q, 1, $noreg, 0, $noreg
  $rdi = COPY %150:gr64
  $rsi = COPY %151:gr64
  CALL64pcrel32 @usqrt, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %152:gr32 = MOV32rm %stack.2.q, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.29, align 8, !tbaa !9)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %153:gr64 = MOV32ri64 @.str.6
  %154:gr32 = MOV32r0 implicit-def dead $eflags
  %155:gr8 = COPY %154.sub_8bit:gr32
  $rdi = COPY %153:gr64
  $rsi = COPY %150:gr64
  $edx = COPY %152:gr32
  $al = COPY %155:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $edx, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %156:gr32 = COPY $eax
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %157:gr64 = MOV32ri64 @str.12
  $rdi = COPY %157:gr64
  CALL64pcrel32 @puts, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %158:gr32 = COPY $eax
  %149:fr64 = FsFLD0SD
  %148:gr32 = MOV32ri 361

bb.26.for.body88:
; predecessors: %bb.25, %bb.26
  successors: %bb.27(0x04000000), %bb.26(0x7c000000); %bb.27(3.12%), %bb.26(96.88%)

  %23:gr32 = PHI %148:gr32, %bb.25, %26:gr32, %bb.26
  %24:fr64 = PHI %149:fr64, %bb.25, %25:fr64, %bb.26
  %159:fr64 = nofpexcept MULSDrm %24:fr64(tied-def 0), $rip, 1, $noreg, %const.14, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %160:fr64 = nofpexcept DIVSDrm %159:fr64(tied-def 0), $rip, 1, $noreg, %const.15, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %161:gr64 = MOV32ri64 @.str.8
  %162:gr8 = MOV8ri 2
  $rdi = COPY %161:gr64
  $xmm0 = COPY %24:fr64
  $xmm1 = COPY %160:fr64
  $al = COPY %162:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $xmm1, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %163:gr32 = COPY $eax
  %25:fr64 = nofpexcept ADDSDrm %24:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %26:gr32 = ADD32ri8 %23:gr32(tied-def 0), -1, implicit-def $eflags
  JCC_1 %bb.26, 5, implicit $eflags
  JMP_1 %bb.27

bb.27.for.end94:
; predecessors: %bb.26
  successors: %bb.28(0x80000000); %bb.28(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %165:gr64 = MOV32ri64 @.str.9
  %166:gr32 = MOV32r0 implicit-def dead $eflags
  %167:gr8 = COPY %166.sub_8bit:gr32
  $rdi = COPY %165:gr64
  $al = COPY %167:gr8
  CALL64pcrel32 @puts, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %168:gr32 = COPY $eax
  %164:fr64 = FsFLD0SD

bb.28.for.body103:
; predecessors: %bb.27, %bb.28
  successors: %bb.29(0x04000000), %bb.28(0x7c000000); %bb.29(3.12%), %bb.28(96.88%)

  %27:fr64 = PHI %164:fr64, %bb.27, %28:fr64, %bb.28
  %169:fr64 = nofpexcept MULSDrm %27:fr64(tied-def 0), $rip, 1, $noreg, %const.15, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %170:fr64 = nofpexcept DIVSDrm %169:fr64(tied-def 0), $rip, 1, $noreg, %const.14, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %171:gr64 = MOV32ri64 @.str.10
  %172:gr8 = MOV8ri 2
  $rdi = COPY %171:gr64
  $xmm0 = COPY %27:fr64
  $xmm1 = COPY %170:fr64
  $al = COPY %172:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $xmm1, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %173:gr32 = COPY $eax
  %28:fr64 = nofpexcept ADDSDrm %27:fr64(tied-def 0), $rip, 1, $noreg, %const.16, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %174:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.17, $noreg :: (load 8 from constant-pool)
  nofpexcept UCOMISDrr killed %174:fr64, %28:fr64, implicit-def $eflags, implicit $mxcsr
  JCC_1 %bb.28, 3, implicit $eflags
  JMP_1 %bb.29

bb.29.for.end114:
; predecessors: %bb.28

  %175:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY %175:gr32
  RET 0, $eax

# End machine code for function main.

# *** IR Dump After Remove dead machine instructions ***:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=24, align=16, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
Constant Pool:
  cp#0: 1.000000e+00, align=8
  cp#1: -1.050000e+01, align=8
  cp#2: 3.200000e+01, align=8
  cp#3: -3.000000e+01, align=8
  cp#4: -4.500000e+00, align=8
  cp#5: 1.700000e+01, align=8
  cp#6: -3.500000e+00, align=8
  cp#7: 2.200000e+01, align=8
  cp#8: -3.100000e+01, align=8
  cp#9: -1.370000e+01, align=8
  cp#10: -3.500000e+01, align=8
  cp#11: 5.000000e+00, align=8
  cp#12: 5.000000e-01, align=8
  cp#13: 1.500000e+01, align=8
  cp#14: 0x400921FB54442D18, align=8
  cp#15: 1.800000e+02, align=8
  cp#16: 0x3F91DF46A2529D39, align=8
  cp#17: 0x401921FB97600B9B, align=8

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.3(0x30000000); %bb.1(62.50%), %bb.3(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %29:gr64 = MOV32ri64 @str
  $rdi = COPY %29:gr64
  CALL64pcrel32 @puts, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %31:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %32:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
  %33:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
  %34:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
  %35:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %36:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %31:fr64
  $xmm1 = COPY %32:fr64
  $xmm2 = COPY %33:fr64
  $xmm3 = COPY %34:fr64
  $rdi = COPY %35:gr64
  $rsi = COPY %36:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %37:gr64 = MOV32ri64 @.str.1
  %38:gr32 = MOV32r0 implicit-def dead $eflags
  %39:gr8 = COPY %38.sub_8bit:gr32
  $rdi = COPY %37:gr64
  $al = COPY %39:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.3, 14, implicit $eflags
  JMP_1 %bb.1

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  %42:gr32 = MOV32r0 implicit-def dead $eflags
  %41:gr64 = SUBREG_TO_REG 0, killed %42:gr32, %subreg.sub_32bit

bb.2.for.body:
; predecessors: %bb.1, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  %0:gr64_nosp = PHI %41:gr64, %bb.1, %1:gr64, %bb.2
  %43:fr64 = MOVSDrm_alt %stack.0.x, 8, %0:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep6, !tbaa !5)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %44:gr64 = MOV32ri64 @.str.2
  %45:gr8 = MOV8ri 1
  $rdi = COPY %44:gr64
  $xmm0 = COPY %43:fr64
  $al = COPY %45:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %1:gr64 = nuw nsw ADD64ri8 %0:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
  %47:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  %48:gr64 = SUB64rr %1:gr64(tied-def 0), killed %47:gr64, implicit-def $eflags
  JCC_1 %bb.2, 12, implicit $eflags
  JMP_1 %bb.3

bb.3.for.end:
; predecessors: %bb.0, %bb.2
  successors: %bb.4(0x50000000), %bb.6(0x30000000); %bb.4(62.50%), %bb.6(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %49:gr32 = MOV32ri 10
  $edi = COPY %49:gr32
  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %51:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %52:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.4, $noreg :: (load 8 from constant-pool)
  %53:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.5, $noreg :: (load 8 from constant-pool)
  %54:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
  %55:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %56:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %51:fr64
  $xmm1 = COPY %52:fr64
  $xmm2 = COPY %53:fr64
  $xmm3 = COPY %54:fr64
  $rdi = COPY %55:gr64
  $rsi = COPY %56:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %57:gr64 = MOV32ri64 @.str.1
  %58:gr32 = MOV32r0 implicit-def dead $eflags
  %59:gr8 = COPY %58.sub_8bit:gr32
  $rdi = COPY %57:gr64
  $al = COPY %59:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.6, 14, implicit $eflags
  JMP_1 %bb.4

bb.4.for.body8.preheader:
; predecessors: %bb.3
  successors: %bb.5(0x80000000); %bb.5(100.00%)

  %62:gr32 = MOV32r0 implicit-def dead $eflags
  %61:gr64 = SUBREG_TO_REG 0, killed %62:gr32, %subreg.sub_32bit

bb.5.for.body8:
; predecessors: %bb.4, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  %2:gr64_nosp = PHI %61:gr64, %bb.4, %3:gr64, %bb.5
  %63:fr64 = MOVSDrm_alt %stack.0.x, 8, %2:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep5, !tbaa !5)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %64:gr64 = MOV32ri64 @.str.2
  %65:gr8 = MOV8ri 1
  $rdi = COPY %64:gr64
  $xmm0 = COPY %63:fr64
  $al = COPY %65:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr64 = nuw nsw ADD64ri8 %2:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
  %67:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  %68:gr64 = SUB64rr %3:gr64(tied-def 0), killed %67:gr64, implicit-def $eflags
  JCC_1 %bb.5, 12, implicit $eflags
  JMP_1 %bb.6

bb.6.for.end14:
; predecessors: %bb.3, %bb.5
  successors: %bb.7(0x50000000), %bb.9(0x30000000); %bb.7(62.50%), %bb.9(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %69:gr32 = MOV32ri 10
  $edi = COPY %69:gr32
  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %71:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %72:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.6, $noreg :: (load 8 from constant-pool)
  %73:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.7, $noreg :: (load 8 from constant-pool)
  %74:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.8, $noreg :: (load 8 from constant-pool)
  %75:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %76:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %71:fr64
  $xmm1 = COPY %72:fr64
  $xmm2 = COPY %73:fr64
  $xmm3 = COPY %74:fr64
  $rdi = COPY %75:gr64
  $rsi = COPY %76:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %77:gr64 = MOV32ri64 @.str.1
  %78:gr32 = MOV32r0 implicit-def dead $eflags
  %79:gr8 = COPY %78.sub_8bit:gr32
  $rdi = COPY %77:gr64
  $al = COPY %79:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.9, 14, implicit $eflags
  JMP_1 %bb.7

bb.7.for.body20.preheader:
; predecessors: %bb.6
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  %82:gr32 = MOV32r0 implicit-def dead $eflags
  %81:gr64 = SUBREG_TO_REG 0, killed %82:gr32, %subreg.sub_32bit

bb.8.for.body20:
; predecessors: %bb.7, %bb.8
  successors: %bb.8(0x7c000000), %bb.9(0x04000000); %bb.8(96.88%), %bb.9(3.12%)

  %4:gr64_nosp = PHI %81:gr64, %bb.7, %5:gr64, %bb.8
  %83:fr64 = MOVSDrm_alt %stack.0.x, 8, %4:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep4, !tbaa !5)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %84:gr64 = MOV32ri64 @.str.2
  %85:gr8 = MOV8ri 1
  $rdi = COPY %84:gr64
  $xmm0 = COPY %83:fr64
  $al = COPY %85:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %5:gr64 = nuw nsw ADD64ri8 %4:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
  %87:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  %88:gr64 = SUB64rr %5:gr64(tied-def 0), killed %87:gr64, implicit-def $eflags
  JCC_1 %bb.8, 12, implicit $eflags
  JMP_1 %bb.9

bb.9.for.end26:
; predecessors: %bb.6, %bb.8
  successors: %bb.10(0x50000000), %bb.12(0x30000000); %bb.10(62.50%), %bb.12(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %89:gr32 = MOV32ri 10
  $edi = COPY %89:gr32
  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %91:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.9, $noreg :: (load 8 from constant-pool)
  %92:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %93:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.10, $noreg :: (load 8 from constant-pool)
  %94:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %95:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %92:fr64
  $xmm1 = COPY %91:fr64
  $xmm2 = COPY %92:fr64
  $xmm3 = COPY %93:fr64
  $rdi = COPY %94:gr64
  $rsi = COPY %95:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %96:gr64 = MOV32ri64 @.str.1
  %97:gr32 = MOV32r0 implicit-def dead $eflags
  %98:gr8 = COPY %97.sub_8bit:gr32
  $rdi = COPY %96:gr64
  $al = COPY %98:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.12, 14, implicit $eflags
  JMP_1 %bb.10

bb.10.for.body32.preheader:
; predecessors: %bb.9
  successors: %bb.11(0x80000000); %bb.11(100.00%)

  %101:gr32 = MOV32r0 implicit-def dead $eflags
  %100:gr64 = SUBREG_TO_REG 0, killed %101:gr32, %subreg.sub_32bit

bb.11.for.body32:
; predecessors: %bb.10, %bb.11
  successors: %bb.11(0x7c000000), %bb.12(0x04000000); %bb.11(96.88%), %bb.12(3.12%)

  %6:gr64_nosp = PHI %100:gr64, %bb.10, %7:gr64, %bb.11
  %102:fr64 = MOVSDrm_alt %stack.0.x, 8, %6:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep3, !tbaa !5)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %103:gr64 = MOV32ri64 @.str.2
  %104:gr8 = MOV8ri 1
  $rdi = COPY %103:gr64
  $xmm0 = COPY %102:fr64
  $al = COPY %104:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %7:gr64 = nuw nsw ADD64ri8 %6:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
  %106:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  %107:gr64 = SUB64rr %7:gr64(tied-def 0), killed %106:gr64, implicit-def $eflags
  JCC_1 %bb.11, 12, implicit $eflags
  JMP_1 %bb.12

bb.12.for.end38:
; predecessors: %bb.9, %bb.11
  successors: %bb.13(0x80000000); %bb.13(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %110:gr32 = MOV32ri 10
  $edi = COPY %110:gr32
  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %109:gr32 = MOV32ri 1
  %108:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)

bb.13.for.cond43.preheader:
; predecessors: %bb.12, %bb.22
  successors: %bb.14(0x80000000); %bb.14(100.00%)

  %8:fr64 = PHI %108:fr64, %bb.12, %19:fr64, %bb.22
  %9:gr32 = PHI %109:gr32, %bb.12, %20:gr32, %bb.22
  %112:gr32 = MOV32ri 10

bb.14.for.cond46.preheader:
; predecessors: %bb.13, %bb.21
  successors: %bb.15(0x80000000); %bb.15(100.00%)

  %10:gr32 = PHI %112:gr32, %bb.13, %18:gr32, %bb.21
  %11:fr64 = CVTSI2SDrr %10:gr32
  %113:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.11, $noreg :: (load 8 from constant-pool)

bb.15.for.cond49.preheader:
; predecessors: %bb.14, %bb.20
  successors: %bb.16(0x80000000); %bb.16(100.00%)

  %12:fr64 = PHI %113:fr64, %bb.14, %17:fr64, %bb.20
  %114:gr32 = MOV32ri -1

bb.16.for.body51:
; predecessors: %bb.15, %bb.19
  successors: %bb.17(0x50000000), %bb.19(0x30000000); %bb.17(62.50%), %bb.19(37.50%)

  %13:gr32 = PHI %114:gr32, %bb.15, %16:gr32, %bb.19
  %115:fr64 = CVTSI2SDrr %13:gr32
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %116:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %117:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %8:fr64
  $xmm1 = COPY %11:fr64
  $xmm2 = COPY %12:fr64
  $xmm3 = COPY %115:fr64
  $rdi = COPY %116:gr64
  $rsi = COPY %117:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %118:gr64 = MOV32ri64 @.str.1
  %119:gr32 = MOV32r0 implicit-def dead $eflags
  %120:gr8 = COPY %119.sub_8bit:gr32
  $rdi = COPY %118:gr64
  $al = COPY %120:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.19, 14, implicit $eflags
  JMP_1 %bb.17

bb.17.for.body56.preheader:
; predecessors: %bb.16
  successors: %bb.18(0x80000000); %bb.18(100.00%)

  %123:gr32 = MOV32r0 implicit-def dead $eflags
  %122:gr64 = SUBREG_TO_REG 0, killed %123:gr32, %subreg.sub_32bit

bb.18.for.body56:
; predecessors: %bb.17, %bb.18
  successors: %bb.18(0x7c000000), %bb.19(0x04000000); %bb.18(96.88%), %bb.19(3.12%)

  %14:gr64_nosp = PHI %122:gr64, %bb.17, %15:gr64, %bb.18
  %124:fr64 = MOVSDrm_alt %stack.0.x, 8, %14:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep, !tbaa !5)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %125:gr64 = MOV32ri64 @.str.2
  %126:gr8 = MOV8ri 1
  $rdi = COPY %125:gr64
  $xmm0 = COPY %124:fr64
  $al = COPY %126:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %15:gr64 = nuw nsw ADD64ri8 %14:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
  %128:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  %129:gr64 = SUB64rr %15:gr64(tied-def 0), killed %128:gr64, implicit-def $eflags
  JCC_1 %bb.18, 12, implicit $eflags
  JMP_1 %bb.19

bb.19.for.end62:
; predecessors: %bb.16, %bb.18
  successors: %bb.16(0x7c000000), %bb.20(0x04000000); %bb.16(96.88%), %bb.20(3.12%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %130:gr32 = MOV32ri 10
  $edi = COPY %130:gr32
  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %16:gr32 = nsw ADD32ri8 %13:gr32(tied-def 0), -1, implicit-def dead $eflags
  %132:gr32 = SUB32ri8 %16:gr32(tied-def 0), -11, implicit-def $eflags
  JCC_1 %bb.16, 15, implicit $eflags
  JMP_1 %bb.20

bb.20.for.inc66:
; predecessors: %bb.19
  successors: %bb.15(0x7c000000), %bb.21(0x04000000); %bb.15(96.88%), %bb.21(3.12%)

  %17:fr64 = nofpexcept ADDSDrm %12:fr64(tied-def 0), $rip, 1, $noreg, %const.12, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %133:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.13, $noreg :: (load 8 from constant-pool)
  nofpexcept UCOMISDrr killed %133:fr64, %17:fr64, implicit-def $eflags, implicit $mxcsr
  JCC_1 %bb.15, 7, implicit $eflags
  JMP_1 %bb.21

bb.21.for.inc68:
; predecessors: %bb.20
  successors: %bb.14(0x7c000000), %bb.22(0x04000000); %bb.14(96.88%), %bb.22(3.12%)

  %18:gr32 = nsw ADD32ri8 %10:gr32(tied-def 0), -1, implicit-def dead $eflags
  %134:gr32 = SUB32ri8 %10:gr32(tied-def 0), 1, implicit-def $eflags
  JCC_1 %bb.14, 15, implicit $eflags
  JMP_1 %bb.22

bb.22.for.inc71:
; predecessors: %bb.21
  successors: %bb.23(0x04000000), %bb.13(0x7c000000); %bb.23(3.12%), %bb.13(96.88%)

  %19:fr64 = nofpexcept ADDSDrm %8:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %20:gr32 = nuw nsw ADD32ri8 %9:gr32(tied-def 0), 1, implicit-def dead $eflags
  %135:gr32 = SUB32ri8 %20:gr32(tied-def 0), 10, implicit-def $eflags
  JCC_1 %bb.13, 5, implicit $eflags
  JMP_1 %bb.23

bb.23.for.end73:
; predecessors: %bb.22
  successors: %bb.24(0x80000000); %bb.24(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %137:gr64 = MOV32ri64 @str.11
  $rdi = COPY %137:gr64
  CALL64pcrel32 @puts, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %139:gr32 = MOV32r0 implicit-def dead $eflags
  %136:gr64 = SUBREG_TO_REG 0, killed %139:gr32, %subreg.sub_32bit

bb.24.for.body77:
; predecessors: %bb.23, %bb.24
  successors: %bb.25(0x04000000), %bb.24(0x7c000000); %bb.25(3.12%), %bb.24(96.88%)

  %21:gr64 = PHI %136:gr64, %bb.23, %22:gr64, %bb.24
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %140:gr64 = LEA64r %stack.2.q, 1, $noreg, 0, $noreg
  $rdi = COPY %21:gr64
  $rsi = COPY %140:gr64
  CALL64pcrel32 @usqrt, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %141:gr32 = MOV32rm %stack.2.q, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.27, align 8, !tbaa !9)
  %142:gr32 = COPY %21.sub_32bit:gr64
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %143:gr64 = MOV32ri64 @.str.5
  %144:gr32 = MOV32r0 implicit-def dead $eflags
  %145:gr8 = COPY %144.sub_8bit:gr32
  $rdi = COPY %143:gr64
  $esi = COPY %142:gr32
  $edx = COPY %141:gr32
  $al = COPY %145:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $esi, implicit $edx, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %22:gr64 = nuw nsw ADD64ri8 %21:gr64(tied-def 0), 1, implicit-def dead $eflags
  %147:gr64 = SUB64ri32 %22:gr64(tied-def 0), 1001, implicit-def $eflags
  JCC_1 %bb.24, 5, implicit $eflags
  JMP_1 %bb.25

bb.25.for.end81:
; predecessors: %bb.24
  successors: %bb.26(0x80000000); %bb.26(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %150:gr64 = MOV32ri64 1072497001
  %151:gr64 = LEA64r %stack.2.q, 1, $noreg, 0, $noreg
  $rdi = COPY %150:gr64
  $rsi = COPY %151:gr64
  CALL64pcrel32 @usqrt, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %152:gr32 = MOV32rm %stack.2.q, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.29, align 8, !tbaa !9)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %153:gr64 = MOV32ri64 @.str.6
  %154:gr32 = MOV32r0 implicit-def dead $eflags
  %155:gr8 = COPY %154.sub_8bit:gr32
  $rdi = COPY %153:gr64
  $rsi = COPY %150:gr64
  $edx = COPY %152:gr32
  $al = COPY %155:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $edx, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %157:gr64 = MOV32ri64 @str.12
  $rdi = COPY %157:gr64
  CALL64pcrel32 @puts, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %149:fr64 = FsFLD0SD
  %148:gr32 = MOV32ri 361

bb.26.for.body88:
; predecessors: %bb.25, %bb.26
  successors: %bb.27(0x04000000), %bb.26(0x7c000000); %bb.27(3.12%), %bb.26(96.88%)

  %23:gr32 = PHI %148:gr32, %bb.25, %26:gr32, %bb.26
  %24:fr64 = PHI %149:fr64, %bb.25, %25:fr64, %bb.26
  %159:fr64 = nofpexcept MULSDrm %24:fr64(tied-def 0), $rip, 1, $noreg, %const.14, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %160:fr64 = nofpexcept DIVSDrm %159:fr64(tied-def 0), $rip, 1, $noreg, %const.15, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %161:gr64 = MOV32ri64 @.str.8
  %162:gr8 = MOV8ri 2
  $rdi = COPY %161:gr64
  $xmm0 = COPY %24:fr64
  $xmm1 = COPY %160:fr64
  $al = COPY %162:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $xmm1, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %25:fr64 = nofpexcept ADDSDrm %24:fr64(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %26:gr32 = ADD32ri8 %23:gr32(tied-def 0), -1, implicit-def $eflags
  JCC_1 %bb.26, 5, implicit $eflags
  JMP_1 %bb.27

bb.27.for.end94:
; predecessors: %bb.26
  successors: %bb.28(0x80000000); %bb.28(100.00%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %165:gr64 = MOV32ri64 @.str.9
  %166:gr32 = MOV32r0 implicit-def dead $eflags
  %167:gr8 = COPY %166.sub_8bit:gr32
  $rdi = COPY %165:gr64
  $al = COPY %167:gr8
  CALL64pcrel32 @puts, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %164:fr64 = FsFLD0SD

bb.28.for.body103:
; predecessors: %bb.27, %bb.28
  successors: %bb.29(0x04000000), %bb.28(0x7c000000); %bb.29(3.12%), %bb.28(96.88%)

  %27:fr64 = PHI %164:fr64, %bb.27, %28:fr64, %bb.28
  %169:fr64 = nofpexcept MULSDrm %27:fr64(tied-def 0), $rip, 1, $noreg, %const.15, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %170:fr64 = nofpexcept DIVSDrm %169:fr64(tied-def 0), $rip, 1, $noreg, %const.14, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %171:gr64 = MOV32ri64 @.str.10
  %172:gr8 = MOV8ri 2
  $rdi = COPY %171:gr64
  $xmm0 = COPY %27:fr64
  $xmm1 = COPY %170:fr64
  $al = COPY %172:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $xmm1, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %28:fr64 = nofpexcept ADDSDrm %27:fr64(tied-def 0), $rip, 1, $noreg, %const.16, $noreg, implicit $mxcsr :: (load 8 from constant-pool)
  %174:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.17, $noreg :: (load 8 from constant-pool)
  nofpexcept UCOMISDrr killed %174:fr64, %28:fr64, implicit-def $eflags, implicit $mxcsr
  JCC_1 %bb.28, 3, implicit $eflags
  JMP_1 %bb.29

bb.29.for.end114:
; predecessors: %bb.28

  %175:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY %175:gr32
  RET 0, $eax

# End machine code for function main.

# *** IR Dump After Early If-Conversion ***:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=24, align=16, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
Constant Pool:
  cp#0: 1.000000e+00, align=8
  cp#1: -1.050000e+01, align=8
  cp#2: 3.200000e+01, align=8
  cp#3: -3.000000e+01, align=8
  cp#4: -4.500000e+00, align=8
  cp#5: 1.700000e+01, align=8
  cp#6: -3.500000e+00, align=8
  cp#7: 2.200000e+01, align=8
  cp#8: -3.100000e+01, align=8
  cp#9: -1.370000e+01, align=8
  cp#10: -3.500000e+01, align=8
  cp#11: 5.000000e+00, align=8
  cp#12: 5.000000e-01, align=8
  cp#13: 1.500000e+01, align=8
  cp#14: 0x400921FB54442D18, align=8
  cp#15: 1.800000e+02, align=8
  cp#16: 0x3F91DF46A2529D39, align=8
  cp#17: 0x401921FB97600B9B, align=8

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.3(0x30000000); %bb.1(62.50%), %bb.3(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %29:gr64 = MOV32ri64 @str
  $rdi = COPY %29:gr64
  CALL64pcrel32 @puts, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %31:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %32:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.1, $noreg :: (load 8 from constant-pool)
  %33:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.2, $noreg :: (load 8 from constant-pool)
  %34:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
  %35:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %36:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %31:fr64
  $xmm1 = COPY %32:fr64
  $xmm2 = COPY %33:fr64
  $xmm3 = COPY %34:fr64
  $rdi = COPY %35:gr64
  $rsi = COPY %36:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %37:gr64 = MOV32ri64 @.str.1
  %38:gr32 = MOV32r0 implicit-def dead $eflags
  %39:gr8 = COPY %38.sub_8bit:gr32
  $rdi = COPY %37:gr64
  $al = COPY %39:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.3, 14, implicit $eflags
  JMP_1 %bb.1

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  %42:gr32 = MOV32r0 implicit-def dead $eflags
  %41:gr64 = SUBREG_TO_REG 0, killed %42:gr32, %subreg.sub_32bit

bb.2.for.body:
; predecessors: %bb.1, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  %0:gr64_nosp = PHI %41:gr64, %bb.1, %1:gr64, %bb.2
  %43:fr64 = MOVSDrm_alt %stack.0.x, 8, %0:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep6, !tbaa !5)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %44:gr64 = MOV32ri64 @.str.2
  %45:gr8 = MOV8ri 1
  $rdi = COPY %44:gr64
  $xmm0 = COPY %43:fr64
  $al = COPY %45:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %1:gr64 = nuw nsw ADD64ri8 %0:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
  %47:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  %48:gr64 = SUB64rr %1:gr64(tied-def 0), killed %47:gr64, implicit-def $eflags
  JCC_1 %bb.2, 12, implicit $eflags
  JMP_1 %bb.3

bb.3.for.end:
; predecessors: %bb.0, %bb.2
  successors: %bb.4(0x50000000), %bb.6(0x30000000); %bb.4(62.50%), %bb.6(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %49:gr32 = MOV32ri 10
  $edi = COPY %49:gr32
  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %51:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %52:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.4, $noreg :: (load 8 from constant-pool)
  %53:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.5, $noreg :: (load 8 from constant-pool)
  %54:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.3, $noreg :: (load 8 from constant-pool)
  %55:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %56:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %51:fr64
  $xmm1 = COPY %52:fr64
  $xmm2 = COPY %53:fr64
  $xmm3 = COPY %54:fr64
  $rdi = COPY %55:gr64
  $rsi = COPY %56:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %57:gr64 = MOV32ri64 @.str.1
  %58:gr32 = MOV32r0 implicit-def dead $eflags
  %59:gr8 = COPY %58.sub_8bit:gr32
  $rdi = COPY %57:gr64
  $al = COPY %59:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.6, 14, implicit $eflags
  JMP_1 %bb.4

bb.4.for.body8.preheader:
; predecessors: %bb.3
  successors: %bb.5(0x80000000); %bb.5(100.00%)

  %62:gr32 = MOV32r0 implicit-def dead $eflags
  %61:gr64 = SUBREG_TO_REG 0, killed %62:gr32, %subreg.sub_32bit

bb.5.for.body8:
; predecessors: %bb.4, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  %2:gr64_nosp = PHI %61:gr64, %bb.4, %3:gr64, %bb.5
  %63:fr64 = MOVSDrm_alt %stack.0.x, 8, %2:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep5, !tbaa !5)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %64:gr64 = MOV32ri64 @.str.2
  %65:gr8 = MOV8ri 1
  $rdi = COPY %64:gr64
  $xmm0 = COPY %63:fr64
  $al = COPY %65:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr64 = nuw nsw ADD64ri8 %2:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
  %67:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  %68:gr64 = SUB64rr %3:gr64(tied-def 0), killed %67:gr64, implicit-def $eflags
  JCC_1 %bb.5, 12, implicit $eflags
  JMP_1 %bb.6

bb.6.for.end14:
; predecessors: %bb.3, %bb.5
  successors: %bb.7(0x50000000), %bb.9(0x30000000); %bb.7(62.50%), %bb.9(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %69:gr32 = MOV32ri 10
  $edi = COPY %69:gr32
  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %71:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %72:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.6, $noreg :: (load 8 from constant-pool)
  %73:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.7, $noreg :: (load 8 from constant-pool)
  %74:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.8, $noreg :: (load 8 from constant-pool)
  %75:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %76:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %71:fr64
  $xmm1 = COPY %72:fr64
  $xmm2 = COPY %73:fr64
  $xmm3 = COPY %74:fr64
  $rdi = COPY %75:gr64
  $rsi = COPY %76:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %77:gr64 = MOV32ri64 @.str.1
  %78:gr32 = MOV32r0 implicit-def dead $eflags
  %79:gr8 = COPY %78.sub_8bit:gr32
  $rdi = COPY %77:gr64
  $al = COPY %79:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.9, 14, implicit $eflags
  JMP_1 %bb.7

bb.7.for.body20.preheader:
; predecessors: %bb.6
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  %82:gr32 = MOV32r0 implicit-def dead $eflags
  %81:gr64 = SUBREG_TO_REG 0, killed %82:gr32, %subreg.sub_32bit

bb.8.for.body20:
; predecessors: %bb.7, %bb.8
  successors: %bb.8(0x7c000000), %bb.9(0x04000000); %bb.8(96.88%), %bb.9(3.12%)

  %4:gr64_nosp = PHI %81:gr64, %bb.7, %5:gr64, %bb.8
  %83:fr64 = MOVSDrm_alt %stack.0.x, 8, %4:gr64_nosp, 0, $noreg :: (load 8 from %ir.scevgep4, !tbaa !5)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %84:gr64 = MOV32ri64 @.str.2
  %85:gr8 = MOV8ri 1
  $rdi = COPY %84:gr64
  $xmm0 = COPY %83:fr64
  $al = COPY %85:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $xmm0, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %5:gr64 = nuw nsw ADD64ri8 %4:gr64_nosp(tied-def 0), 1, implicit-def dead $eflags
  %87:gr64 = MOVSX64rm32 %stack.1.solutions, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  %88:gr64 = SUB64rr %5:gr64(tied-def 0), killed %87:gr64, implicit-def $eflags
  JCC_1 %bb.8, 12, implicit $eflags
  JMP_1 %bb.9

bb.9.for.end26:
; predecessors: %bb.6, %bb.8
  successors: %bb.10(0x50000000), %bb.12(0x30000000); %bb.10(62.50%), %bb.12(37.50%)

  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %89:gr32 = MOV32ri 10
  $edi = COPY %89:gr32
  CALL64pcrel32 @putchar, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %91:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.9, $noreg :: (load 8 from constant-pool)
  %92:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load 8 from constant-pool)
  %93:fr64 = MOVSDrm_alt $rip, 1, $noreg, %const.10, $noreg :: (load 8 from constant-pool)
  %94:gr64 = LEA64r %stack.1.solutions, 1, $noreg, 0, $noreg
  %95:gr64 = LEA64r %stack.0.x, 1, $noreg, 0, $noreg
  $xmm0 = COPY %92:fr64
  $xmm1 = COPY %91:fr64
  $xmm2 = COPY %92:fr64
  $xmm3 = COPY %93:fr64
  $rdi = COPY %94:gr64
  $rsi = COPY %95:gr64
  CALL64pcrel32 @SolveCubic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $xmm0, implicit $xmm1, implicit $xmm2, implicit $xmm3, implicit $rdi, implicit $rsi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %96:gr64 = MOV32ri64 @.str.1
  %97:gr32 = MOV32r0 implicit-def dead $eflags
  %98:gr8 = COPY %97.sub_8bit:gr32
  $rdi = COPY %96:gr64
  $al = COPY %98:gr8
  CALL64pcrel32 @printf, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $al, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CMP32mi8 %stack.1.solutions, 1, $noreg, 0, $noreg, 0, implicit-def $eflags :: (dereferenceable load 4 from %ir.solutions, !tbaa !1)
  JCC_1 %bb.12, 14, implicit $eflags
  JMP_1 %bb.10

bb.10.for.body32.preheader:
; predecessors: %bb.9
  successors: %bb.11(0x80000000); %bb.11(100.00%)

  %101:gr32 = MOV32r0 implicit-def dead $eflags
  %100:gr64 = SUBREG_TO_REG 0, killed %101:gr32, %subreg.sub_32bit

bb.11.for.body32:
; predecessors: %bb.10, %bb.11
  successors: %bb.11(0x7c000000), %bb.12(0x04000000); %bb.11(96.88%), %bb.